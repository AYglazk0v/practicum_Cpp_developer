<details>
<summary>Теория + тестирование:</summary>

# Связь потоков: в поисках оптимального ввода и вывода

В прошлом уроке речь шла о том, что замена  `endl`  на  `\n`  улучшает эффективность. Разберёмся, всегда ли это происходит. Рассмотрим программу для возведения в квадрат чисел, прочитанных из стандартного ввода:

```cpp
#include <iostream>
#include <string>

#include "log_duration.h"

using namespace std;

// main с аргументами означает, что программа принимает аргументы командной строки,
// при запуске из консоли их количество будет сохранено в переменную argc,
// а значения — в argv.
// Тип const char** будет обсуждаться позже в курсе, работать с ним можно
// отчасти как с вектором: argv[0] — нулевой аргумент, argv[1] — первый. 
// argv[i] можно конвертировать в string
int main(int argc, const char** argv) {
    // Нулевой аргумент — это всегда имя программы,
    // поэтому нам нужен первый
    int arg = stoi(argv[1]);

    if (arg == 1) {
        LOG_DURATION("endl"s);
        int i;
        while (cin >> i) {
            cout << i * i << endl;
        }
    }

    if (arg == 2) {
        // Чтобы "\n" воспринималось не как перевод строки, а как 
        // слэш и буква 'n', добавим перед ним ещё один слеш:
        // два слеша в строковом (и символьном) литерале воспринимаются
        // как один (\) 
        LOG_DURATION("\\n"s);
        int i;
        while (cin >> i) {
            cout << i * i << "\n"s;
        }
    }
}

```

Эта программа принимает один числовой аргумент: единицу или двойку. Она читает числа из стандартного ввода и выдаёт их квадраты в стандартный вывод, замеряя время. Причём метод завершения строки —  `\n`  или  `endl`  — можно менять, используя аргумент командной строки. Скомпилируем программу и назовём исполняемый файл  `sqnums`. Запустим её так:

```bash
$ sqnums 1

```

Она будет радостно выводить квадраты всех введённых чисел до тех пор, пока вы не введёте символ конца файла. Затем выведет общее время работы и при этом будет использовать  `endl`. Запустим программу иначе:

```bash
$ sqnums 2

```

Тут вместо  `endl`  будет простой  `\n`.

Для запуска программы возьмём файл  `numbers.txt`, который содержит 50000 чисел от 0 до 99.

Запускать будем, перенаправляя стандартный ввод и вывод:

```bash
$ sqnums 1 >numbers2.txt <numbers.txt

```

Перенаправление символами  `>`  и  `<`  позволяет проассоциировать потоки  `cin`  и  `cout`  с файлами. Так программа будет через поток  `cin`  получать данные из файла  `numbers.txt`. Благодаря  `>`  данные из  `cout`  пойдут в файл  `numbers2.txt`, а не в окно консоли. Если хотим использовать  `\n`, меняем параметр  `1`  на  `2`:

```bash
$ sqnums 2 >numbers2.txt <numbers.txt

```

Смотрим на результаты:

```bash
$ sqnums 1 >numbers2.txt <numbers.txt
endl: 410 ms
$ sqnums 2 >numbers2.txt <numbers.txt
\n: 408 ms

```

Не столь впечатляюще. Раньше мы наблюдали чуть не десятикратное различие, а теперь оно едва заметно. Чтобы понять причину этого, обратимся к другой программе:

```cpp
#include <iostream>

using namespace std;

int main() {
    cout << "Enter x and y: "s;
    cin >> x >> y;
    cout << x + y << endl;
}

```

----------

Почему мы всегда видим надпись  `Enter x and y:`  перед вводом?

-   Очевидно, потому что выводим её в  `cout`  перед вводом.
    
-   Потому что далее в  `cout`  выводится  `endl`, сбрасывающий буфер.
    
-   Это нельзя объяснить так просто, явно чтение из  `cin`  влияет на  `cout`.
    

Совсем не очевидно, но чтение из  `cin`  заставляет буфер  `cout`  и  `cerr`  опустошаться, как если бы мы добавили  `cout.flush()`  перед ним. В этом причина медленной работы программы с  `\n`. К счастью, есть способ исправить ситуацию, отвязав  `cin`  от  `cout`  так:  `cin.tie(nullptr);`.

Дополним программу ещё одной веткой и протестируем скорость:

```cpp
#include <iostream>
#include <string>

#include "log_duration.h"

using namespace std;

int main(int argc, const char** argv) {
    // не забываем, что один аргумент — это название программы,
    // поэтому argc должно быть как минимум 2
    if (argc < 2) {
        cerr << "Пожалуйста, задайте как минимум 1 аргумент"s << endl;
        return 1;
    }

    int arg = std::stoi(argv[1]);

    if (arg == 1) {
        LOG_DURATION("endl"s);
        int i;
        while (cin >> i) {
            cout << i * i << endl;
        }
    }

    if (arg == 2) {
        LOG_DURATION("\\n"s);
        int i;
        while (cin >> i) {
            cout << i * i << "\n"s;
        }
    }

    if (arg == 3) {
        LOG_DURATION("\\n with tie"s);
        cin.tie(nullptr);
        int i;
        while (cin >> i) {
            cout << i * i << "\n"s;
        }
    }
}

```

Запускаем:

```bash
$ test-stream.exe 3 <numbers.txt >numbers2.txt
\n with tie: 89 ms

```

Совсем другое дело! Однако будьте осторожны, потому что отвязывание  `cin`  от  `cout`  повлияет на всё последующее выполнение. Если разрабатываете основную функцию программы, это не так важно. Но если подобное происходит в функции библиотеки, которая будет применяться в разных программах, такой побочный эффект крайне нежелателен. Избежать его просто — в конце работы привяжите обратно:

```cpp
...
if (arg == 3) {
    LOG_DURATION("\\n with tie"s);
    auto tied_before = cin.tie(nullptr);

    int i;
    while (cin >> i) {
        cout << i * i << "\n"s;
    }

    cin.tie(tied_before);
}
...

```

Чтобы избежать возможных проблем, используйте для этих целей класс с конструктором и деструктором для выполнения парных действий. В прошлой теме вы так измеряли время.

В этом уроке мы убедились: замена  `endl`  на  `\n`  серьёзно ускоряет использование потоков, если это критичное место вашей программы.

Ещё сильнее ускорить ввод и вывод в  `cin`  и  `cout`  может магическая команда  `ios_base::sync_with_stdio(false)`, с которой хорошо знакомы участники соревнований по программированию. Использовать её следует осторожно. Эта команда способна помешать работе при подключении сторонних библиотек, выводящих информацию в стандартный вывод, и при многопоточной работе, с которой вы ещё познакомитесь.

Команда  `sync_with_stdio`  отключает синхронизацию между стандартными потоками C и C++, а также между разными потоками выполнения, сохраняя ресурсы.

Не путайте потоки ввода и вывода  `stream`  и потоки выполнения  `thread`:

-   Потоки ввода и вывода  `stream`  передают данные между произвольным источником  `source`  и потребителем  `sink`.
-   Потоки выполнения  `thread`  позволяют одновременно выполнять несколько операций в программе. Они также используются для ускорения за счёт выполнения на разных ядрах процессора. Термины «многопоточный», «потокобезопасный» всегда относятся к потокам выполнения.

----------

Когда замена  `endl`  на  `\n`  не сможет дать значительного выигрыша? Отметьте все подходящие варианты.

-   Когда вывод производится в файл через  `ofstream`, а не через перенаправление стандартного вывода.
    
-   Когда данные выводятся в поток большими порциями.
    
-   Когда используется режим  `binary`  для записи в файл — такая оптимизация имеет смысл только для текста.
    
-   Когда читаем из  `cin`  и пишем в  `cout`, но не отвязали одно от другого.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания


Почему мы всегда видим надпись  `Enter x and y:`  перед вводом?

-   **(-)**  Очевидно, потому что выводим её в  `cout`  перед вводом.

> Как показал предыдущий урок, если мы что-то вывели в поток, это не значит, что оно там окажется сразу же. На самом деле  `std::cin`  и  `std::cout`  связаны.

-   **(-)**  Потому что далее в  `cout`  выводится  `endl`, сбрасывающий буфер.

> `endl`  выводится позднее сообщения и уж точно не может повлиять на этот вывод. В C++ прошлое не всегда определяет настоящее, но будущее на настоящее действительно никогда не может повлиять. На самом деле  `std::cin`  и  `std::cout`  связаны.

-   **(+)**  Это нельзя объяснить так просто, явно чтение из  `cin`  влияет на  `cout`.

> И эти потоки правда связаны!

----------

Когда замена  `endl`  на  `\n`  не сможет дать значительного выигрыша? Отметьте все подходящие варианты.

-   **(-)**  Когда вывод производится в файл через  `ofstream`, а не через перенаправление стандартного вывода.

> Это совершенно не важно: запись в файл производится одинаково через файловый поток или перенаправление.

-   **(+)**  Когда данные выводятся в поток большими порциями.

> В этом случае буфер всё равно будет сбрасываться, так как данные, записываемые за один раз, в него не поместятся.

-   **(-)**  Когда используется режим  `binary`  для записи в файл — такая оптимизация имеет смысл только для текста.

> Такая оптимизация эффективна вне зависимости от того, какие данные выводятся.

-   **(+)**  Когда читаем из  `cin`  и пишем в  `cout`, но не отвязали одно от другого.

> Как вы и увидели в этом уроке.

</details>

<details>
<summary>Задание:</summary>

### Задание

Разработайте класс  `StreamUntier`, который выполняет следующие действия:

-   В конструкторе — «отвязывание» потока, переданного в конструктор как аргумент.
-   В деструкторе — «привязывание» того потока, который был отвязан.

В этом уроке вы столкнулись с указателями — объектами C++, которые изучите позже в курсе. Тип указателя содержит звёздочку. Вы видели такой тип в параметре  `main`  в уроке. Метод потока  `tie`  тоже оперирует с указателем —  `ostream*`. Именно им был тип переменной  `tied_before`, выведенный автоматически в выражении  `auto tied_before = cin.tie(nullptr);`.

Интерфейс класса  `StreamUntier`  дан в заготовке кода. Добавьте конструктор, деструктор и, при необходимости, дополнительные поля.

### Ограничения

Не меняйте название класса  `StreamUntier`.

### Пример

Пример использования класса — в функции  `main`.

### Что отправлять на проверку

Отправьте на проверку реализацию класса  `StreamUntier`, которая отвязывает поток в конструкторе и привязывает обратно в деструкторе. Функция  `main`  будет игнорироваться.

### Как будет тестироваться ваш код

Будет проверено, что  `StreamUntier`  выполняет свои функции: отвязывает в конструкторе и привязывает обратно в деструкторе. Причём в деструкторе привязывается именно тот поток, который был отвязан в конструкторе.

### Подсказка

Выполните  `stream.tie(nullptr)`  в конструкторе, сохранив возвращённое значение в поле  `tied_before_`. Используйте его в деструкторе. Придётся также добавить поле класса типа  `istream&`  для того, чтобы сохранить сам  `stream`.

</details>
