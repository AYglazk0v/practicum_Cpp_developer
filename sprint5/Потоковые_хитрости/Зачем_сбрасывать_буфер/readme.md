<details>
<summary>Введение:</summary>

# Введение

Вы уже сталкивались с объектами переноса строки  `endl`  и  `\n`. В этой теме вы увидите, чем они отличаются, и научитесь выбирать подходящий под конкретную задачу объект.

Узнаете, как отвязывать и привязывать  `cin`  и  `cout`. Поймёте, в чем разница между потоками ввода и вывода  `stream`  и потоками выполнения  `thread`.

</details>

<details>
<summary>Теория + тестирование:</summary>

# Зачем сбрасывать буфер

Вместо того чтобы просто написать  `\n`  в конце литерала, для перевода строки используют  `endl`. Разберёмся почему.

```cpp
#include <fstream>
#include <string>

using namespace std;

int main() {
    ofstream out_file("ballad.txt"s);
    for (int i = 0; i < 10; ++i) {
        out_file << "С любимыми не расставайтесь\n"s;
    }

    throw;
}

```

Обратите внимание на  `throw`  в последней строке  `main`. Эта конструкция вызывает аварийное завершение программы, которое не даст выполнить код деинициализации. По идее,  `throw`  происходит уже после записи в файл, значит, повлиять на содержимое файла не может.

Запустим программу. Файл оказался пуст. Дело в том, что поток вывода оптимизирован. Записывать на диск 10 раз по одному символу — намного дольше, чем один раз записать 10 символов. Поэтому выведенный в поток текст вместо немедленной записи сохраняется в некоторое промежуточное хранилище и сбрасывается на диск только по мере наполнения этого хранилища либо в случае явной команды  `flush`. Такая оптимизация называется  **буферизацией**‎, а промежуточное хранилище  **буфером**.

Проверим на примере. Если увеличить количество строк с 10 до 10000, то буфера точно не хватит, и что-нибудь всё-таки попадёт в файл:

```
0001 С любимыми не расставайтесь
0002 С любимыми не расставайтесь
...
9924 С любимыми не расставайтесь
9925 С любимыми не расставайте

```

Раз результат работы программы выглядит подобным образом, значит, гипотеза оказалась верна: в некоторый момент данные сбросились в файл, но часть всё равно оказалась незаписанной. А теперь заменим  `\n`  на  `endl`:

```cpp
#include <fstream>
#include <string>

using namespace std;

int main() {
    ofstream out_file("ballad.txt"s);
    for (int i = 0; i < 10; ++i) {
        out_file << "С любимыми не расставайтесь"s << endl;
    }

    throw;
}

```

Вуаля, несмотря на аварийное завершение все 10 строк записались в файл. Но нужно проверить, как  `endl`  повлиял на эффективность.

----------

Примените  `LOG_DURATION`  и измерьте время записи в файл 50 000 строк: отдельно с  `\n`  и с  `endl`. Какой способ эффективнее? При тестировании используйте конфигурацию Release.

-   С  `\n`  эффективнее.
    
-   `endl`  работает быстрее.
    
-   Примерно одинаково.
    

Предположим, ваша задача — перевозить уголь из одного места в другое. Уголь поступает разными порциями — бывает и один уголёк, и целая тонна за раз. При поступлении каждой порции вы можете сразу опломбировать груз, вызвать локомотив и отправить вагон, а можете подождать, пока он наполнится, и только потом отправить. Вызов локомотива требует времени, и если делать это сразу, перевозка угля может затянуться. В итоге вы отправите 100 составов, перевозящих по одному угольку: 100 раз потратите время на пломбировку, прицепку вагона, хотя могли бы подождать, пока вагон наполнится, и сделать это только один раз. Потоки в C++ по умолчанию ждут, пока буфер — то есть вагон — наполнится, чтобы отправить сразу большое количество данных.

Сбрасывать буфер можно не только в начале новой строки, но и просто по желанию. Для этого используют манипулятор  `std::flush`  и функцию потока  `flush`:

```cpp
#include <fstream>
#include <string>

using namespace std;

int main() {
    ofstream out_file("ballad.txt"s);
    for (int i = 0; i < 10; ++i) {
        // такой же эффект, как если бы мы написали endl
        out_file << "С любимыми не расставайтесь\n"s << flush;
    }

    throw;
}

```

Как видим,  `endl`  — это вывод конца строки с одновременным сбросом буфера. Однако за всё нужно платить: сброс буфера снижает эффективность программы. Лучше избегать его, когда интерактивность вывода не требуется, но важна производительность.

Используйте  `endl`  при отладке или профилировке, если есть риск, что программа упадёт и не успеет выдать нужную информацию. В остальном  `endl`  и  `\n`  работают одинаково — ваша задача найти баланс между эффективностью и удобством.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Примените  `LOG_DURATION`  и измерьте время записи в файл 50 000 строк: отдельно с  `\n`  и с  `endl`. Какой способ эффективнее? При тестировании используйте конфигурацию Release.

-   **(+)**  С  `\n`  эффективнее.

> Действительно, с  `\n`  не просто эффективнее, а намного!

-   **(-)**  `endl`  работает быстрее.

> Видимо, у вас необычная реализация потока. На самом деле  `\n`  не просто эффективнее, а намного!

-   **(-)**  Примерно одинаково.

> Может быть, у вас очень быстрый диск и очень эффективная файловая система, а может быть, вы забыли включить оптимизацию. В любом случае в типичной ситуации использование  `\n`  намного эффективнее.

</details>
