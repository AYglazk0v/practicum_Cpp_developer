<details>
<summary>Теория:</summary>

# Два важных правила оптимизации

В предыдущем уроке нас постигла неудача: оптимизация не дала желаемого ускорения. Это показывает, что оптимизация — не всегда хорошо. Код стало сложнее писать и читать, а результат оказался неудовлетворительным. Чтобы избегать подобных неприятностей, следуйте первому правилу оптимизации.

> Первое правило оптимизации: избегайте преждевременной оптимизации.

Главные достоинства вашей программы — это надёжность, понятность и скорость. Усложняя программу ради скорости, вы ухудшаете понятность, а скорее всего, и надёжность, потому что в сложных и непонятных программах гораздо проще допустить ошибку. Особенно обидно, если результат того не стоил.

Если оптимизация сработала, и вы путём большого труда ускорили функцию, занимавшую 10 миллисекунд, до одной миллисекунды — это хорошее достижение. Но если вся программа при этом работает 10 секунд, ускорение попросту не будет заметно. Понять, где именно нужна оптимизация, поможет профилировка. Это второе правило оптимизации.

> Второе правило оптимизации: измеряйте.

Только измерения помогут выявить узкие места программы — те, где ваша программа в действительности проводит больше всего времени. Их расположение часто противоречит интуиции.

Есть даже эмпирическое правило Парето, согласно которому

> 80% всего времени выполнения программы тратится на 20% кода.

В реальных программах это соотношение может быть иным и часто даже более разительным. Но в любом случае оно говорит, что во время разработки стоит думать не только об эффективности кода, но и о том, что ему может понадобиться оптимизация.

----------

Выберите верные утверждения.

-   С++ — самый быстрый язык программирования. Любая программа, написанная на нём, будет крайне быстро решать поставленную задачу.
    
-   Оптимизация — это изменение программы, улучшающее производительность, но не меняющее результат.
    
-   В каждом компиляторе C++ есть автоматический оптимизатор, его можно отключить при необходимости.
    
-   Автоматический оптимизатор может серьёзно изменить работу программы, его лучше не применять без необходимости.
    
-   Во время разработки нужно постоянно думать о производительности и писать только оптимальный код.
    
-   Оптимизация имеет смысл только для критичных мест программы. Чтобы выявить их, используется профилировка.
    

### Задание

Это задание выполните и протестируйте в своей IDE. Сохраните решение. Оно понадобится вам для итогового проекта пятого спринта.

Внесите небольшую модификацию в свой поисковый сервер. Пусть он выводит время выполнения запросов  `FindTopDocuments`  и  `MatchDocuments`  в  `cout`. Для этого расширьте класс  `LogDuration`  так, чтобы его конструктор принимал второй аргумент типа  `ostream&`, по умолчанию равный  `cerr`. В переданный классу поток должна выводиться информация о времени работы операции. Добавьте макрос  `LOG_DURATION_STREAM`. Примеры использования этой функции и макроса:

```cpp
...
// без макроса
{
    LogDuration guard("Long task", cout);
    PerformLongTask();
}

// с макросом
{
    LOG_DURATION_STREAM("Long task", cout);
    PerformLongTask();
}
...

```

Диагностика, выводимая в  `cout`, должна называться  `Operation time`. Допустим, в  `main`  документы ищутся так:

```cpp
MatchDocuments(search_server, "пушистый -пёс"s);
...
FindTopDocuments(search_server, "пушистый -кот"s);

```

Тогда вы увидите подобный вывод:

```
Матчинг документов по запросу: пушистый -пёс
{ document_id = 1, status = 0, words = пушистый}
...
{ document_id = 4, status = 0, words =}
Operation time: 15 ms
...
Результаты поиска по запросу: пушистый -кот
{ document_id = 1, relevance = 0.143844, rating = 5 }
...
{ document_id = 17, relevance = 0.143844, rating = 5 }
Operation time: 76 ms

```

Не забудьте сохранить своё решение.

</details>

<details>
<summary>Задание:</summary>

# Ответы на задания

----------

Выберите верные утверждения.

-   **(-)**  С++ — самый быстрый язык программирования. Любая программа, написанная на нём, будет крайне быстро решать поставленную задачу.

> Программы на C++ действительно эффективны, но только если они правильно написаны.

-   **(+)**  Оптимизация — это изменение программы, улучшающее производительность, но не меняющее результат.

> Действительно. Изменения, не меняющие результат, называются «рефакторинг». Его проводят для разных целей, не только ради эффективности. Основная цель рефакторинга — улучшить код.

-   **(+)**  В каждом компиляторе C++ есть автоматический оптимизатор, его можно отключить при необходимости.

> Да, отключение оптимизатора используется для отладочных (Debug) сборок.

-   **(-)**  Автоматический оптимизатор может серьёзно изменить работу программы, его лучше не применять без необходимости.

> Его нужно использовать всегда для конечных (Release) сборок. Изменения, которые вносит оптимизатор, могут либо помешать отладке, либо выявить ошибки или неопределённое поведение, уже имеющиеся в программе.

-   **(-)**  Во время разработки нужно постоянно думать о производительности и писать только оптимальный код.

> Это крайне неправильная концепция. Её называют «преждевременная оптимизация». На самом деле следует думать об оптимальности, но руководствоваться в первую очередь качеством и понятностью кода. Большинство операций вашей программы влияют на общее время работы незначительно, следует оптимизировать только узкие места.

-   **(+)**  Оптимизация имеет смысл только для критичных мест программы. Чтобы выявить их, используется профилировка.

> Да, профилировка поможет выявить распределение расходов времени и понять, в каком именно месте кода программа проводит больше всего времени.

</details>
