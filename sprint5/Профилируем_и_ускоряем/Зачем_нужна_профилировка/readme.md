<details>
<summary>Теория + Тестирование:</summary>

# Зачем нужна профилировка

Как вы знаете, одно из самых важных преимуществ C++ перед другими современными языками программирования — скорость. Синтаксис вряд ли можно объективно назвать сильной стороной: кому-то он нравится, кому-то нет. А вот скорость программ, написанных на C++, на высоте. Тут ему на самом деле нет равных. Однако если писать синтаксически правильный, но плохой код, никакие преимущества C++ не сделают программу быстрой. Пройдя этот урок, вы узнаете, как находить проблемы производительности.

### Профилировка

Рассмотрим такой код:

```cpp
// Заголовок cstdlib понадобится для функции rand,
// выдающей случайные числа.
#include <cstdlib>
#include <iostream>
#include <vector>

using namespace std;

vector<int> ReverseVector(const vector<int>& source_vector) {
    vector<int> res;
    for (int i : source_vector) {
        res.insert(res.begin(), i);
    }

    return res;
}

// Функция считает количество ненулевых чисел в массиве
int CountPops(const vector<int>& source_vector, int begin, int end) {
    int res = 0;

    for (int i = begin; i < end; ++i) {
        if (source_vector[i]) {
            ++res;
        }
    }

    return res;
}

void AppendRandom(vector<int>& v, int n) {
    for (int i = 0; i < n; ++i) {
        // Получаем случайное число с помощью функции rand.
        // Конструкцией (rand() % 2) получим целое число в диапазоне 0..1.
        // В C++ имеются более современные генераторы случайных чисел,
        // но в данном уроке не будем их касаться.
        v.push_back(rand() % 2);
    }
}

int main() {
    vector<int> random_bits;

    // Операция << для целых чисел это сдвиг всех бит в двоичной
    // записи числа. Запишем с её помощью число 2 в степени 17 (131072)
    static const int N = 1 << 17;

    // Заполним вектор случайными числами 0 и 1.
    AppendRandom(random_bits, N);

    // Перевернём вектор задом наперёд.
    vector<int> reversed_bits = ReverseVector(random_bits);

    // Посчитаем процент единиц на начальных отрезках вектора.
    for (int i = 1, step = 1; i <= N; i += step, step *= 2) {
        // Чтобы вычислить проценты мы умножаем на литерал 100. типа double.
        // Целочисленное значение функции CountPops при этом автоматически
        // преобразуется к double, как и i.
        double rate = CountPops(reversed_bits, 0, i) * 100. / i;
        cout << "After "s << i << " bits we found "s << rate << "% pops"s
             << endl;
    }
}

```

Эта программа иллюстрирует важное следствие математического закона больших чисел: чем длиннее случайная последовательности нулей и единиц, тем больше вероятность, что процент единиц будет близок к 50%. Реверсирование вектора чисел в этой программе добавлено искусственно, чтобы потренироваться профилировать и оптимизировать код.

Запустим код и посмотрим, сколько времени займёт выполнение. Скорость зависит в том числе от оборудования. Но этот код в любом случае выполнится не моментально. Разберёмся, в чём проблема.

Для поиска узких мест проводят  **операцию профилирования**  — выборочное измерение времени выполнения участков кода. Есть несколько готовых профилировщиков — отдельных инструментов, показывающих, сколько времени работала функция. Они подключаются к вашей программе и очень часто — например, раз в миллисекунду — просматривают стек вызовов, проверяя, где выполнение происходит в данный момент. Анализируя данные профилировщика, вы легко найдёте  **узкие места**  — медленные функции, в которых программа проводит больше всего времени.

Некоторые известные профилировщики:

-   Intel®VTune™Profiler (Windows, Linux). Сложный коммерческий продукт в составе большого пакета инструментов Intel, предназначенных для анализа производительности. Имеет графический интерфейс для просмотра и составления различных отчётов о работе кода.
-   Microsoft Visual Studio (Windows). Начиная с версии 2017, в Microsoft Visual Studio входит собственный несложный профилировщик. Как и профилировщик Intel, он имеет интуитивный графический интерфейс.
-   Консольные инструменты (Linux). В ряде UNIX-подобных операционных систем есть инструменты strace, ltrace и gprof. Первые два служат для профилировки системных и библиотечных вызовов. Эти утилиты можно использовать с любой программой, они даже не требуют наличия в ней отладочной информации. gprof — это полноценный профилировщик, который может анализировать вашу программу. Он выдаёт результат в виде текстового файла.

На практике прибегать к сложным инструментам профилировки нужно не всегда. Поэтому вы напишете свой простой профилировщик. Он будет не сторонним инструментом, а встроится прямо в ваш код. Иногда такой профилировщик эффективнее, ведь он измеряет не всё, а только то, что вам нужно.

----------

Определите узкое место этой программы. В ней три операции: заполнение вектора случайными числами, реверсирование и подсчёт единиц. Можно действовать так:

-   Вставьте код из теории в свою IDE.
    
-   По очереди убирая каждую из операций и запуская программу, найдите операцию, которая занимает больше всего времени.
    
-   `rand()`  — медленная функция. Большое количество вызовов занимает много времени, и в этом основная проблема.
    
-   Эта реализация реверсирования  `vector`  неэффективна, она отнимает больше всего времени.
    
-   Вычисление процента единиц. Там делаются повторные вычисления, что фатально для этой программы.
    

Когда в программе всего три операции, можно действовать, как было предложно, и не профилировать. Хотя, вероятно, вы уже столкнулись с проблемами: удаление реверсирования влияет на следующий код. В реальных программах «подозреваемых» много, и наивными методами не обойтись — искать узкое место в объёмном коде трудно. Даже в нашей маленькой программе пока непонятно, какой вклад в общее время вносит каждая из операций. Об этом и о том, как программы ускорять, — в следующих уроках.

### Оптимизатор

Когда компилятор завершает работу, в дело вступает встроенный оптимизатор. Он сделает всё, чтобы ускорить программу, не испортив её. Оптимизатор может многое: удалять код, не влияющий на работу программы, подставлять тело функции в месте, где она вызывается, менять местами операции, устранять избыточные копирования. Шагая отладчиком по коду программы, вы могли заметить, что выполнение проходит не совсем так, как задумано. Это потому что поработал оптимизатор.

Вы можете влиять на оптимизатор, настраивая параметры компиляции. Основных вариантов два:

-   совсем отключить его. Так обычно делают для Debug-версий, поскольку оптимизатор может сильно усложнять отладку;
-   выбрать максимальную оптимизацию в Release-сборке.

Оптимизатор C++ — сложная вещь, и в некоторых случаях его поведение совсем не очевидно. Но даже самый изощрённый оптимизатор не сделает из плохого и медленного кода быстрый и эффективный. Возможности оптимизатора широки, но не безграничны.

Оптимизация перепутает функции вашей программы, как спагетти. Некоторые функции она и вовсе удалит, встроив их код в другие. Это в свою очередь влияет на наглядность результатов профилировщика. В вашем профилировщике не будет такого недостатка. Но чтобы создать профилировщик, нужно овладеть временем, а вернее, механизмами его измерения в C++. Их вы изучите в следующем уроке.Помимо этих этапов может выполняться оптимизация при компоновке, а после них — генерация кода. В результате генерации кода получается готовая программа.

</details>

<details>
<summary>Задание:</summary>

# Ответы на задания

Определите узкое место этой программы. В ней три операции: заполнение вектора случайными числами, реверсирование и подсчёт единиц. Можно действовать так:

-   Вставьте код из теории в свою IDE.
    
-   По очереди убирая каждую из операций и запуская программу, найдите операцию, которая занимает больше всего времени.
    
-   **(-)**  `rand()`  — медленная функция. Большое количество вызовов занимает много времени, и в этом основная проблема.
    
-   **(+)**  Эта реализация реверсирования  `vector`  неэффективна, она отнимает больше всего времени.
    
-   **(-)**  Вычисление процента единиц. Там делаются повторные вычисления, что фатально для этой программы.

</details>
