<details>
<summary>Теория + Тестирование:</summary>

# Измеряем время

Главная задача профилировщика — измерять время выполнения определённых операций. Алгоритм измерения прост:

-   запомнить начальный момент (до операции),
-   запомнить конечный момент (после операции),
-   вычесть из конечного значения времени начальное.

В итоге получится продолжительность операции.


![1.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint5/%D0%9F%D1%80%D0%BE%D1%84%D0%B8%D0%BB%D0%B8%D1%80%D1%83%D0%B5%D0%BC_%D0%B8_%D1%83%D1%81%D0%BA%D0%BE%D1%80%D1%8F%D0%B5%D0%BC/%D0%98%D0%B7%D0%BC%D0%B5%D1%80%D1%8F%D0%B5%D0%BC_%D0%B2%D1%80%D0%B5%D0%BC%D1%8F/img/1.png?raw=true)

В C++ для этого есть замечательная библиотека  `<chrono>`. Вы приме́ните эту библиотеку, создавая свой профилировщик.

Посмотрим, как работает  `<chrono>`. Измерим время пятисекундного ожидания. Чтобы заставить программу подождать, используют функцию  `this_thread::sleep_for`  из библиотеки  `<thread>`. Эту библиотеку вы изучите позже. Сейчас из неё понадобится только функция ожидания, останавливающая программу на заданное время:

```cpp
#include <chrono>
#include <iostream>
#include <thread>

using namespace std;

int main() {
    cout << "Ожидание 5s..."s << endl;
    const chrono::steady_clock::time_point start_time = chrono::steady_clock::now();

    // операция - ожидание 5 секунд
    this_thread::sleep_for(chrono::seconds(5));
    const chrono::steady_clock::time_point end_time = chrono::steady_clock::now();

    const chrono::steady_clock::duration dur = end_time - start_time;
    cout << "Ожидание завершено"s << endl;
}

```

В выводе программы пока нет ничего содержательного:

```
Ожидание 5s...
Ожидание завершено

```

Чтобы узнать время, в C++, как и в обычной жизни, нужно обратиться к часам. В  `<chrono>`  есть разные виды часов: одни показывают привычное нам время, другие — время с момента запуска компьютера. Есть даже часы, используемые системами позиционирования GPS. Для измерения временных интервалов идеально подходят  `chrono::steady_clock`. Часы отсчитывают величину, называемую моментом времени. А разность моментов времени — это продолжительность.  `time_point`  и  `duration`  — разные типы данных, поэтому вы не сможете случайно сложить два момента времени вместо того, чтобы вычесть. Вы также не можете использовать момент времени там, где нужна продолжительность, и наоборот. Здесь мы указали типы полностью, а в дальнейшем для краткости будем писать  `auto`.

Приведём продолжительность в понятный вид — например, в миллисекунды. Для этого применим функцию  `chrono::duration_cast`. Мы пишем профилировщик — служебную часть программы, напрямую не связанную с её работой, поэтому результат будем выводить не в  `cout`, а в  `cerr`. Этот поток вывода при желании можно отделить от  `cout`, перенаправив его в отдельный лог-файл с отладочной информацией:

```cpp
#include <chrono>
#include <iostream>
#include <thread>

using namespace std;
using namespace chrono;

int main() {
    cout << "Ожидание 5s..."s << endl;
    const auto start_time = steady_clock::now();

    // операция - ожидание 5 секунд
    this_thread::sleep_for(seconds(5));
    const auto end_time = steady_clock::now();

    const auto dur = end_time - start_time;
    cerr << "Продолжительность сна: "s << duration_cast<milliseconds>(dur).count() << " ms"s << endl;

    cout << "Ожидание завершено"s << endl;
}

```

Вот какой результат может получиться:

```
Ожидание 5s...
Продолжительность сна: 5002 ms
Ожидание завершено

```

Запустим программу, перенаправляя  `cerr`  в файл. Если считать, что мы назвали исполняемый файл  `measure`, то это делается такой командой:

```
measure.exe 2>err.txt

```

Или под UNIX-системами:

```
./measure 2>err.txt

```

Тогда вывод сократится:

```
Ожидание 5s...
Ожидание завершено

```

Зато появится файл  `err.txt`  с содержимым

```
Продолжительность сна: 5002 ms

```

Код можно упростить, если подключить пространство имён  `std::literals`:

```cpp
#include <chrono>
#include <iostream>
#include <thread>

using namespace std;
using namespace chrono;
// хотите немного магии? тогда используйте namespace literals
using namespace literals;

int main() {
    cout << "Ожидание 5s..."s << endl;
    const auto start_time = steady_clock::now();

    // операция - ожидание 5 секунд
    this_thread::sleep_for(5s);
    const auto end_time = steady_clock::now();

    const auto dur = end_time - start_time;
    cerr << "Продолжительность сна: "s << chrono::duration_cast<chrono::milliseconds>(dur).count() << " ms"s << endl;

    cout << "Ожидание завершено"s << endl;
}

```

Мы написали просто  `5s`, и компилятор понял, что мы имели в виду пять секунд!  `std::literals`  позволяет использовать различные единицы измерения времени от наносекунд (ns) до часов (h). Причём единицы необязательно должны быть целыми: иногда нужно подождать полсекунды.

----------

Используя  `chrono::duration_cast`, определите, сколько наносекунд в 10 часах.

-   1000000000
    
-   18000000000
    
-   36000000000000
    
-   1000000000000000
    

Вам могло показаться странным, что тип длины интервала  `chrono::steady_clock::duration`  зависит от типа часов.

Часы c определённой периодичностью отсчитывают тики, прошедшие с некоторого начального момента, который называется «эпоха». Эти тики происходят в некоторые моменты времени, задаваемые типом  `chrono::{тип_часов}::time_point`. Интервал между двумя любыми моментами времени на часах задаётся типом  `chrono::{тип_часов}::duration`.

![](https://raw.githubusercontent.com/AYglazk0v/practicum_Cpp_developer/372bf6d9ac2bae4cfbf6b087022a2b2838538868/sprint5/%D0%9F%D1%80%D0%BE%D1%84%D0%B8%D0%BB%D0%B8%D1%80%D1%83%D0%B5%D0%BC_%D0%B8_%D1%83%D1%81%D0%BA%D0%BE%D1%80%D1%8F%D0%B5%D0%BC/%D0%98%D0%B7%D0%BC%D0%B5%D1%80%D1%8F%D0%B5%D0%BC_%D0%B2%D1%80%D0%B5%D0%BC%D1%8F/img/2.svg)
    
Каждые часы задают свою систему отсчёта времени: эпоху и периодичность тиков. В этой системе отсчёта задаются моменты времени. Приведём аналогию с часами из реальной жизни:

-   Настенные часы показывают время 8:15:13 после полуночи. Период тиков — 1 секунда.
-   Часы на духовом шкафу показывают 20:16 с начала приготовления пирога. Период тиков — 1 секунда.
-   Секундомер показывает время 30:25,17 с начала забега. Период тиков —  1⁄100  секунды.

Библиотека  `<chrono>`  разрешает находить разницу между моментами времени, только если они получены с одних и тех же часов. Моменты времени с разных часов никак друг с другом не связаны. И действительно, вопрос «сколько времени прошло между моментом 3:15:00 на настенных часах и моментом 1:10:53 на секундомере» не имеет смысла, если не знаем время на настенных часах, когда секундомер показывал 0:00. Более того, ответ на вопрос зависит от того, переводились ли настенные часы на летнее или зимнее время в этот промежуток времени.

В  `<chrono>`  есть универсальный тип — шаблонный класс  `chrono::duration`. Его шаблонные параметры задают:

-   числовой тип, измеряющий количество тиков. Может быть целым, как  `int`  и  `int64_t`, или вещественным, как  `float`  или  `double`.
-   продолжительность одного тика, задаваемого в виде дробного количества секунд. Например,  1⁄1000. Чтобы задать продолжительность, используется шаблонный класс  `[ratio](https://en.cppreference.com/w/cpp/numeric/ratio/ratio)`, позволяющий задавать рациональные числа.

Примеры:

-   `chrono::seconds`  — это часто то же самое, что и  `chrono::duration<int64_t>`,
-   `chrono::milliseconds`  аналогично  `chrono::duration<int64_t, chrono::milli>`,
-   `chrono::minutes`  аналогично  `chrono::duration<int64_t, ratio<60>>`.

Каждые часы определяют наиболее подходящие типы для хранения количества и продолжительности тиков.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Используя  `chrono::duration_cast`, определите, сколько наносекунд в 10 часах.

-   **(-)**  1000000000

> Маловато будет! Можно было решить так:

```cpp
#include <chrono>
#include <iostream>

using namespace std;
using namespace literals;

int main() {
    cout << chrono::duration_cast<chrono::nanoseconds>(10h).count() << endl;
}

```

-   **(-)**  18000000000

> Маловато будет! Можно было решить так:

```cpp
#include <chrono>
#include <iostream>

using namespace std;
using namespace literals;

int main() {
    cout << chrono::duration_cast<chrono::nanoseconds>(10h).count() << endl;
}

```

-   **(+)**  36000000000000

> Верно! Решить задачу можно было так:

```cpp
#include <chrono>
#include <iostream>

using namespace std;
using namespace literals;

int main() {
    cout << chrono::duration_cast<chrono::nanoseconds>(10h).count() << endl;
}

```

-   **(-)**  1000000000000000

> Перебор! Можно было решить так:

```cpp
#include <chrono>
#include <iostream>

using namespace std;
using namespace literals;

int main() {
    cout << chrono::duration_cast<chrono::nanoseconds>(10h).count() << endl;
}
```

</details>

<details>
<summary>Задание:</summary>

### Задание

В прошлом уроке вы работали с программой, в которой три операции. Измерьте время каждой из них. Вывод в  `cerr`  должен выглядеть так:

```
Append random: ??? ms
Reverse: ??? ms
Counting: ??? ms

```

Если всё сделаете правильно, время самой долгой операции будет существенно больше двух других. Попробуйте угадать заранее, во сколько раз.

Эту, как и все другие задачи на производительность, имеет смысл тестировать только с оптимизацией в конфигурации Release. Она настраивается в среде разработки. Отсутствие оптимизации и отладочные проверки могут серьёзно исказить реальную картину быстродействия.

### Формат выходных данных

-   Вывод в  `cout`  должен совпадать с выводом программы из заготовки кода.
    
-   В  `cerr`  нужно вывести три строки, содержащие изменение времени:
    
    ```
    Append random: ??? ms
    Reverse: ??? ms
    Counting: ??? ms
    
    ```
    
    Вопросы нужно заменить на целые числа — количество миллисекунд в каждом измерении.
    

### Ограничения

Не меняйте логику программы. Разрешается только добавлять в неё код.

### Пример

Пример вывода.

```
Append random: 100 ms
Reverse: 200 ms
Counting: 300 ms

```

### Что отправлять на проверку

Заготовку кода с добавленным кодом измерения времени.

### Как будет тестироваться ваш код

Будет проверено, что вы выводите в  `cerr`  текст в нужном формате и что он соответствует продолжительности работы указанных процедур.

### Подсказка

Добавьте в  `Operate`  переменные, чтобы измерять продолжительность каждого действия: начального момента, конечного момента и продолжительности. Не забудьте включить  `<chrono>`.

</details>
