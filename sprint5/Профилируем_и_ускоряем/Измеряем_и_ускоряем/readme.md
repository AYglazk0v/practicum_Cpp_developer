<details>
<summary>Теория:</summary>

# Измеряем и ускоряем

Вы потратили много усилий на макросы и теперь ваш профилировщик готов. Посмотрим, на что он способен.

Возможно, вы догадались, почему в примере из прошлого урока так много времени занимает реверсирование вектора. А если не догадались — нестрашно, сейчас разберёмся.

Дело в том, что когда вектор достаточно велик, вставка элементов в начало и середину — долгая операция: нужно подвинуть много элементов вправо, чтобы освободить ячейку. А мы делаем эту операцию много раз. Куда быстрее вставлять в конец — вспомните пример с чемоданом из начала курса:


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_Чтобы положить что-то вниз чемодана, как и в начало вектора, нужно переместить всё содержимое_

Возьмём код из предыдущего урока. Изменим программу так, чтобы вставка производилась в конец. Раньше мы читали с начала и вставляли в начало. А теперь будем читать с конца и вставлять в конец. Вроде бы ничего не изменилось, но теория подсказывает, что вставка в конец эффективнее.

Чтобы изменить направление прохода по вектору, используем обратные итераторы  `rbegin`  и  `rend`. Они работают так же, как  `begin`  и  `end`, но проходят контейнер в обратном направлении:

```cpp
vector<int> ReverseVector2(const vector<int>& source_vector) {
    vector<int> res;

    // будем проходить source_vector задом наперёд
    // с помощью обратного итератора
    for (auto iterator = source_vector.rbegin(); iterator != source_vector.rend(); ++iterator) {
        res.push_back(*iterator);
    }

    return res;
}

```

Не забываем в  `main`  поменять  `ReverseVector`  на  `ReverseVector2`  и измеряем время.

|**Было**|**Стало**|
|--|--|
|Append random: 3 ms |Append random: 6 ms|
|Reverse: 2402 ms | Reverse: 1 ms|
|Counting: 38 ms|Counting: 37 ms|
|Total: 2446 ms|Total: 46 ms|

Круто, производительность всей программы возросла более чем в 50 раз! Попробуем ускорить ещё. Но чтобы разница была заметной, увеличим размер вектора в 256 раз: с 2^{17} до 2^{25} или 33 554 432:

```cpp
static const int N = 1 << 25;

```

Теперь измерения выглядят так:

|**Стало**|
|--|
|Append random: 1366 ms|
|Reverse: 549 ms|
|Counting: 80 ms|
|Total: 2019 ms|

Начинаем ускорять с “Append random” — самой медленной части, потому что она вносит основной вклад в скорость программы. Ведь даже если мы очень постараемся и ускорим Counting в 100 раз, производительность всей программы улучшится только на 4%, а если в 100 раз ускорить Append random, то на 67%. Разница очевидна.

При случайном заполнении вектора требуется только один бит информации, а  `rand()`  выдаёт как минимум 15 случайных бит. Сколько точно — зависит от операционной системы и компилятора. Используем все 15, которые нам гарантированы:

```cpp
// <algorithm> нужен для функции min
#include <algorithm>
... 
void AppendRandom2(vector<int>& v, int n) {
    for (int i = 0; i < n; i += 15) {
        int number = rand();

        // мы можем заполнить 15 элементов вектора,
        // но не более, чем нам осталось до конца:
        int count = min(15, n - i);

        for (int j = 0; j < count; ++j)
            // таким образом, получим j-й бит числа.
            // операцию побитового сдвига вы уже видели в этой программе
            // на этот раз двигаем вправо, чтобы нужный бит оказался самым последним
            v.push_back((number >> j) % 2);
    }
}
...

```

|**Было**|**Стало**|
|--|--|
|Append random: 1366 ms|Append random: 620 ms|
|Reverse: 549 ms | Reverse: 579 ms|
|Counting: 80 ms | Counting: 81 ms|
|Total: 2019 ms|Total: 1312 ms|

Ускорение уже скромнее. Однако это лучше, чем ничего. Мы договорились ускорять самую медленную часть программы, но идей, как оптимизировать “Append random” пока нет. Поэтому улучшим функцию  `Reverse`, вторую по скорости. Вставлять элемент в конец вектора эффективнее, чем в начало, но можно ещё ускорить процесс. Для этого зарезервируем место — применим метод  `reserve`, указав количество элементов, которые будут в векторе в итоге:

```cpp
vector<int> ReverseVector3(const vector<int>& source_vector) {
    vector<int> res;
    res.reserve(source_vector.size());

    // будем проходить sourceVector задом наперёд
    // с помощью обратного итератора
    for (auto iterator = source_vector.rbegin(); iterator != source_vector.rend(); ++iterator) {
        res.push_back(*iterator);
    }

    return res;
}

```

|**Было**|**Стало**|
|--|--|
|Append random: 620 ms|Append random: 624 ms|
|Reverse: 579 ms|Reverse: 194 ms|
|Counting: 81 ms|Counting: 80 ms|
|Total: 1312 ms|Total: 926 ms|

Отлично! Не так хорошо, как при первой оптимизации, но всё-таки ускорение почти в три раза — это очень неплохо.

----------

Как упростить тело этой функции буквально до одной строчки?

-   Можно просто скопировать исходный вектор.
    
-   Поможет конструктор вектора, принимающий два итератора.
    
-   Тут поможет алгоритм  `std::copy`.

<details>
<summary>Ответы:</summary>

# Ответы на задания

Как упростить тело этой функции буквально до одной строчки?

-   **(-)**  Можно просто скопировать исходный вектор.

> Идея хорошая, но в исходном векторе другой порядок элементов.

Вот правильная реализация с применением конструктора и инициализацией фигурными скобками:

```cpp
vector<int> ReverseVector2(const vector<int>& source_vector) {
    return {source_vector.rbegin(), source_vector.rend()};
}

```

-   **(+)**  Поможет конструктор вектора, принимающий два итератора.

> Точно! Можно вот так:

```cpp
vector<int> ReverseVector2(const vector<int>& source_vector) {
    return {source_vector.rbegin(), source_vector.rend()};
}

```

-   **(-)**  Тут поможет алгоритм  `std::copy`.

> Можно решить комбинацией  `copy`  и  `back_inserter`, но с  `return`  и объявлением вектора получится уже три строки. А в одну вот так:

```cpp
vector<int> ReverseVector2(const vector<int>& source_vector) {
    return {source_vector.rbegin(), source_vector.rend()};
}
```

</details>

<details>
<summary>Задание:</summary>

### Задание

Напишите программу, которая будет сравнивать четыре реализации реверсирования вектора:

1.  наивную (`Naive`), со вставками в начало;
2.  хорошую (`Good`), со вставками в конец;
3.  отличную (`Best`), с инициализацией двумя итераторами;
4.  вашу (`Your`): она изначально создаёт вектор из нужного числа элементов и заполняет его с последнего элемента.

Прочитайте из  `cin`  одно число — размер вектора. Создайте вектор такого размера, заполните его случайными числами и произведите сравнение нескольких версий реверсирования:

-   Если размер вектора меньше либо равен 100’000, сравните наивную и хорошую реализацию.
-   Если размер вектора больше 100’000, сравните хорошую с отличной и вашей.

Сравнение заключается в измерении и выводе времени работы операций.

### Формат входных данных

Считайте одно целое неотрицательное число — размер входных данных.

### Формат выходных данных

Выведите в  `cerr`  несколько строк в формате  `<название версии>: <время работы> ms`.

Если введённое число меньше или равно 100’000, то должны быть выведены результаты для  `Naive`  и  `Good`.

Если введённое число от 100’001, то должны быть выведены результаты для  `Good`,  `Best`,  `Your`.

### Ограничения

Порядок вывода должен быть таким как указан в условии.

Называйте функции реверсирования так:

-   наивную —  `ReverseVector`,
-   хорошую —  `ReverseVector2`,
-   отличную —  `ReverseVector3`,
-   вашу —  `ReverseVector4`.

Используйте файл log_duration.h, как и в предыдущем задании.

Для тестирования компилируйте с оптимизацией (конфигурация Release), иначе результаты могут быть не такими, как вы ожидаете.

### Пример

Пример вывода для числа до 100’000:

```
Naive: 1000 ms
Good: 10 ms

```

Пример вывода для числа от 100’001:

```
Good: 100 ms
Best: 50 ms
Your: 40 ms

```

### Что отправлять на проверку

Загрузите в тренажёр код с реализацией четырёх функций реверсирования, названных как сказано в секции «Ограничения». Также в решении должна быть функция  `main`, которая измеряет время нескольких версий реверсирования и выводит результат в миллисекундах.

### Как будет тестироваться ваш код

Будет проверено, что:

-   сравниваются правильные версии реверсирования,
-   ваша версия реверсирования реализована правильно,
-   не изменены другие версии реверсирования

### Подсказка

Три реализации реверсирования у вас уже есть, осталось разработать четвёртую и применить их все. Не измеряйте заполнение вектора случайными числами.

Не выводите в  `cerr`  напрямую: для вывода используйте макрос  `LOG_DURATION`.

</details>
