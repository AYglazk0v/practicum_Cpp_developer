<details>
<summary>Теория + тестирование:</summary>

# Улучшаем сложность

В предыдущих уроках было много слов, но мало дела. Исправим это скорее. Начнём с примера. В конце урока вы ускорите его в десятки раз.

Даны два вектора чисел. Нужно определить, содержат ли они в точности одинаковые элементы. Элементы в векторах могут быть в разном порядке.

Решение:

```cpp
#include <algorithm>
#include <vector>

using namespace std;

// функция возвращает true, если векторы из одинаковых элементов
bool TestPermut(const vector<int>& v1, const vector<int>& v2) {
    // если они разной длины, элементы заведомо разные
    if (v1.size() != v2.size()) {
        return false;
    }

    for (int i : v1) {
        // проверяем, что каждый элемент первого вектора
        // содержится одинаковое количество раз в обоих векторах
        if (count(v1.begin(), v1.end(), i) != count(v2.begin(), v2.end(), i)) {
            return false;
        }
    }

    return true;
}

```

----------

Пусть N— размер векторов. Оцените сложность этого решения:

-   O(1)
    
-   O(N)
    
-   O(N \log N)
    
-   O(N^2)
    
-   O(N^3)
    

Измерим время работы цикла. Он совершает N итераций. Каждая итерация два раза вызывает алгоритм  `count`. На его  [странице](https://en.cppreference.com/w/cpp/algorithm/count)  на сайте cppreference.com сказано, что его сложность в худшем случае — это линейное количество константных сравнений относительно расстояния между итераторами, то есть O(N). Сделать N раз O(N) — это O(N^2).

----------

Такие сложности есть у массы методов и алгоритмов в стандартной библиотеке. Вы можете самостоятельно убедиться в этом, изучая их страницы на cppreference.com.

Часто сложность можно определить интуитивно, представив, как именно работает функция. Приведём несколько примеров. Постарайтесь в каждом из них понять, почему сложность именно такая.

В частности, O(1) — это сложность:

-   получения или изменения элемента  `vector`,  `deque`,  `string`,  `list`  по итератору;
-   получения или изменения элемента  `vector`  и  `string`  по индексу;
-   перемещения итератора  `vector`  или  `deque`  на произвольное число в любую сторону;
-   перемещение итератора  `map`  или  `set`  на один элемент;
-   вставки в  `stack`, в конец  `vector`, в начало или конец  `deque`, в любое место  `list`  по итератору. Для вектора эта сложность амортизированная. Что это значит, вы узнаете в одном из следующих уроков;
-   удаления в аналогичных случаях.

В одной из прошлых тем вы реализовали стек, который выдаёт наименьший элемент. Сложность получения элемента из такого стека константная — O(1).

O(N) — это сложность:

-   любых алгоритмов, которые один раз проходят от одного итератора до другого:  `find`,  `find_if`,  `iota`,  `count`,  `count_if`,  `transform`;
-   копирования любого контейнера или строки:  `vector`,  `set`,  `map`,  `deque`,  `stack`;
-   деструктора любого контейнера;
-   сравнение контейнеров, строк;
-   вставки в начало или середину  `vector`, середину  `deque`;
-   удаления в аналогичных случаях.

Для методов контейнера параметр N — это количество элементов контейнера, для алгоритмов — расстояние между итераторами.

Все указанные сложности верны, если такие операции с элементами контейнера как удаление, копирование и сравнение константны, то есть имеют сложность O(1). Иначе нужна другая оценка. Например, если есть вектор строк длины не более L, сравнение таких строк требует в худшем случае O(L) операций. Сравнение векторов размера N из таких строк будет иметь сложность O(NL).

----------

Пусть вектор чисел  `v`  имеет размер  `N`. Также переменная  `s`  типа  `string`  содержит  `N`  символов. Укажите сложность следующих операций:

-   `vector<int> u = v`
    
-   `v.insert(v.begin() + N/2, 15);`
    
-   `v[N/2]=100`
    
-   `v.push_back(s[N/2])`
    
-   `std::vector<string> sv(N, s)`
    

Итак, вы увидели три сложности: O(1), O(N), O(N^2). Далее в уроках вы познакомитесь с очень большой (экспоненциальной) и очень маленькой (логарифмической) сложностями.

Если не помните логарифмы — не пугайтесь. Уроки будут понятными для тех, кто забыл логарифмы, и интересными для тех, кто не забыл. В рамках курса будем считать, что логарифм — это просто количество цифр числа. Например, \log 99999\approx5. Такое внимание к логарифмам неслучайно. Они фигурируют в важном классе сложности — O(N\log N). Эта сложность занимает промежуточное положение между линейной и квадратичной сложностью: хуже, чем O(N), и намного лучше, чем O(N^2):

__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

_Сравнение трёх асимптотик при N до 10_

__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

_Сравнение трёх асимптотик при N до 100_

__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

_Сравнение трёх асимптотик при N до 1000_

Такую сложность имеет эффективная сортировка контейнера из N элементов. Убедиться в этом можно на  [странице алгоритма sort](https://en.cppreference.com/w/cpp/algorithm/sort)  в документации.O(N\log N) — теоретический минимум сложности для сортировки. В общем случае невозможно разработать алгоритм сортировки, который бы делал меньше, чем O(N\log N) операций. Вернее, меньше, чем O(N\log N) сравнений.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Пусть N— размер векторов. Оцените сложность этого решения:

-   **(-)**  O(1)
    
-   **(-)**  O(N)
    
-   **(-)**  O(N \log N)
    
-   **(+)**  O(N^2)
    
-   **(-)**  O(N^3)
    

----------

Пусть вектор чисел  `v`  имеет размер  `N`. Также переменная  `s`  типа  `string`  содержит  `N`  символов. Укажите сложность следующих операций:

-   `vector<int> u = v`

> Правильный ответ: O(N)

-   `v.insert(v.begin() + N/2, 15);`

> Правильный ответ: O(N)

-   `v[N/2]=100`

> Правильный ответ: O(1)

-   `v.push_back(s[N/2])`

> Правильный ответ: O(1)

-   `std::vector<string> sv(N, s)`

> Правильный ответ: O(N²)

</details>

<details>
<summary>Задание:</summary>

### Задание

Оптимизируйте пример из теории: улучшите его сложность, не изменяя при этом работу. Идея быстрого алгоритма есть в подсказке, но постарайтесь додуматься сами.

Самостоятельно сравните время работы квадратичного алгоритма и того, который у вас получился, на большом векторе — например 100 000 элементов.

### Ограничения

Поменяйте только функцию  `TestPermut`. Её поведение не должно измениться.

### Пример

Пример вы можете получить самостоятельно на основе функции  `TestPermut`  заготовки.

### Что отправлять на проверку

Включите в решение оптимизированную функцию  `TestPermut`  из заготовки. Функция  `main`  при проверке учитываться не будет.

### Как будет тестироваться ваш код

Будет проверено, что  `TestPermut`  продолжает работать правильно, а также, что она стала быстрее.

### Подсказка

-   Векторы  `v1 = {1, 15, 10}`  и  `v2 = {10, 1, 15}`  не равны, хотя содержат одинаковые элементы. Если отсортировать векторы, то они они станут равными:  `{1, 10, 15} == {1, 10, 15}`. Используйте это для решения задачи — отсортируйте оба вектора, а затем сравните их.
-   Поскольку векторы переданы через  `const &`, придётся сортировать копии.
-   Сложность сортировки — это O(N\log N), а сложность сравнения двух векторов — O(N), обе намного лучше N^2.

</details>
