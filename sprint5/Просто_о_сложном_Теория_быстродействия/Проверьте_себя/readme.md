<details>
<summary>Теория + тестирование:</summary>

# Проверьте себя

Мы приближаемся к концу темы. Впереди только финальное задание. Проверьте, как вы усвоили понятие сложности.

----------

Почему обычно оценивают худший случай? Отметьте несколько вариантов.

-   Так проще.
    
-   Чтобы сделать программу устойчивой к атакам.
    
-   Между худшим и лучшим обычно нет никакой разницы.
    
-   Худший часто совпадает со средним.
    
-   Худший случай оценивают пессимисты, лучший — оптимисты. Этот курс составляли пессимисты, поэтому в нём рассматриваются худшие случаи.
    

----------

О каком алгоритме говорят, что он работает за амортизированное O(1)?

-   Алгоритм, который работает ограниченное время, вне зависимости от входных данных.
    
-   Алгоритм, который иногда работает быстро, редко медленно, и при усреднении большого количества запусков получается константа.
    
-   Алгоритм, разработанный достаточно давно и приобретший специфический аромат.
    

----------

Ядро процессора выполняет миллиард операций в секунду. Какой размер вектора сможет обработать такой алгоритм за секунду или меньше?

```cpp
void FindDuplicates(const vector<int>& v) {
    for (size_t i = 0; i < v.size(); ++i) {
        for (size_t j = 0; j < v.size(); ++j) {
            if (v[i] == v[j] && i < j) {
                cout << "Найден дубликат "s << v[i] << endl;
            }
        }
    }
}

```

Известно, что в векторе не более десяти дубликатов. Отметьте несколько вариантов:

-   100
    
-   1 000
    
-   10 000
    
-   100 000
    
-   1 000 000
    

----------

Отметьте верные утверждения.

-   Алгоритм с меньшей сложностью всегда работает быстрее алгоритма с большей сложностью. По крайней мере в худшем случае.
    
-   Алгоритм, решающий задачу с наилучшей сложностью, будет быстрым.
    
-   Алгоритм с худшей сложностью бывает быстрее алгоритма с лучшей сложностью даже при больших входных данных.
    
-   Гарантировано, что в худшем случае и при достаточно больших данных алгоритм, имеющий меньшую сложность, будет работать быстрее алгоритма, имеющего большую сложность.
    

----------

Установите соответствие между алгоритмом и сложностью.

-   O(A^N)
    
-   O(1)
    
-   O(N)
    
-   амортизированная O(1)
    
-   O(\log N)
    
-   O(N\log N)
    

----------

Последний вопрос.

Это будет непросто, но попробуйте оценить сложность функции  `F`:

```cpp
#include <algorithm>
#include <random>
#include <string>
#include <vector>

using namespace std;

string RandString(int len) {
    static mt19937 engine;

    // строка длины len из символов 'A'
    string s(len, 'A');
    for (int i = 0; i < len / 2; ++i) {
        uniform_int_distribution<int> dist(0, i - 1);
        s[dist(engine)] = 'B';
    }

    return s;
}

void F(int n, int m) {
    vector<int> v1;
    vector<string> v2;

    for (int i = 0; i < m; ++i) {
        v1.push_back(rand() % 100);
    }

    for (int i = 0; i < n; ++i) {
        v2.push_back(RandString(i));
    }

    sort(v2.begin(), v2.end());

    for (int r : v1) {
        for (int j = 0; j < r * 2; ++j) {
            string s = RandString(n);
            upper_bound(v2.begin(), v2.end(), s);
        }
    }
}

```

-   O(m+n)
    
-   O(mn)
    
-   O(mn\log n)
    
-   O(mn\log n + n^2\log n)
    
-   O(m+n^2\log n)
    
-   O(mn + n^2)
    

Решить можно так.

Первый цикл имеет сложность O(m), второй — O(n^2), так как он делает n итераций, а худшая сложность итерации сама равна n. Сортировка делает O(n\log n) сравнений, каждое из которых имеет худшую сложность O(n). По правилу умножения вся сортировка потребует O(n^2\log n) операций в худшем случае.

Цикл, вложенный в третий, делает не более C итераций, а именно не более 200, поэтому его можно не учитывать вовсе. По документации  `upper_bound`  делает O(\log n) сравнений, но каждое сравнение строк само занимает время O(n). Таким образом, по правилу умножения тело третьего цикла имеет сложность O(n\log n). Умножаем на количество итераций, получаем сложность третьего цикла O(mn\log n).

Теперь суммируем три цикла: O(m) будет поглощено третьим циклом, но сравнить O(n^2\log n) и O(mn\log n) нельзя, так что ответом будет их сумма.

</details>

<details>
<summary>Задание:</summary>

# Ответы на задания

Почему обычно оценивают худший случай? Отметьте несколько вариантов.

-   **(+)**  Так проще.
    
-   **(+)**  Чтобы сделать программу устойчивой к атакам.
    
-   **(-)**  Между худшим и лучшим обычно нет никакой разницы.
    
-   **(+)**  Худший часто совпадает со средним.
    
-   **(-)**  Худший случай оценивают пессимисты, лучший — оптимисты. Этот курс составляли пессимисты, поэтому в нём рассматриваются худшие случаи.
    

----------

О каком алгоритме говорят, что он работает за амортизированное O(1)?

-   **(-)**  Алгоритм, который работает ограниченное время, вне зависимости от входных данных.
    
-   **(+)**  Алгоритм, который иногда работает быстро, редко медленно, и при усреднении большого количества запусков получается константа.
    
-   **(-)**  Алгоритм, разработанный достаточно давно и приобретший специфический аромат.
    

----------

Ядро процессора выполняет миллиард операций в секунду. Какой размер вектора сможет обработать такой алгоритм за секунду или меньше?

```cpp
void FindDuplicates(const vector<int>& v) {
    for (size_t i = 0; i < v.size(); ++i) {
        for (size_t j = 0; j < v.size(); ++j) {
            if (v[i] == v[j] && i < j) {
                cout << "Найден дубликат "s << v[i] << endl;
            }
        }
    }
}

```

Известно, что в векторе не более десяти дубликатов. Отметьте несколько вариантов:

-   **(+)**  100
    
-   **(+)**  1 000
    
-   **(+)**  10 000
    
-   **(-)**  100 000
    
-   **(-)**  1 000 000
    

----------

Отметьте верные утверждения.

-   **(-)**  Алгоритм с меньшей сложностью всегда работает быстрее алгоритма с большей сложностью. По крайней мере в худшем случае.

> Это верно только при достаточно большом объёме данных. Если параметры задачи недостаточно большие, линейный алгоритм может оказаться хуже, чем O(N\log N).

-   **(-)**  Алгоритм, решающий задачу с наилучшей сложностью, будет быстрым.

> Это не совсем верно. Ведь если какой-нибудь алгоритм работает быстро, то алгоритм, работающий в 100 раз медленнее, будет медленным, но иметь такую же хорошую сложность.

-   **(+)**  Алгоритм с худшей сложностью бывает быстрее алгоритма с лучшей сложностью даже при больших входных данных.

> Такой пример с  `upper_bound`  был в одном из уроков. Это случается при определённым образом подобранных входных данных.

-   **(+)**  Гарантировано, что в худшем случае и при достаточно больших данных алгоритм, имеющий меньшую сложность, будет работать быстрее алгоритма, имеющего большую сложность.

> Единственное, что гарантирует теория. Но часто этого достаточно.

----------

Установите соответствие между алгоритмом и сложностью.

-   O(A^N)

-   O(1)

-   O(N)

-   амортизированная O(1)

-   O(\log N)

-   O(N\log N)

----------

Последний вопрос.

Это будет непросто, но попробуйте оценить сложность функции  `F`:

```cpp
#include <algorithm>
#include <random>
#include <string>
#include <vector>

using namespace std;

string RandString(int len) {
    static mt19937 engine;

    // строка длины len из символов 'A'
    string s(len, 'A');
    for (int i = 0; i < len / 2; ++i) {
        uniform_int_distribution<int> dist(0, i - 1);
        s[dist(engine)] = 'B';
    }

    return s;
}

void F(int n, int m) {
    vector<int> v1;
    vector<string> v2;

    for (int i = 0; i < m; ++i) {
        v1.push_back(rand() % 100);
    }

    for (int i = 0; i < n; ++i) {
        v2.push_back(RandString(i));
    }

    sort(v2.begin(), v2.end());

    for (int r : v1) {
        for (int j = 0; j < r * 2; ++j) {
            string s = RandString(n);
            upper_bound(v2.begin(), v2.end(), s);
        }
    }
}

```

-   **(-)**  O(m+n)
    
-   **(-)**  O(mn)
    
-   **(-)**  O(mn\log n)
    
-   **(+)**  O(mn\log n + n^2\log n)
    
-   **(-)**  O(m+n^2\log n)
    
-   **(-)**  O(mn + n^2)

</details>
