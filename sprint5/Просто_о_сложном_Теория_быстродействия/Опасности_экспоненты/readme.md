<details>
<summary>Теория + тестирование:</summary>

# Опасности экспоненты

Логарифм — отличная вещь. Число может быть большим, например сто миллионов, а цифр в нём будет всего девять. Девять операций лучше, чем сто миллионов. Но бывает логарифм «наоборот»‎, который называется «**экспонента**». Он далеко не столь приятен.

В прошлом спринте вы решали задачу о числах Фибоначчи. Эти числа F_n задаются так: F_0 = 0, F_1 = 1, а остальные получаются по формуле F_n = F_{n-1} + F_{n-2}.

Ваше решение могло выглядеть так:

```cpp
#include <cstdint>
#include <iostream>
#include <string>

using namespace std;

// числа Фибоначчи довольно быстро растут, используем int64_t
int64_t F(int i) {
    // тут обработаем i == 0 и i == 1
    if (i <= 0) {
        return 0;
    }

    if (i == 1) {
        return 1;
    }

    // рекурсивно вызовем саму функцию F
    return F(i - 1) + F(i - 2);
}

int main() {
    int i;

    while (true) {
        cout << "Введите индекс: "s;
        if (!(cin >> i)) {
            break;
        }

        cout << "Fi = "s << F(i) << endl;
    }
}

```

Сомнения может вызвать рекурсия. Ей вычисляется  `F`. Но глубина рекурсии не превышает  `i`. В наших примерах  `i`  будет в пределах 100, что вполне допустимо. На первый взгляд программа работает неплохо:

```cpp
Введите индекс: 0
Fi = 0
Введите индекс: 1
Fi = 1
Введите индекс: 2
Fi = 1
Введите индекс: 3
Fi = 2
Введите индекс: 4
Fi = 3
Введите индекс: 5
Fi = 5
Введите индекс: 6
Fi = 8
Введите индекс: 10
Fi = 55
Введите индекс: 20
Fi = 6765
Введите индекс: 30
Fi = 832040
Введите индекс: 40
Fi = 102334155

```

Но перед вычислением 40-го числа была подозрительная пауза. Введём 45. Поначалу показалось, что программа зависла. Но в конце концов она выдала результат:

```cpp
Введите индекс: 45
Fi = 1134903170

```

У программы такой простой код, но уже явные проблемы с производительностью! Чтобы оценить их, измерим время, внеся изменения в  `main`:

```cpp
...

int main() {
    for (int i = 0; i < 100; ++i) {
        int64_t fi;
        {
            LOG_DURATION("Number "s + std::to_string(i));
            fi = F(i);
        }
        cout << fi << endl;
    }
}

```

Посмотрим, что выдаст программа:

```cpp
Number 0: 0 ms
0
Number 1: 0 ms
1
Number 2: 0 ms
1
...
Number 27: 3 ms
196418
Number 28: 3 ms
317811
Number 29: 7 ms
514229
Number 30: 12 ms
832040
Number 31: 15 ms
1346269
Number 32: 36 ms
2178309
Number 33: 96 ms
3524578
...
Number 43: 4004 ms
433494437
Number 44: 6674 ms
701408733
Number 45: 10793 ms
1134903170
Number 46: 17412 ms
1836311903

```

Проблемы начались примерно с 27-го числа и начали увеличиваться лавинообразно, когда количество миллисекунд само стало напоминать числа Фибоначчи. Если подумать, сколько операций совершит вызов  `F`, можно понять: это вовсе не случайность.  `F`  вызывает две такие же функции и будет работать примерно столько, сколько обе они вместе взятые — точь-в-точь как в формуле самих чисел. Если так пойдёт дальше, для вычисления 80-го числа понадобится примерно восемь лет.

Количество операций возрастает минимум в два раза каждые два числа. Такая сложность называется экспоненциальной и обозначается O(a^N). Как правило, программы, имеющие такую сложность, непригодны для использования, потому что требуют колоссального времени даже при маленьких входных данных.

----------

Известно, что некоторый алгоритм, принимающий на вход N чисел, совершает количество операций примерно 2^N. Также известно, что при вводе десяти чисел время его работы составило одну миллисекунду. Каким примерно будет время работы алгоритма при вводе 100 чисел?

-   Десять миллисекунд
    
-   100 миллисекунд
    
-   Одну минуту
    
-   Несколько часов
    
-   Около суток
    
-   От нескольких месяцев до года
    
-   В районе десяти лет
    
-   Вы шутите? Он будет работать в несколько миллионов раз дольше, чем существует Вселенная!
    

Результат для 100 чисел будет в 2^{90} раз медленнее, чем для десяти. Трудно поверить, но такой алгоритм действительно потребовал бы миллионы миллиардов лет для работы.

----------

Это абсолютно неприемлемая сложность, ведь числа Фибоначчи можно вычислить даже без компьютера, простым сложением в столбик. Числа длинные, работа будет трудоёмкой, но времени понадобится явно меньше. Минус нашего алгоритма в том, что он многократно вычисляет одни и те же числа Фибоначчи, вместо того чтобы сделать это один раз. Чтобы такого не случалось, достаточно постоянно помнить два предыдущих числа:

```cpp
int64_t F2(int i) {
    if (i == 0) {
        return 0;
    }

    int64_t prev0 = 0, prev1 = 1;

    for (int t = 1; t < i; ++t) {
        int64_t next = prev0 + prev1;
        prev0 = prev1;
        prev1 = next;
    }

    return prev1;
}

```

Решение настолько быстрое, что профилировщик даже не может заметить разницы между вычислениями, выдавая каждый раз ноль миллисекунд:

```cpp
Number 0: 0 ms
0
Number 1: 0 ms
1
...
Number 90: 0 ms
2880067194370816120
Number 91: 0 ms
4660046610375530309
Number 92: 0 ms
7540113804746346429
Number 93: 0 ms
-6246583658587674878
Number 94: 0 ms
1293530146158671551
Number 95: 0 ms
-4953053512429003327
Number 96: 0 ms
-3659523366270331776
Number 97: 0 ms
-8612576878699335103
Number 98: 0 ms
6174643828739884737
Number 99: 0 ms
-2437933049959450366

```

На 93-м месте вдруг появилось отрицательное число. Это значит, что результат перестал помещаться в  `int64_t`, и дальнейшее вычисление не имеет смысла.

----------

Посчитайте количество операций сложений при вычислении  `F2(N)`. Дайте наилучшую оценку:

-   O(1)
    
-   O(N)
    
-   O(N^2)
    

Эта таблица наглядно показывает рост асимптотик на нескольких примерах. С экспонентой действительно лучше не связываться.

____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Известно, что некоторый алгоритм, принимающий на вход N чисел, совершает количество операций примерно 2^N. Также известно, что при вводе десяти чисел время его работы составило одну миллисекунду. Каким примерно будет время работы алгоритма при вводе 100 чисел?

-   **(-)**  Десять миллисекунд
    
-   **(-)**  100 миллисекунд
    
-   **(-)**  Одну минуту
    
-   **(-)**  Несколько часов
    
-   **(-)**  Около суток
    
-   **(-)**  От нескольких месяцев до года
    
-   **(-)**  В районе десяти лет
    
-   **(+)**  Вы шутите? Он будет работать в несколько миллионов раз дольше, чем существует Вселенная!
    

----------

Посчитайте количество операций сложений при вычислении  `F2(N)`. Дайте наилучшую оценку:

-   **(-)**  O(1)

> Маловато! Цикл сделает примерно N шагов, каждый шаг делает одно сложение.

-   **(+)**  O(N)

> Да, цикл делает N-1 сложение.

-   **(-)**  O(N^2)

> Перебор. Если быть точным, цикл делает N-1 сложение, что подходит под O(N).

</details>

<details>
<summary>Задание 1:</summary>

### Задание 1

Перед вами экспоненциальный алгоритм для так называемых чисел «‎трибоначчи»‎. Ускорьте его, не меняя результат работы.

### Ограничения

В заготовке кода дана функция  `T`. Она решает поставленную задачу верно, но медленно. Не меняйте поведение этой функции.

### Пример

-   `T(0) = 0`
-   `T(2) = 1`
-   `T(7) = 13`
-   `T(15) = 1705`

### Что отправлять на проверку

Включите в решение оптимизированный вариант  `T`. Функция  `main`  будет игнорироваться.

### Как будет тестироваться ваш код

Будет проверено, что  `T`  верно находит числа трибоначчи, и что её поведение не изменилось. Функция  `main`  будет игнорироваться.

### Подсказка

Избавьтесь от рекурсии. В цикле теперь нужно помнить три последних числа. Обратите внимание, что числа трибоначчи начинаются с двух нулей и единицы.

</details>

<details>
<summary>Задание 2:</summary>

### Задание 2

Иногда экспонента всё-таки необходима. Реализуйте брутфорс для подбора пароля к секретному объекту Неверляндии. К счастью, контрразведка Неверляндии не очень продвинута — Неверландский системный администратор Артур установил пароль, содержащий всего пять латинских букв верхнего регистра A-Z. Вам не составит труда подобрать его. Функция проверки пароля будет передана в качестве аргумента.

### Ограничения

Не меняйте сигнатуру функции  `BruteForce`.

### Пример

Если пароль  `ABCDE`, то  `check("ABCDE"s) == true`,  `check(str) == false`, где  `str`  — любая другая строка.

### Что отправлять на проверку

Включите в решение реализацию функции  `BruteForce`. Функция  `main`  при проверке будет игнорироваться.

### Как будет тестироваться ваш код

Функция  `BruteForce`  будет вызываться с различными предикатами  `check`. Для каждого гарантируется, что есть ровно одна строка из пяти символов A-Z, на которой он истинен.

### Подсказка

Вы можете выбрать один из двух подходов к решению.

1.  Простой. Реализуйте 5 вложенных циклов по  `char`  от  `'A'`  до  `'Z'`.
2.  Универсальный. Годится, если длина пароля заранее неизвестна. Напишите рекурсивную функцию  `string BruteForceInternal(F check, const string& begin, int n)`. При  `n == 5`  она будет вызывать  `check(begin)`  и возвращать результат вызова в случае успеха, пустую строку в случае неудачи. При  `n < 5`  она будет вызывать себя, приписывая к  `begin`  всевозможные символы и увеличивая  `n`  на 1. Если рекурсивный вызов  `BruteForceInternal`  вернул непустую строку, то это и есть правильный ответ, дальнейший перебор не нужен.

</details>
