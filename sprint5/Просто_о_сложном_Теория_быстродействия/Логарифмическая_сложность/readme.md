<details>
<summary>Теория + тестирование:</summary>

# Логарифмическая сложность

Рассмотрим такую задачу. В восьмиэтажном доме поселилась невезучая обезьяна, которая очень любит орехи. Орехи она находит неподалёку. Только вот беда — ей совершенно нечем их колоть. Обезьяна хоть и невезучая, но хитрая. Она решила сбрасывать орехи из окна и таким образом разбивать их. Обезьяна успешно расколола орех, кинув его с верхнего, восьмого этажа. Чтобы не подниматься каждый раз так высоко, обезьяна хочет найти самый низкий этаж, при броске с которого орехи разбиваются. Все орехи одинаковые и все броски одинаковые, так что любые два броска с одного этажа будут иметь одинаковый результат.

----------

Подумайте, как действовать обезьяне, чтобы при самом страшном невезении совершить как можно меньше бросков для определения нужного этажа. Сколько бросков ей нужно сделать?

-   Придётся перебирать все этажи — итого восемь бросков.
    
-   Один она уже попробовала, поэтому хватит семи попыток.
    
-   Нужно перебрать каждый второй этаж, итого четыре попытки.
    
-   Есть способ справиться за три броска.
    
-   Справится за два броска.
    
-   Один бросок, на этот раз ей точно повезёт!
    

Когда обезьяна совершает бросок, например, с пятого этажа, она делит этажи на две части. Если бросок успешный, нужный этаж — пятый или ниже. Если неуспешный, нужный этаж выше — шестой, седьмой или восьмой. Поскольку обезьяна невезучая, скорее всего, каждый раз будет выпадать большая часть: в этом конкретном примере — с первого по пятый. Лучший способ — делать части равными, бросая со среднего этажа. Тогда количество вариантов будет каждый раз сокращаться вдвое: после первого броска обезьяна будет рассматривать четыре этажа, после второго — два, после третьего найдёт нужный.

Число восемь выбрано для условия задачи отнюдь не случайно: чтобы обезьяна могла постоянно делить на два. Также подойдёт любая степень двойки: 2, 4, 8, 16, 32.

----------

Если удвоить количество этажей, обезьяне понадобится всего на один бросок больше. Предложенное решение — пример так называемого логарифмического алгоритма, то есть алгоритма сложности O(\log N). Для N-этажного здания количество бросков, которое нужно совершить обезьяне, — это двоичный логарифм числа N.

Если вы забыли что такое логарифм, не расстраивайтесь — для наших целей можно считать, что это просто количество цифр в числе. А если не забыли, возможно, задались вопросом, почему мы не написали основание. На самом деле под буквой O основание неважно: логарифмы по всем основаниям имеют одинаковую скорость роста.

У логарифмической зависимости есть особенность: если увеличить аргумент N  **в несколько раз**, количество действий увеличится  **на несколько штук**. Например, увеличили количество этажей в два раза, а количество необходимых бросков возросло на один. Или увеличили число в десять раз, а количество цифр увеличилось на одну. Можно повторить операцию увеличения числа в десять раз шестикратно, и число возрастёт в миллион раз, а количество цифр всего лишь шесть раз увеличится на единицу. Это очень маленький рост.

Важный пример логарифмического алгоритма — бинарный поиск, который использовала хитрая обезьяна. Он реализован в уже известных вам алгоритмах  `binary_search`,  `lower_bound`,  `upper_bound`.

Вы применяете похожий алгоритм, когда ищете слово в словаре. Вряд ли вы просматриваете каждую страницу, начиная с первой, — поиск был бы слишком долгим. Скорее всего, вы открываете словарь в случайном месте и проверяете, раньше или позже находится ваше слово, постепенно сужая круг поиска. Бинарный поиск в контейнере можно применять только если элементы уже упорядочены, как слова в словаре.

Проверим, действительно ли  `upper_bound`  так эффективен, как подсказывает теория. Создадим отсортированный вектор из миллиона случайных чисел от 0 до 1 000 000 000 и тысячу раз поищем первое число, превышающее 500 000 000:

```cpp
int main() {
    static const int NUMBERS = 1'000'000;
    static const int SEARCHES = 500'000;
 
    mt19937 generator;
    uniform_int_distribution<int> uniform_dist(0, 1'000'000'000);

    vector<int> nums;
    for (int i = 0; i < NUMBERS; ++i) {
        int random_number = uniform_dist(generator);
        nums.push_back(random_number);
    }
    sort(nums.begin(), nums.end());

    ...
}

```

В первом случае применим для поиска алгоритм  `upper_bound`, а во втором —  `find_if`. Алгоритм  `find_if`  просматривает контейнер, пока не найдёт нужное значение, его сложность O(N):

```cpp
...
int result_number;
{
    LOG_DURATION("std::upper_bound"s);
    for (int i = 0; i < SEARCHES; ++i) {
        auto iter = upper_bound(nums.begin(), nums.end(), 500'000'000);
        result_number = *iter;
    }
}
cout << result_number << endl;

{
    LOG_DURATION("std::find_if"s);
    for (int i = 0; i < SEARCHES; ++i) {
        auto iter = find_if(nums.begin(), nums.end(), [](int x) {
            return x > 500'000'000;
        });
        result_number = *iter;
    }
}
cout << result_number << endl;
...

```

Посмотрим на результат:

```cpp
std::upper_bound: 0 ms
500000367
std::find_if: 623 ms
500000367

```

Результат получился одинаковый, но  `upper_bound`  выдала его в сотни раз быстрее. Вот она, сила логарифма!

В стандартной библиотеке логарифмическая сложность встречается часто. Её имеют следующие методы и алгоритмы:

-   вставка одного элемента в  `set`  и  `map`  и удаление из них;
-   поиск элемента в  `set`  и  `map`;
-   методы  `lower_bound`,  `upper_bound`  для  `set`  и  `map`;
-   бинарный поиск по отсортированному  `vector`  или  `deque`:  `binary_search`,  `lower_bound`,  `upper_bound`.

Для методов контейнера параметр N — это количество элементов контейнера, а для алгоритмов — расстояние между итераторами.

Логарифмическая сложность так часто встречается в методах  `set`  и  `map`, потому что в них использованы деревья поиска, имеющие логарифмическую глубину. Подробности об этих структурах вы узнаете позже в курсе.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Подумайте, как действовать обезьяне, чтобы при самом страшном невезении совершить как можно меньше бросков для определения нужного этажа. Сколько бросков ей нужно сделать?

-   **(-)**  Придётся перебирать все этажи — итого восемь бросков.
    
-   **(-)**  Один она уже попробовала, поэтому хватит семи попыток.
    
-   **(-)**  Нужно перебрать каждый второй этаж, итого четыре попытки.
    
-   **(+)**  Есть способ справиться за три броска.
    
-   **(-)**  Справится за два броска.
    
-   **(-)**  Один бросок, на этот раз ей точно повезёт!

</details>

<details>
<summary>Задание:</summary>

## Задание

Реализуйте самый эффективный алгоритм обезьяны в  `n`-этажном здании. Гарантируется, что  `n`  — степень двойки, но нужно совершить минимальное количество бросков в худшем случае.

Бросок делайте функцией  `drop`, которая будет передана в качестве параметра. Она принимает номер этажа, с которого вы хотите бросить орех, и возвращает  `true`, если орех раскололся. Ваша функция должна выдать номер самого низкого этажа, откуда можно разбить орех. Этажи нумеруются с первого. Гарантируется, что  `drop(n) == true`.

### Ограничения

Количество вызовов функции  `drop`  должно быть минимально возможным. В заготовке кода дано верное, но медленное решение задачи. Оптимизируйте функцию  `FindFloor`  так, чтобы количество вызовов функции  `drop`  было минимально возможным.

### Пример

Если  `n == 4`, то можно делать так:

-   Вызовем  `drop(2)`.
-   Если  `drop(2) == true`, то возвратим  `drop(1) ? 1 : 2`.
-   Если  `drop(2) == false`, то возвратим  `drop(3) ? 3 : 4`.

### Что отправлять на проверку

В решение включите оптимизированную версию функции  `FindFloor`  из заготовки кода. Функция  `main`  учитываться не будет.

### Как будет тестироваться ваш код

Будет проверено, что:

-   Функция  `FindFloor`  правильно находит минимальный этаж, с которого разбиваются орехи.
-   Функция  `FindFloor`  делает минимальное возможное количество вызовов функции  `drop`  в худшем случае.

### Подсказка

-   Задачу можно решить циклом  `while`. Сохраните первый и последний рассматриваемый этаж в переменных  `int a, b`.
-   В цикле выполните бросок функцией  `drop`  c этажа  `int m = (a + b) / 2`. Бросок будет успешным, если  `drop(m) == true`.
-   В зависимости от результата обновите либо  `a`, либо  `b`: при неуспешном броске  `a`  должно стать  `m + 1`, а при успешном  `b`  становится  `m`.
-   Завершить цикл следует, когда  `a == b`, то есть количество рассматриваемых этажей сократилось до одного. Значение  `a`  будет правильным ответом.

</details>
