<details>
<summary>Теория + тестирование:</summary>

# Арифметика сложности: три правила вычисления

В предыдущих уроках этой темы вы уже оценивали сложность. Обобщим накопленный опыт и сформулируем правила, по которым можно вычислять в более сложных случаях.

## Правило поглощения

Это правило вам уже знакомо. Оно формулируется так: убираем всё ненужное, оставляя главное. Или более подробно: если программа выполняет несколько действий, сложность всей программы будет равна сложности самого медленного действия. Иными словами, при суммировании нескольких сложностей побеждает самая большая.

Более того: сложность поглощает сама себя. То есть если несколько слагаемых одинаковы, нужно оставить только одно из них.

Будьте внимательны: количество слагаемых не должно зависеть ни от каких параметров, оно должно быть известно заранее. Иначе потребуется применить правило умножения — но о нём чуть позже.

----------

Вычислите:

O(N^2) + O(N\log N) + O(N) + O(N) + O(N) + O(1) + O(N^2).

-   O(N)
    
-   O(3N)
    
-   O(N^2)
    
-   O(N\log N)
    

Нашли самую большую сложность и вспомнили, что O(N^2)+O(N^2)=O(N^2). Так мы получили ответ в этой задаче.

----------

Возьмём, например, функцию, выдающая таблицу умножения для N чисел из вектора:

```cpp
void F(vector<int> v) {
    // избавимся от отрицательных чисел, если таковые имеются
    for (int i = 0; i < v.size(); ++i) {
        if (v[i] < 0) {
            v[i] = -v[i];
        }
    }

    // отсортируем вектор
    sort(v.begin(), v.end());

    // только теперь выведем таблицу
    for (int i = 0; i < v.size(); ++i) {
        for (int j = 0; j < v.size(); ++j) {
            if (j > 0) {
                cout << "\t"s;
            }
            cout << (v[i] * v[j]);
        }
        cout << endl;
    }
}

```

Функция  `F`  выполняет три действия:

1.  избавляется от отрицательных чисел — сложность O(N);
2.  сортирует вектор — сложность O(N\log N);
3.  выдаёт саму таблицу — сложность O(N^2).

Итоговая сложность получается по правилу сложения: O(N)+O(N\log N)+O(N^2) = O(N^2).

## Правило суммирования

Бывает, что сложность программы зависит от нескольких параметров. Рассмотрим такую функцию:

```cpp
void SortPair(std::vector<int>& v1, std::vector<int>& v2) {
    sort(v1.begin(), v1.end());
    sort(v2.begin(), v2.end());
}

```

Пусть размер первого вектора равен N, а второго — M. Тогда функция выполняет две операции со сложностями O(N\log N) и O(M\log M), но применить правило поглощения тут не получится: мы не знаем, какая из этих двух сложностей окажется больше. Ничего не остаётся, как не мудрствуя лукаво, оставить сумму: O(N\log N+M\log M).

## Правило умножения

Предположим, мы знаем о функции  `F(int k)`, что её сложность равна O(k). Требуется оценить сложность такого кода:

```cpp
bool F(int k);

bool G(int n) {
    for (int i = 0; i < n; ++i) {
        if (F(i)) {
            return true;
        }
    }
    return false;
}

```

Понадобятся две вещи:

-   сложность тела цикла;
-   асимптотика количества итераций.

Сложность тела цикла оценим по худшему случаю, когда  `i == n-1`. Самое сложное — это вызов  `F(i)`, который в этом случае имеет сложность O(n-1)=O(n). Количество итераций тоже оценим по худшему случаю: когда все итерации функция  `F`  возвращала  `false`. Тогда будет O(n) итераций.

Правило умножения в данном случае говорит, что нужно перемножить оба результата: сложность тела и количество итераций. В рассмотренном примере они оба равны O(n), так что получится O(n\cdot n)=O(n^2).

В примере мы видели реализацию тела цикла, но о функции  `F`  знали только сложность. При использовании алгоритмов бывает наоборот — сам алгоритм скрыт, но известна функция, которую он будет вызывать.

Рассмотрим знакомый  `find_if`. На  [его странице](https://en.cppreference.com/w/cpp/algorithm/find)  сказано, что если N — расстояние между итераторами, переданными этому алгоритму, он совершает не более N проверок. Казалось бы, можно сразу написать сложность — O(N), но это будет корректно только если сложность одной проверки O(1). А если сама проверка сложная — например, поиск символа в строке, — применяют правило умножения:

```cpp
// получить певую строку, содержащую символ 'A', либо ""s если такой строки нет в векторе
const string& FindStringWithA(const vector<string>& v) {
    auto result = find_if(v.begin(), v.end(), [](const string& s){
        return s.find('A') != string::npos;
    });

    // создадим статическую переменную, содержащую пустую строку
    // чтобы иметь возможность возвратить ссылку на неё,
    // если мы ничего не нашли
    static const string dummy;
    return result == v.end() ? dummy : *result;
}

```

Чтобы оценить сложность этой функции, нужно знать сложность метода поиска символа в строке —  `find`. Но на  [странице документации](https://en.cppreference.com/w/cpp/string/basic_string/find)  нет раздела “Complexity”. Можно предположить, что в случае поиска символа алгоритм будет работать за линейное время относительно длины строки, так как он просматривает все символы по порядку. Если известно, что строки в векторе имеют длину не более L, а размер вектора N, ответом будет число O(NL) в соответствии с правилом умножения.

----------

Как вы думаете, какую сложность будет иметь следующая программа:

```cpp
x = y;

```

Известно, что  `x`  и  `y`  имеют тип  `vector<string>`, причём  `y`  содержит N строк длины от 1 до N, а  `x`  пуст.

-   O(1), так как присваивание — быстрая операция.
    
-   O(N), так как для копирования вектора нужно копирование N элементов.
    
-   O(N^2), так как копирование одного элемента вектора в худшем случае имеет сложность N, а всего нужно скопировать N строк.
    

Вы познакомились с основными правилами вычисления сложности и умеете оценивать скорость программ, даже не запуская их.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Вычислите:

O(N^2) + O(N\log N) + O(N) + O(N) + O(N) + O(1) + O(N^2).

-   **(-)**  O(N)

> O(N) явно не самая большая сложность.

-   **(-)**  O(3N)

> Несколько раз O(N) — всё равно O(N), но это не самая большая сложность в выражении.

-   **(+)**  O(N^2)

> Верно!

-   **(-)**  O(N\log N)

> O(N^2) намного больше.

----------

Как вы думаете, какую сложность будет иметь следующая программа:

```cpp
x = y;

```

Известно, что  `x`  и  `y`  имеют тип  `vector<string>`, причём  `y`  содержит N строк длины от 1 до N, а  `x`  пуст.

-   **(-)**  O(1), так как присваивание — быстрая операция.
    
-   **(-)**  O(N), так как для копирования вектора нужно копирование N элементов.
    
-   **(+)**  O(N^2), так как копирование одного элемента вектора в худшем случае имеет сложность N, а всего нужно скопировать N строк.

</details>
