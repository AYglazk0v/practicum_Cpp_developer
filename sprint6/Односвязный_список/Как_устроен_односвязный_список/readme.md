<details>
<summary>Введение:</summary>

# Введение

До сих пор вы создавали одиночные объекты в динамической памяти, а в этой теме научитесь работать с массивами и сделаете собственный контейнер — односвязный список. Это позволит лучше разобраться в устройстве контейнеров C++ и эффективно их использовать.

</details>

<details>
<summary>Теория + тестирование:</summary>

# Как устроен односвязный список

В предыдущих уроках вы использовали контейнеры стандартной библиотеки. Даже в основе вспомогательного класса  `PtrVector`  лежал контейнер  `vector`. Теперь у вас достаточно знаний, чтобы с нуля создать первый собственный контейнер — односвязный список. Это позволит разобраться в том, как устроены связные структуры данных.

Односвязный список ещё называют линейным однонаправленным списком. Эта структура данных состоит из элементов одного типа. Их логически связывают между собой указатели. Каждый элемент списка указывает на следующий, а последний — на  `nullptr`. Хранятся элементы списка, как правило, в динамической памяти.

_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

_Каждый элемент односвязного списка ссылается на следующий элемент_

Структура односвязного списка такова, что передвигаться по его элементам можно только в прямом направлении. Узнать адрес предыдущего элемента, опираясь лишь на содержимое текущего элемента, невозможно.

Односвязный список допускает следующие операции:

-   вставка элемента в начало или конец списка,
-   вставка элемента после некоторого элемента списка,
-   удаление элемента, следующего за данным элементом списка,
-   проверка списка на пустоту,
-   определение количества элементов в списке.

Достоинства односвязного списка:

-   вставка и удаление элемента выполняются за константное время, то есть не зависят от количества элементов и позиции вставляемого или удаляемого элемента;
-   размер списка ограничен лишь объёмом доступной памяти.

Недостатки односвязного списка следуют из особенностей его структуры:

-   Узнать адрес элемента по его порядковому номеру — операция линейной сложности. Чтобы определить адрес N-го элемента списка, нужно последовательно перебрать все N-1 элементов, начиная с первого элемента.
-   Неэффективное расходование памяти: помимо данных, каждый элемент списка хранит указатель на следующий элемент. Кроме того, при каждом создании объекта в динамической памяти пара десятков байт расходуется на поддержание структуры кучи.
-   Не такая высокая эффективность вставки и удаления. Каждая вставка и каждое удаление обращаются к операциям работы с кучей:  `new`  или  `delete`. Считается, что эти операции работают за константное время, однако константа может быть достаточно большой. При этом выполняется сложный код синхронизации между потоками, и могут быть задействованы низкоуровневые механизмы работы с памятью.
-   Соседние элементы списка могут располагаться в памяти непоследовательно, что снижает эффективность работы кэш-памяти.

Тем не менее односвязный список — одна из базовых связанных структур данных. Понять, как он работает, — значит сделать первый шаг к разработке более сложных структур. В стандартной библиотеке односвязный список представлен шаблоном класса  [`forward_list`](https://en.cppreference.com/w/cpp/container/forward_list). Вам предстоит разработать его аналог —  `SingleLinkedList`, то есть односвязный список.

Контейнер способен хранить данные произвольного типа, поэтому соответствующий класс следует объявить шаблонным:

```cpp
template <typename Type>
class SingleLinkedList {
    ...
};

```

Элемент списка называется «узел». Элемент списка можно представить в виде структуры  `Node`, которая содержит значение элемента и указатель на следующий узел. Можно сделать структуру  `Node`  шаблонной, а можно просто поместить её внутрь шаблонного класса  `SingleLinkedList`. В этом случае полное имя  `SingleLinkedList<Type>::Node`  будет содержать информацию о типе значения, которое хранится в узле:

```cpp
template <typename Type>
class SingleLinkedList {
    // Узел списка
    struct Node {
        Node() = default;
        Node(const Type& val, Node* next)
            : value(val)
            , next_node(next) {
        }
        Type value;
        Node* next_node = nullptr;
    };
    ...
};

```

----------

В списке 20 элементов. Какими данными нужно воспользоваться, чтобы узнать десятый из них?

-   Адресом первого узла.
    
-   Адресом последнего узла.
    
-   Для первых девяти узлов — адресом следующего.
    
-   Для десятого узла — адресом следующего.
    
-   Размером списка.
    

Каждый узел списка знает, где находится следующий за ним элемент, а информацией о местоположении первого узла владеет сам класс списка. Так класс списка может управлять своим содержимым — достаточно знать адрес первого элемента, чтобы добраться до всех остальных.

В простейшем случае списку, чтобы управлять своими элементами, достаточно хранить указатель на первый элемент.

_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

_Список содержит указатель на первый элемент_

Если представить список так, для его хранения потребуется минимум памяти в области стека — всего четыре или восемь байт в зависимости от размера указателя. Все остальные данные хранятся в области кучи. Но у такого способа есть недостаток — узнать количество элементов в списке можно, только пройдясь по всем его элементам.

Чтобы время вычисления длины списка не зависело от количества его элементов, можно пожертвовать четырьмя или восемью байтами и добавить в список дополнительное поле, которое хранило бы размер списка.

_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

_Чтобы не тратить время на подсчёт элементов списка, в него добавили поле  `size_`_

Пользовательский код не должен иметь возможности обратиться к узлам односвязного списка, так как:

-   Пользовательский код может случайно модифицировать структуру данных односвязного списка и нарушить её целостность. Это чревато сбоями в работе программы или утечками памяти.
-   Прямой доступ к элементам списка усложняет обход его элементов и вынуждает пользователей применять указатели.
-   Изменения в реализации списка или его узлов могут повлиять на работоспособность пользовательского кода.

Поэтому для доступа к элементам стандартных контейнеров применяют вспомогательные объекты — итераторы, которые:

-   «‎Знают»‎ о внутреннем устройстве контейнера и умеют перемещаться с одного элемента на другой.
-   Скрывают служебные данные от пользовательского кода и предоставляют простой интерфейс. Используя его, можно обращаться к значениям элементов списка и к следующему элементу.
-   Играют роль указателей на элементы контейнера в операциях вставки и удаления элементов.
-   Служат посредниками между контейнерами и алгоритмами, благодаря чему один и тот же алгоритм можно использовать с разными контейнерами.

Итератор односвязного списка хранит указатель на текущий узел. Этих данных достаточно, чтобы иметь доступ к значению узла и перемещаться к следующему узлу.

_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

_Итератор хранит указатель на узел списка_

Операции вставки и удаления элемента из односвязного списка требуют указателя на элемент, предшествующий позиции вставки/удаления. В этих операциях такой объект используется как опорный. Поэтому помимо знакомых вам итераторов  `begin`  и  `end`, присущих другим контейнерам, односвязному списка нужен итератор  `before_begin`. Данный итератор ссылается на позицию перед первым элементом:

_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

_Итераторы  `before_begin`,  `begin`  и  `end`_

Итератор, хранящий позицию  `before_begin`, обычно ссылается на фиктивный узел списка. Этот узел можно создать при инициализации списка и использовать лишь для хранения указателя на первый «‎настоящий»‎ элемент и никогда — для хранения данных. Поэтому его можно хранить не только в куче, но и в самом списке, вместо указателя на первый элемент.

_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

_Узлы, на которые ссылаются итераторы  `begin`,  `before_begin`  и  `end`_

```cpp
template <typename Type>
class SingleLinkedList {
    struct Node { ... };
private:
    Node head_;
    size_t size_;
};

```

Далее вы примените теорию на практике и шаг за шагом реализуете односвязный список. Начнём с пустого списка.

----------

Для чего нужен фиктивный узел будет ясно ближе к концу темы. А пока что ответьте на вопрос: какие проблемы он может создать?

-   Если список хранит большие объекты, то будет расходоваться лишняя память.
    
-   Не получится использовать список с типами, не имеющими конструктора по умолчанию.
    
-   Будет лишний элемент при проходе списка от начала до конца.
    
-   Нельзя создать пустой список.
    

Эти две проблемы можно обойти, но код усложнится. Поэтому будем считать, что элемент  `Type`  легко создаётся конструктором без параметров и не занимает много места.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

----------

В списке 20 элементов. Какими данными нужно воспользоваться, чтобы узнать десятый из них?

-   **(+)**  Адресом первого узла.
    
-   **(-)**  Адресом последнего узла.
    
-   **(+)**  Для первых девяти узлов — адресом следующего.
    
-   **(-)**  Для десятого узла — адресом следующего.
    
-   **(-)**  Размером списка.
    

----------

Для чего нужен фиктивный узел будет ясно ближе к концу темы. А пока что ответьте на вопрос: какие проблемы он может создать?

-   **(+)**  Если список хранит большие объекты, то будет расходоваться лишняя память.

> Фиктивный узел будет хранить один объект типа  `Type`, который не соответствует никакому значению. Это лишние данные.

-   **(+)**  Не получится использовать список с типами, не имеющими конструктора по умолчанию.

> При создании фиктивного узла нужно создать объект типа  `Type`. Параметры конструктора при этом не передаются.

-   **(-)**  Будет лишний элемент при проходе списка от начала до конца.

> `begin`  указывает на позицию после фиктивного, так что при проходе по списку вы не увидите фиктивный элемент.

-   **(-)**  Нельзя создать пустой список.

> Свежесконструированный список имеет размер 0 и состоит из одного фиктивного узла. Мы считаем такой список пустым.

</details>

<details>
<summary>Задание:</summary>

## Задание

Создайте шаблонный класс односвязного списка  `SingleLinkedList<Type>`  со следующим функционалом:

-   конструктор по умолчанию, который создаёт пустой список;
-   метод  `GetSize`, который возвращает количество элементов в списке;
-   метод  `IsEmpty`, который возвращает  `true`, если список пустой, и  `false`  в противном случае.

### Что отправлять на проверку

Только код с шаблоном класса  `SingleLinkedList`  и нужными для его работы директивами  `#include`. Функция  `main`  будет проигнорирована.

### Ограничения

Сохраните сигнатуры всех публичных методов класса  `SingleLinkedList`  неизменными, чтобы код скомпилировался без ошибок.

Не изменяйте поля класса: не добавляйте новые и не удаляйте старые, а также не меняйте их порядок.

### Как будет тестироваться ваш код

Тренажёр проверит, что в шаблоне  `SingleLinkedList`  метод  `IsEmpty`  возвращает  `true`, а метод  `GetSize`  — нулевое значение. Функция  `main`  будет проигнорирована.

### Подсказка

-   Односвязный список считается пустым, только если в нём ноль элементов.
-   Не мудрите — в этом задании нужно всего лишь реализовать пустой односвязный список.
-   Если явно заданных конструкторов нет, компилятор сам сгенерирует конструктор по умолчанию. Не забудьте задать корректные значения полям класса.

</details>
