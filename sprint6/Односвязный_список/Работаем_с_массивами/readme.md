<details>
<summary>Теория + тестирование:</summary>

# Работаем с массивами

Представьте, что вы с друзьями решили сходить в кино, и каждый из вас независимо от других купил билет на сайте кинотеатра. Придя на сеанс вы, скорее всего, обнаружите, что сидите не все вместе, а как повезёт. В тёмном зале единственный способ найти ваших друзей — это знать, на каких местах они сидят.

Так как даже тупой карандаш лучше острой памяти, вы решаете записать места друг друга до входа в зал. На беду у всех разрядились телефоны, но у каждого из вас есть небольшой лист бумаги, вмещающий информацию только об одном месте. Поэтому все кроме одного записывают ряд и номер места кого-нибудь из друзей так, чтобы не было повторов.

![1.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint6/%D0%9E%D0%B4%D0%BD%D0%BE%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA/%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D0%BC_%D1%81_%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0%D0%BC%D0%B8/img/1.png?raw=true)


_Пример расположения зрителей в зале_

Оставим за скобками культурный аспект передвижения по залу во время сеанса и подумаем. Если вы хотите найти своего k-го друга, придётся дойти до первого человека, записанного на вашем листе бумаги, узнать у него номер места следующего и двигаться так до тех пор, пока не пройдёте k человек.

Очевидно, что чем больше компания, тем больше в среднем вы будете затрачивать времени, чтобы дойти до нужного друга.

Эта аналогия описывает процесс доступа к элементу односвязного списка по его порядковому номеру. Каждый узел односвязного списка может быть в произвольном месте динамической памяти. Поэтому для связи между ними приходится хранить указатель на следующий узел списка. Чтобы добраться до  `i`-го элемента, нужно последовательно передвигаться с начала списка, пока не пройдёте  `i - 1`  предыдущих элементов. Можно сказать, что односвязный список имеет линейное время доступа к элементу по его порядковому номеру или сложность O(N).

### Знакомьтесь, массивы

Наилучшим решением было бы всем сразу купить билеты на соседние места на одном ряду.

![2.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint6/%D0%9E%D0%B4%D0%BD%D0%BE%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA/%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D0%BC_%D1%81_%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0%D0%BC%D0%B8/img/2.png?raw=true)

_Когда зрители сидят в одном ряду, найти нужного человека проще_

В этом случае каждому человеку достаточно знать, где находится его кресло относительно кресла с наименьшим номером. Ваше кресло — третье слева, если считать с нуля. Значит, чтобы дойти до Даши, которая сидит на пятом, нужно перейти на два кресла вправо. Листочки бумаги уже не понадобятся — всё упрощается, когда купленные места расположены последовательно.

Структура данных, где все элементы имеют одинаковый размер и хранятся в непрерывной области памяти один за другим, называется массивом. Доступ к элементу массива осуществляется по его индексу.

Зная адрес  `begin`  начала массива и размер  `item_size`  одного элемента, легко вычислить адрес k-го элемента:  `addr(k) = begin + item_size * k`


![3.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint6/%D0%9E%D0%B4%D0%BD%D0%BE%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA/%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D0%BC_%D1%81_%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0%D0%BC%D0%B8/img/3.png?raw=true)


_Массив из 10 элементов размером 4 байта каждый_

На иллюстрации показан массив из десяти элементов, каждый из которых занимает в памяти четыре байта. Элемент с индексом 7 располагается по адресу:

`0x0000000000400004 + 7*4 = 0x0000000000400004 + 0x1c = 0x0000000000400020`

Такая структура данных используется контейнером  `vector`. Вот почему время доступа к любому элементу вектора имеет сложность O(1): чтобы узнать адрес любого элемента массива, достаточно одного сложения с умножением.

Работа с массивами доступна не только классу  `vector`. Самый простой способ создать массив — объявить переменную и указать после её имени размер массива в квадратных скобках. Этот массив располагается в автоматической или статической области памяти, в зависимости от места своего объявления:

```cpp
// Массив из 10 int-ов со статическим временем жизни
int global_array[10];

int main() {
    // Массив из 5 int-ов с автоматическим временем жизни
    int numbers[5];

    numbers[2] = 3;
}

```

Размер массива в статической или автоматической области памяти должен быть константой времени компиляции. Компилятору нужно знать размер кадра стека функции, которая использует массивы.

Увеличить или уменьшить размер такого массива нельзя — сколько в нём было элементов при объявлении, столько останется до окончания его времени жизни. Операций копирования и присваивания для массивов тоже нет.

Эти ограничения связаны с тем, что C++ унаследовал массивы от своего предшественника, языка C. Их и называют C-массивы.

Когда работаете с массивами переменного размера в C++, выбирайте контейнер  `vector`. Для хранения небольших массивов фиксированного размера в области стека можно использовать контейнер  [`std::array`](https://en.cppreference.com/w/cpp/container/array). Это удобная обёртка над C-массивом. В следующем спринте вы познакомитесь с  `std::array`  ближе.

В этом уроке узнаете, какие возможности С++ предоставляет для низкоуровневой работы с массивами в динамической памяти. Это поможет понять, как устроены контейнеры, подобные  `vector`.

### Массивы в динамической памяти

Для создания массива в динамической памяти служит специальная форма операции  `new`  —  `new Тип[размер]`. В отличие от массива на стеке или в статической области памяти, размер массива в куче может быть произвольным значением, а не константой. Оператор  `new[]`  возвращает указатель на первый элемент созданного массива:

```cpp
size_t size;
cin >> size;

// Создаёт в куче массив из size элементов
int* numbers = new int[size];

```

Элементы созданного так массива инициализируются конструктором по умолчанию для заданного типа. Для примитивных типов вроде  `int`  и  `double`  элементы не будут проинициализированы. Чтобы выполнить инициализацию элементов, укажите их значения внутри фигурных скобок:

```cpp
// Создаёт в куче массив {0, 0, 0}
int* all_zeros = new int[3]{};

// Создаёт в куче массив {1, 2, 3, 4, 5}
int* five_numbers = new int[]{1, 2, 3, 4, 5};

// Создаёт в куче массив {1, 2, 3, 4, 5, 0, 0}
int* seven_numbers = new int[7]{1, 2, 3, 4, 5};

// Создаёт в куче пустой массив из нуля элементов
int* empty_array = new int[0];

// Создаёт в куче единичный int, равный 42
int* single_int = new int{42};

```

Когда закончите работать с массивом в динамической памяти, удалите его, используя операцию  `delete[]`. Эта операция вызывает деструкторы у всех элементов массива и освобождает память.

```cpp
int* numbers = new int[10];
...
delete[] numbers;

```

Квадратные скобки  `[]`  нужны, чтобы отличать удаление массива объектов от удаления одиночного объекта.

Среда выполнения может использовать различающиеся форматы хранения одиночных объектов и массивов в динамической памяти. Например, помимо самих элементов массива в динамической памяти может храниться его размер, а для одиночных объектов эта информация избыточна. Создатели C++ поставили во главу производительность и возложили на программиста ответственность за выбор между  `delete`  и  `delete[]`. Использование непарной версии операции  `delete`, например  `delete`  без квадратных скобок после  `new int[10]`, приведёт к неопределённому поведению.

### Связь указателей и массивов, адресная арифметика

Итак, у вас есть указатель, ссылающийся на первый элемент массива. Обратиться к остальным элементам массива вы можете, используя операцию  `[]`:

```cpp
int* my_array = new int[10];

// Следующие две строки делают одно и то же
my_array[0] = 1;
*my_array = 1;

my_array[3] = my_array[2];

delete[] my_array;

```

Аналогичные действия можно выполнять с указателем, ссылающимся на любой элемент массива, в том числе по отрицательному индексу. В этом случае к элементу массива можно обратиться как по его абсолютном индексу в массиве, так и по смещению относительно другого элемента с известным адресом.

![4.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint6/%D0%9E%D0%B4%D0%BD%D0%BE%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA/%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D0%BC_%D1%81_%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0%D0%BC%D0%B8/img/4.png?raw=true)

_Схема массива из 10-ти элементов. Под ячейками указаны индексы, а над ними — смещения относительно 4-го элемента_

```cpp
int* my_array = new int[10]{};

int* p = &my_array[4];  // указатель на элемент с индексом 4

p[-1] = 42;  // запись в элемент с индексом 3 (3 = 4 - 1)
p[3] = 128;  // запись в элемент массива с индексом 7 (7 = 4 + 3)

// В этом месте массив содержит следующие элементы:
// 0, 0, 0, 42, 0, 0, 0, 128, 0, 0

delete[] my_array;

```

----------

Чему будет равно значение переменной  `k`  в следующей программе? Введите целое число:

```cpp
int numbers[] = {3, 5, 3, 2, 1, 6, 8};
int* p = &numbers[2];
int k = p[2];

```

Имя массива может выступать в роли указателя на его начальный элемент:

![5.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint6/%D0%9E%D0%B4%D0%BD%D0%BE%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA/%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D0%BC_%D1%81_%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0%D0%BC%D0%B8/img/5.png?raw=true)

```cpp
int numbers[3];
int* item0_ptr = numbers; // в item_0 хранится указатель на начальный элемент массива
assert(item0_ptr == &numbers[0]);

```

Обращаться к элементам за пределами массива для чтения или записи нельзя — будет неопределённое поведение. При этом неважно, в динамической, автоматической или статической памяти располагался массив:

```cpp
int* numbers = new int[10];
int* item4_ptr = &numbers[4];

numbers[10] = 0; // неопределённое поведение - выход за пределы массива
numbers[-1] = 0; // неопределённое поведение - выход за пределы массива
item4_ptr[6] = 0; // неопределённое поведение - обращение к элементу массива с индексом 10

delete numbers;  // неопределённое поведение - использование delete вместо delete[]

string names[2];
names[5] = "Ivan"s; // неопределённое поведение - выход за пределы массива

```

Можно взять адрес ячейки памяти, следующей за последним элементом массива. Разыменовывать этот указатель нельзя, но можно использовать в качестве опорного указателя для доступа к существующим элементам массива.

```cpp
int* my_array = new int[10];

// Разрешается взятие адреса элемента, следующего за последним:
int* end = &my_array[10];

// Следующие две строки делают одно и то же:
end[-1] = 43;
my_array[9] == 43;

assert(&end[-1] == &my_array[9]);

delete[] my_array;

```

Указатели на элементы массива и целые числа можем использовать в выражениях адресной арифметики, которая включает в себя следующие операции:

-   разность указателей,
-   сумма указателя и числа,
-   разность указателя и числа,
-   инкремент и декремент указателя,
-   сравнение указателей.

Если  `p`  — указатель на некоторый элемент массива, то:

-   `p+1`  — указатель на следующий за ним элемент массива;
-   `p-1`  — указатель на предыдущий элемент массива;
-   `p+N`  — указатель на N-й элемент массива относительно  `p`;
-   `++p`  выполняет инкремент указателя  `p`, после чего он будет указывать на следующий элемент массива;
-   `--p`  выполняет декремент указателя  `p`.

Если  `p`  и  `q`  — указатели на некоторые элементы одного и того же массива, то:

-   `p - q`  равно количеству элементов после  `q`, которое необходимо добавить, чтобы получить  `p`;
-   `p < q`  истинно, если  `p`  ссылается на элемент массива, предшествующий  `q`;
-   `p == q`  истинно, если  `p`  и  `q`  ссылаются на один и тот же элемент массива.

![6.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint6/%D0%9E%D0%B4%D0%BD%D0%BE%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA/%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D0%BC_%D1%81_%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0%D0%BC%D0%B8/img/6.png?raw=true)

----------

Дана программа:

```cpp
int values[] = {7, 3, 6, 2, 2, 8, 5, 6};
int* p = values + 5;
int* q = p - 3;
int* t = &values[8];

```

Выберите верные утверждения. Их может быть несколько:

-   `p < q`
    
-   `t - values == 8`
    
-   `q+3 == p`
    
-   `q-p == 3`
    
-   `p-q == 3`
    
-   `p+1 == t-2`
    
-   `t == q+3`
    
-   `q-t == 6`
    
-   `q+2 > p-2`
    
-   `q-p == -3`
    
-   `q-1 == p+2`
    
-   `q[5] == p[-3]`
    

### Указатели как итераторы по элементам массивов

Благодаря перегрузке операций итераторы стандартных контейнеров предоставляют множество операций или его часть, в зависимости от контейнера. Этим множеством обладают указатели:

-   Операция разыменования  `*`  указателя возвращает ссылку на объект. Итератор возвращает ссылку на значение элемента контейнера;
-   Операции инкремента и декремента указателя перемещают его на следующий и предыдущий элементы массива. Инкремент и декремент итератора перемещают его к следующему или предыдущему элементу контейнера;
-   Операции адресной арифметики над указателями выполняют перемещение вперёд или назад за константное время. Аналогичные действия возможны и над итераторами произвольного доступа контейнера  `vector`  или  `deque`.

Благодаря сходству интерфейсов указателей и итераторов стандартные алгоритмы С++ можно применять к элементам контейнера и массивов в памяти. Разница между итераторами и указателями — в толщине слоя абстракции от «‎железа». Операции с указателями выполняются максимально быстро, но ограничены использованием в массивах. Итераторы в этом плане более интеллектуальны, но менее быстры за счёт накладных расходов при обходе более сложных структур данных контейнеров. Исключение могут составить разве что итераторы контейнера  `vector`, для которых современные компиляторы способны сгенерировать код, аналогичный использующему указатели.

Объявив массив в статической или автоматической памяти, можно использовать функции  `std::begin`  и  `std::end`  и получить итераторы на его начало и конец:

```cpp
#include <algorithm>

int main() {
    using namespace std;

    int numbers[] = {1, 2, 4, 8, 1, 6, 3, 2, 6, 4};
    sort(begin(numbers), end(numbers));
}

```

Адрес начала данных контейнера  `vector`  предоставляет метод  `data`. Возвращённый им указатель задаёт полуинтервал  `[data(); data() + size())`. Внутри этого полуинтервала содержатся элементы контейнера  `vector`. Как правило, метод  `data()`  используют для передачи содержимого  `vector`  в функции ОС или в низкоуровневые библиотеки:

```cpp
#include <vector>

struct Point {
    int x;
    int y;
};

// Функция DrawPolygon рисует многоугольник, состоящий из num_points вершин,
// расположенных в массиве по адресу points.
void DrawPolygon(const Point* points, size_t num_points){
    /* ... */
}

int main() {
    using namespace std;
    vector<Point> polygon;
    for (int i = 0; i < num_vertices; ++i) {
        Point vertex;
        /* Вычисляем координаты очередной вершины многоугольника */
        polygon.push_back(vertex);
    }
    // Передаём адрес массива вершин и их количество в функцию рисования многоугольника
    DrawPolygon(polygon.data(), polygon.size());

    const Point triangle_vertices[3] = {{100, 100}, {0, 0}, {200, 0}};
    // DrawPolygon может использоваться и с обычными массивами.
    // Например, для рисования треугольника
    DrawPolygon(triangle, 3);
}
```

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Чему будет равно значение переменной  `k`  в следующей программе? Введите целое число:

```cpp
int numbers[] = {3, 5, 3, 2, 1, 6, 8};
int* p = &numbers[2];
int k = p[2];

```

-   Так как  `p`  ссылается на элемент массива с индексом два,  `p[2]`  обратится к элементу с индексом четыре, значение которого равно единице.

----------

Дана программа:

```cpp
int values[] = {7, 3, 6, 2, 2, 8, 5, 6};
int* p = values + 5;
int* q = p - 3;
int* t = &values[8];

```

Выберите верные утверждения. Их может быть несколько:

-   **(-)**  `p < q`

> `p`  ссылается на элемент с индексом пять, а  `q`  — на элемент с индексом два. Выражение  `p < q`  ложно, так как пятый элемент не предшествует второму.

-   **(+)**  `t - values == 8`

> Так как  `t`  ссылается на ячейку памяти, следующую за последним элементом массива, а имя массива  `values`  выступает в качестве указателя на его начальный элемент, разность между  `t`  и  `values`  равна количеству элементов в массиве, то есть 8.

-   **(+)**  `q+3 == p`

> Это следует из инициализации  `q = p - 3`.

-   **(-)**  `q-p == 3`

> Разность указателей  `q`  и  `p`  равна количеству элементов, которые надо добавить после  `p`, чтобы получить  `q`. Так как  `q`  ссылается на второй элемент, а  `p`  - на пятый, их разность равна -3. От позиции  `p`  надо сделать три шага назад, чтобы получить  `q`.

-   **(+)**  `p-q == 3`

> Это следует из инициализации  `q = p - 3`.

-   **(+)**  `p+1 == t-2`

> И левое, и правое подвыражение ссылаются на элемент с индексом четыре.

-   **(-)**  `t == q+3`

> `q + 3`  возвращает указатель на пятый элемент массива, а  `t`  - адрес псевдоэлемента с индексом восемь.

-   **(-)**  `q-t == 6`

> Выражение  `t-q`  равно 6, а  `q-t`  равно -6.

-   **(+)**  `q+2 > p-2`

> `p - 2`  ссылается на четвёртый элемент, а  `q + 2`  — на следующий за ним третий.

-   **(+)**  `q-p == -3`

> Это следует из инициализации  `q = p - 3`.

-   **(-)**  `q-1 == p+2`

> Указатели  `q - 1`  и  `p + 2`  ссылаются на первый и седьмой элементы массива.

-   **(+)**  `q[5] == p[-3]`

> `q[5]`  получает значение седьмого элемента, а  `p[-3]`  — значение второго. Значения обоих элементов равны шести.

</details>

<details>
<summary>Задание:</summary>

## Задание

Напишите шаблонную функцию  `ReverseArray`, которая заменяет порядок элементов массива на противоположный. Функция принимает адрес первого элемента массива и количество элементов массива.

Сигнатура функции  `ReverseArray`:

```cpp
template <typename T>
void ReverseArray(T* start, size_t size);

```

Переданный массив может быть пустым или непустым. В случае пустого массива параметр  `size`  равен нулю, а указатель  `start`  может быть как нулевым, так и ненулевым указателем. Если массив непустой, указатель  `start`  будет ненулевым.

### Ограничения

Функция  `ReverseArray`  должна использовать O(1) дополнительной памяти, то есть её объём не должен зависеть от размера массива. Например, нельзя использовать  `vector`  или иной контейнер для промежуточного хранения элементов. Ограничение по времени выполнения — O(N).

### Что отправлять на проверку

Только код функции  `ReverseArray`  и, возможно, нужные для её работы директивы  `#include`. Если отправите  `main`, она будет заменена на версию из тренажёра.

### Как будет тестироваться ваш код

Шаблон функции  `ReverseArray`  будет протестирован на массивах различного размера с разными типами элементов. Не меняйте сигнатуру функции  `ReverseArray`, чтобы код скомпилировался без ошибок.

### Подсказка

Корректно обрабатывайте вырожденные случаи — пустой массив и массив из одного элемента. Убедитесь, что программа правильно работает с массивами чётного и нечётного размеров.

</details>
