<details>
<summary>Теория:</summary>

# Создаём RAII-обёртку над массивом в динамической памяти

Когда в повседневной работе вам нужен массив, динамически изменяющий свои размеры, выбирайте  `vector`. Это производительный и надёжный контейнер, подходящий для решения большинства прикладных задач.

Но в рамках курса вы намеренно будете отступать от этого правила и заново изобретать велосипед, чтобы узнать о внутреннем устройстве привычных инструментов и лучше понимать их достоинства и недостатки.

В этом уроке вы начнёте создавать аналог контейнера  `vector`  и сделаете умный указатель для управления массивом в динамической памяти.

Вы уже создавали умный указатель  `ScopedPtr`, упрощающий работу с объектами в динамической памяти.

----------

Можно ли использовать  `ScopedPtr`  для управления массивом объектов в динамической памяти?

-   Можно.
    
-   Нельзя.
    

----------

Итак,  `ScopedPtr`  не подходит для управления массивом. Поэтому рассмотрим особенности, которыми должен обладать новый умный указатель  `ArrayPtr`.

Как и в случае обычного указателя, способного ссылаться на  `nullptr`  или на существующий массив, конструкторы  `ArrayPtr`  предлагают различные способы создать умный указатель:

```cpp
template <typename Type>
class ArrayPtr {
public:
    // Инициализирует ArrayPtr значением nullptr
    ArrayPtr() noexcept {...}

    // Инициализирует ArrayPtr значением переданного указателя raw_ptr
    explicit ArrayPtr(Type* raw_ptr) noexcept {...}
    
    // Создаёт в динамической памяти массив из size элементов и инициализирует ArrayPtr его адресом
    explicit ArrayPtr(size_t size) {...}
};

```

Внутри  `ArrayPtr`  должен содержаться сырой указатель, хранящий адрес нулевого элемента массива в динамической памяти. При разрушении  `ArrayPtr`  должно происходить удаление массива в куче при помощи  `delete[]`.

```cpp
template <typename Type>
class ArrayPtr {
public:
    ~ArrayPtr() {
        // Удалить массив, адрес которого содержится в поле raw_ptr_
    }
    ...
private:
    Type* raw_ptr_;  // указатель на массив в динамической памяти 
};

```

Чтобы  `ArrayPtr`  мог предоставлять доступ к элементам массива по их индексу, подобно обычным массивами и  `vector`, перегрузим операцию  `[]`.

Операция  `[]`  принимает один аргумент и перегружается как член класса или структуры. Как правило она возвращает ссылку на соответствующий элемент контейнера. Последующие операции над возвращённой ссылкой, например, присваивание, модифицируют значение элемента:

```cpp
vector<int> v;
...
// Сначала v[3] вернёт ссылку на третий элемент,
// а затем оператор присваивания изменит значение этого элемента
v[3] = 5;

```

Часто перегружают две версии операции  `[]`  — константную и неконстантную. Константная версия оператора возвращает константную ссылку на элемент. Благодаря этому можно защитить содержимое контейнера от модификации — модифицировать значение константы нельзя.

Бывают исключения: в контейнере  `map`  есть только неконстантная версия операции  `[]`. Если элемента с указанным ключом нет, она вставляет ключ со значением по умолчанию.

Для контейнера  `ArrayPtr`  перегрузим обе версии  `[]`:

```cpp
template <typename Type>
class ArrayPtr {
public:
    Type& operator[](size_t index) noexcept { ... }
    const Type& operator[](size_t index) const noexcept { ... }
    ...
};

```

Чтобы доступ по индексу был максимально быстрым, операции объявлены  `noexcept`.  `ArrayPtr`  не хранит размер массива, поэтому следить за корректностью передаваемых индексов должен программист.

Запретив конструктор копирования и операцию присваивания, мы упростим класс, а метод  `Release`  позволит передавать этот указатель на массив из одной области видимости в другую без копирования элементов. Метод  `swap`  эффективно обменяет значения двух объектов  `ArrayPtr`. Это пригодится при использовании знакомой вам идиомы copy-and-swap:

```cpp
template <typename Type>
class ArrayPtr {
public:
    ArrayPtr(const ArrayPtr&) = delete;
    ArrayPtr& operator=(const ArrayPtr&) = delete;
    Type* Release() noexcept { ... }
    void swap(const ArrayPtr& other) noexcept { ... }
    ...
};
```

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Можно ли использовать  `ScopedPtr`  для управления массивом объектов в динамической памяти?

-   **(-)**  Можно.
    
-   **(+)**  Нельзя.

</details>

<details>
<summary>Задание:</summary>

## Задание

Разработайте шаблонный класс  `ArrayPtr`, играющий роль умного указателя на массив в динамической памяти. У него должен быть такой функционал:

-   удаление массива при разрушении умного указателя;
-   конструкторы: по умолчанию, из указателя на существующий массив, создающий новый массив заданного размера;
-   доступ к элементу массива по индексу;
-   запрет операций копирования и присваивания;
-   метод  `swap`  для обмена содержимым с другим объектом  `ArrayPtr`;
-   метод  `Release`, прекращающий владение массивом и возвращающий значение сырого указателя.

### Ограничения

Сохраните сигнатуры всех публичных методов класса  `ArrayPtr`  неизменными, чтобы код скомпилировался без ошибок.

### Что отправлять на проверку

В решении должен быть класс  `ArrayPtr`  с нужными для его компиляции директивами  `#include`. Функция  `main`  учитываться при проверке не будет.

### Как будет тестироваться ваш код

В качестве указателя, передаваемого в конструктор  `ArrayPtr`, будет передаваться  `nullptr`  либо адрес массива в динамической памяти.

### Подсказка

Посмотрите на использование  `ArrayPtr`  и комментарии к его методам в заготовке решения

</details>
