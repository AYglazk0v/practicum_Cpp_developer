<details>
<summary>Теория + тестирование:</summary>

# Статическое и автоматическое размещение объектов в памяти

Память для программ на языке C++ можно разделить на несколько независимых областей:

-   для объектов со статическим временем жизни;
-   для объектов с автоматическим временем жизни;
-   для объектов с динамическим временем жизни;
-   для объектов в локальной памяти потока. В рамках этой темы память потока рассматривать не будем.

Как правило, объекты с разным временем жизни размещаются в разных частях адресного пространства. Такой подход помогает эффективнее использовать доступную память. Вы указываете, как должен храниться объект, а компилятор и среда выполнения отвечают за его размещение в памяти.

_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

_Один из способов распределить адресное пространство программы_

Области памяти для объектов с автоматическим и динамическим временем жизни «растут» навстречу друг другу, а размер области для объектов со статическим временем жизни остаётся постоянным.

### Память для объектов со статическим временем жизни

Статическим временем жизни обладают глобальные переменные и локальные статические переменные функций. Область памяти для их хранения выделяется при старте программы и освобождается при её завершении:

```cpp
#include <iostream>

using namespace std;

int value = 0;

void Fn() {
    // Глобальная переменная value существует в единственном экземпляре.
    // Адрес переменной value будет тот же, какой был получен в функции main
    cout << "Fn(): &value="s << &value << endl;
    value = 1;
}

int main() {
    cout << "main(): &value="s << &value << endl;
    cout << "value="s << value << endl;
    Fn();
    // Функция Fn изменила значение переменной value. Это изменение будет
    // видно и в функции main
    cout << "value="s << value << endl;
}

```

Скопируйте код в свою IDE и запустите. Возможный вывод программы:

```
main(): &value=00007FF68C874150
value=0
Fn(): &value=00007FF68C874150
value=1

```

Так как переменная  `value`  — глобальная, её адрес остаётся неизменным на протяжении всей работы программы. Любая функция может изменить значение  `value`  и повлиять тем самым на работу остальных функций, которые используют эту глобальную переменную.

### Автоматическое выделение памяти для хранения объектов

Память для хранения объекта автоматически выделяется при входе в блок, где этот объект объявлен, и освобождается при выходе из блока. Такой способ выделения памяти используют локальные переменные и аргументы функций.

Стандарт C++ не оговаривает, как должно происходить автоматическое выделение памяти для локальных переменных. Распространённые компиляторы хранят локальные переменные в области памяти, где располагается стек вызовов функций.

При входе в функцию программа выделяет кадр стека — блок памяти, способный вместить все локальные переменные текущей функции. При выходе из функции этот кадр удаляется.

_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

_Кадры стека вызовов функций  `main`→`Func1`→`Func2`_

Работу автоматического выделения памяти можно увидеть на примере функции  `Factorial`  для рекурсивного вычисления факториала. При каждом вызове она выводит адрес параметра  `n`. Параметры функции выделяются в автоматической области памяти. Так вы можете проследить адрес этой области при каждом вызове функции:

```cpp
#include <iostream>

using namespace std;

// Функция для рекурсивного вычисления факториала:
// 0! = 1
// n! = n*(n-1)!
int Factorial(int n) {
    cout << "  Factorial("s << n << "): &n="s << &n << endl;
    return n > 0 ? n * Factorial(n - 1) : 1;
}

int main() {
    for (int i = 0; i < 4; ++i) {
        cout << "=== Calculating factorial of "s << i << " ==="s << endl;
        int f = Factorial(i);
        cout << "Result is: "s << f << endl << endl;
    }
}

```

Скопируйте код себе. Скомпилируйте и запустите его. Цифры зависят от вашего компилятора и операционной системы, поэтому могут получиться иными. Они даже могут различаться при каждом запуске. Важно просто обратить внимание на закономерности в адресах:

```
=== Calculating factorial of 0 ===
  Factorial(0): &n=0000005D1D0FF9B0
Result is: 1

=== Calculating factorial of 1 ===
  Factorial(1): &n=0000005D1D0FF9B0
  Factorial(0): &n=0000005D1D0FF8E0
Result is: 1

=== Calculating factorial of 2 ===
  Factorial(2): &n=0000005D1D0FF9B0
  Factorial(1): &n=0000005D1D0FF8E0
  Factorial(0): &n=0000005D1D0FF810
Result is: 2

=== Calculating factorial of 3 ===
  Factorial(3): &n=0000005D1D0FF9B0
  Factorial(2): &n=0000005D1D0FF8E0
  Factorial(1): &n=0000005D1D0FF810
  Factorial(0): &n=0000005D1D0FF740
Result is: 6

```

При первом входе в функцию  `Factorial`  адрес, по которому расположена переменная  `n`, всегда один и тот же —  `0000005D1D0FF9B0`. С каждым следующим рекурсивным вызовом переменная  `n`  размещается по адресу, меньшему на  `0xD0`  — 208 в десятичной системе.

Можно сделать вывод, что размер кадра стека функции  `Factorial`  равен 208 байтам. Стек на платформе x86/x64 «растёт» сверху вниз. Этим объясняется уменьшение адреса размещения локальных переменных при вложенных вызовах функции.

_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

_Кадры стека при вычислении  `Factorial(2)`  и  `Factorial(3)`_

----------

Дан текст программы:

```cpp
int speed = 12;

int Run(int time) {
    int distance = speed * time;
    speed /= 2;
    return distance;
}

int main() {
    int distance = Run(10) + Run(10) + Run(10);
}

```

Чему будет равно значение переменной  `distance`  перед выходом из функции  `main`?

----------

Что выведет в  `output`  эта программа? Введите ответ в одну строку без пробелов.

```cpp
#include <iostream>

using namespace std;

struct Log {
    explicit Log(int id)
        : id_(id) 
    {
        cout << id_;
    }

    ~Log() {
        cout << "-" << id_;
    }

private:
    int id_;
};

void One() {
    Log local1{1};
}

void Two() {
    Log local2{2};
    One();
    Log local3{3};
}

Log global1{4};

int main() {
    Two();
}

Log global2{5};

```

В этом уроке вы узнали о статическом и автоматическом размещении объектов в памяти программы. Время жизни таких объектов строго детерминировано и за его соблюдением следит компилятор.

За простоту статического и автоматического хранения приходится платить ограниченными функциональными возможностями. Для хранения локальных переменных при каждом вызове функции выделяется кадр стека фиксированного размера. Объекты со статическим размещением существуют в программе в единственном экземпляре.

Динамическое размещение памяти позволяет программе создавать столько объектов, сколько нужно для решения задачи, а потом удалять эти объекты, когда задача решена. В следующем уроке познакомитесь с динамической памятью.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Дан текст программы:

```cpp
int speed = 12;

int Run(int time) {
    int distance = speed * time;
    speed /= 2;
    return distance;
}

int main() {
    int distance = Run(10) + Run(10) + Run(10);
}

```

Чему будет равно значение переменной  `distance`  перед выходом из функции  `main`?

-   210. Функция  `Run`  три раза вызывается с одним и тем же значением  `time`. Однако скорость перемещения после каждого забега уменьшается вдвое. В результате пройденное расстояние будет равно 12*10 + 6*10 + 3*10 = 210. Вот так глобальные переменные неочевидным образом усложняют анализ работы программы.

----------

Что выведет в  `output`  эта программа? Введите ответ в одну строку без пробелов.

```cpp
#include <iostream>

using namespace std;

struct Log {
    explicit Log(int id)
        : id_(id) 
    {
        cout << id_;
    }

    ~Log() {
        cout << "-" << id_;
    }

private:
    int id_;
};

void One() {
    Log local1{1};
}

void Two() {
    Log local2{2};
    One();
    Log local3{3};
}

Log global1{4};

int main() {
    Two();
}

Log global2{5};

```

-   `4521-13-3-2-5-4`
    
-   До выполнения функции  `main`  конструкторы глобальных переменных  `global1`  и  `global2`  выведут  `45`.
    
-   Функция  `main`  вызовет функцию  `Two`, где конструктор переменной  `local2`  выведет  `2`.
    
-   Функция  `Two`  вызовет функцию  `One`, где конструктор переменной  `local1`  выведет  `1`, а её деструктор выведет  `-1`. Произойдёт возврат в функцию  `Two`.
    
-   Конструктор переменной  `local3`  внутри функции  `Two`  выведет  `3`. Следом деструкторы  `local3`  и  `local2`  выведут  `-3-2`. Произойдёт выход в функцию  `main`.
    
-   После выхода из  `main`  запустится процесс разрушения переменных со статическим временем жизни в порядке, обратном их конструированию в текущем .cpp файле. Сначала деструктор переменной  `global2`  выведет  `-5`, а затем деструктор переменной  `global1`  выведет  `-4`.

</details>
