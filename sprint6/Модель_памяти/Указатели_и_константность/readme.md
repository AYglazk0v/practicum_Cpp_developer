<details>
<summary>Теория:</summary>

# Указатели и константность

В прошлом уроке вы познакомились с указателями — переменными, хранящими адреса объектов в памяти. Операция  `&`  позволяет взять адрес объекта и сохранить его в переменную-указатель. В нужный момент вы разыменовываете этот указатель операцией  `*`, чтобы прочитать или изменить состояние объекта.

Переменные в C++ можно объявить константными, чтобы защитить их значения от непреднамеренной модификации. При попытке изменить константную переменную компилятор выдаст ошибку.

### Указатель на константу

Свойство константности сохраняется и при взятии адреса объекта. Операция  `&`  возвращает указатель на константный объект — его ещё называют указателем на константу. Такой указатель разрешает читать значение объекта, но не модифицировать его:

```cpp
#include <cassert>

int main() {
    const int value = 42;

    // Ошибка: неконстантная ссылка не может ссылаться на константный объект
    // int& value_ref = value;

    // А вот так можно
    const int& const_value_ref = value;
    
    // Ошибка: указатель на неконстантное значение не может хранить адрес константного объекта
    // int* value_ptr = &value;

    // Указатель на константу типа int.
    const int* const_value_ptr = &value;
    // можно также объявить как int const* - это одно и то же

    // Указатель на константу можно использовать только для чтения значения объекта
    assert(*const_value_ptr == 42);
    // Выполнить модификацию объекта с его помощью нельзя.
    // Следующая строка не скомпилируется:
    // *const_value_ptr = 43;
}

```

Здесь компилятор не разрешает задать указателю типа  `int*`  значение адреса константного объекта. Такой указатель позволил бы изменить состояние объекта. В этом плане указатели на константу похожи на константные ссылки.

![1.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint6/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8/%D0%A3%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8_%D0%B8_%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C/img/1.png?raw=true)


_Указатель на неизменяемое значение типа  `const int`_

Указатель на константу может хранить адрес неконстантного объекта и таким образом предоставить доступ к объекту только для чтения. В этом случае указатель на константу ведёт себя подобно константой ссылке.

Константные ссылки и указатели на константу запрещают модифицировать объект, только если вы используете именно их. Изменять значение объекта иным способом можно.

```cpp
#include <cassert>

int main() {
    int value = 42;

    // Указатель на константу может хранить адрес неконстантного объекта
    const int* const_value_ptr = &value;

    // Константная ссылка может ссылаться на неконстантный объект
    const int& const_value_ref = value;

    value = 43;

    // Константные ссылки и указатели на константу означают, что
    // через них нельзя изменить значение объекта. Само значение 
    // может быть изменено иным способом.
    assert(const_value_ref == 43);
    assert(*const_value_ptr == 43);
} 

```

В этой программе доступ к переменной  `value`  через указатель  `const_value_ptr`  разрешается только для чтения. Саму переменную  `value`  можно изменять как обычно.

![2.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint6/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8/%D0%A3%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8_%D0%B8_%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C/img/2.png?raw=true)

_Указатель типа  `const int`_`*`  указывает на изменяемое значение типа  `int`. Изменение через указатель невозможно*

### Изменение значения указателя

В отличие от ссылок, указатели могут в процессе жизни менять своё значение, храня в разные моменты времени адреса разных объектов. Простейший способ изменить значение указателя — присвоить ему адрес другого объекта:

```cpp
#include <cassert>
#include <iostream>
#include <string>

using namespace std;

int main() {
    int value = 1;

    // Сначала value_ptr ссылается на value
    int* value_ptr = &value;

    cout << "&value: "s << &value << endl;
    cout << "value_ptr: "s << value_ptr << endl;
    assert(*value_ptr == 1);

    int another_value = 2;
    // Затем ссылается на another_value
    value_ptr = &another_value;

    cout << "&another_value: "s << &another_value << endl;
    cout << "value_ptr: "s << value_ptr << endl;
    assert(*value_ptr == 2);
}

```

Возможный вывод этой программы:

```
&value: 00000031D55AFC20
value_ptr: 00000031D55AFC20
&another_value: 00000031D55AFC24
value_ptr: 00000031D55AFC24

```

Указатель на константу сам константой не будет и может в любой момент начать ссылаться на другой объект:

```cpp
#include <cassert>
#include <iostream>
#include <string>

using namespace std;

int main() {
    int value = 1;

    // Указатель на константу. Само значение указателя константным не является.
    const int* value_ptr = &value;
    assert(*value_ptr == 1);

    int another_value = 2;

    // Можно присвоить указателю адрес другого объекта.
    value_ptr = &another_value;
    assert(*value_ptr == 2);
}
```

![3.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint6/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8/%D0%A3%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8_%D0%B8_%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C/img/3.png?raw=true)

_Два значения типа  `int`  и указатель типа  `const int`_`*`, указывающий на одно из них*

### Константные указатели

Константным может быть не только объект, на который ссылается указатель, но и сам указатель. Значение константного указателя нельзя изменить после инициализации. Чтобы объявить такой указатель, поставьте  `const`  справа от знака  `*`. Как и обычная константа, константный указатель должен быть инициализирован при объявлении:

```cpp
int value = 42;
int* const const_ptr_to_value = &value;

int another_value = 5;
// Ошибка: нельзя изменить значение константного указателя
// const_ptr_to_value = &another_value;
```

![4.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint6/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8/%D0%A3%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8_%D0%B8_%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C/img/4.png?raw=true)

_Неизменяемый указатель, указывающий на изменяемое значение_

### Константные указатели на константу

Как вы могли догадаться, константными могут быть как сам указатель, так и данные, на которые он ссылается. В этом случае разместите ключевое слово  `const`  с обеих сторон от символа  `*`:

```cpp
int value = 42;
const int* const const_ptr_to_const_value = &value;

int another_value = 5;
// Ошибка: нельзя изменить значение константного указателя:
// const_ptr_to_const_value = &another_value;

// Ошибка: нельзя изменить значение данных через указатель:
// *const_ptr_to_const_value = 0;

```

![5.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint6/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8/%D0%A3%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8_%D0%B8_%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C/img/5.png?raw=true)

_Неизменяемый указатель, указывающий на неизменяемое значение_

### Определение типа указателя

Есть простое мнемоническое правило, которое позволяет запомнить, к чему относится  `const`  в типе указателя. Для этого прочитайте объявление указателя  **справа налево**, заменяя символ  `*`  на слово «указатель». Например:

```cpp
// p1 - это указатель на данные типа int
int* p1;

// p2 - это указатель на данные типа const int
const int* p2;

int data = 42;

// p3 - это константный указатель на данные типа int
int* const p3 = &data;

// p4 - это константный указатель на данные типа const int
const int* const p4 = &data;

```

----------

-   `const string *`
    
-   `vector<string> * const`
    
-   `const vector<string*>`
    
-   `map<int, const string> * const`
    
-   `string const *`
    
-   `char const * const`
    

### Указатели и константность — итоги

Указатели на константу нужны, чтобы хранить адрес константного объекта и ограничивать доступ к неконстантным объектам. Сам указатель также может быть константным — в этом случае адрес, хранящийся в нём, нельзя менять после инициализации.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

----------

-   `const string *`

-   `vector<string> * const`

-   `const vector<string*>`

-   `map<int, const string> * const`

-   `string const *`

-   `char const * const`

</details>

<details>
<summary>Задание:</summary>

## Задание

Попрактикуйтесь использовать константные указатели на примере программы, которая ведёт учёт кошек. В ней кошки представлены структурой  `Cat`, задающей имя, пол, породу и возраст:

```cpp
// Породы кошек
enum class CatBreed {
    Bengal,
    Balinese,
    Persian,
    Siamese,
    Siberian,
    Sphynx,
};

// Пол
enum class Gender {
    Male,
    Female,
};

struct Cat {
    string name;
    Gender gender;
    CatBreed breed;
    int age;
};

```

Для хранения кошек используется контейнер  `vector`:

```cpp
int main() {
    const vector<Cat> cats = {
        {"Tom"s, Gender::Male, CatBreed::Bengal, 2},
        {"Leo"s, Gender::Male, CatBreed::Siberian, 3},
        {"Luna"s, Gender::Female, CatBreed::Siamese, 1},
        {"Charlie"s, Gender::Male, CatBreed::Balinese, 7},
        {"Ginger"s, Gender::Female, CatBreed::Sphynx, 5},
        {"Tom"s, Gender::Male, CatBreed::Siamese, 2},
    };
    ...
}

```

Требуется создать в программе несколько одновременно существующих представлений этой коллекции, отсортированных по разным критериям:

1.  По породе и имени. Кошки одинаковой породы сортируются по имени.
2.  По полу и породе.

Простейшее решение — создать несколько копий вектора кошек и отсортировать их по заданным критериям. Основной недостаток решения — избыточное потребление памяти. Каждая кошка будет храниться в нескольких экземплярах со всеми своими данными. Представьте, что вам пришлось бы клонировать оригинальный набор кошек, а потом отсортировать копию каждого набора. Слишком много кошек!

Более эффективно хранить каждую кошку в единственном экземпляре в контейнере  `cats`. Отсортированное представление контейнера  `cats`  можно задать в виде вектора указателей, которые ссылаются на кошек из  `cats`  и отсортированы как надо. Для хранения указателя нужно в несколько раз меньше памяти, чем для хранения данных о кошке. Такое решение аналогично сортировке листков бумаги с адресами этих замечательных животных.

![6.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint6/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8/%D0%A3%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8_%D0%B8_%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C/img/6.png?raw=true)

_Два индекса используют одни и те же данные_

### Требования

Напишите

-   шаблонную функцию  `GetSortedCats`, которая принимает константную ссылку на массив кошек,
-   функцию-компаратор, которая проверяет кошек на упорядоченность.

`GetSortedCats`  должна вернуть контейнер  `vector<const Cat*>`, содержащий указатели на элементы вектора кошек. Для сортировки указателей используйте переданную функцию-компаратор:

```cpp
// Возвращает массив указателей на элементы вектора cats, отсортированные с использованием
// компаратора comp. Компаратор comp - функция, принимающая два аргумента типа const Cat&
// и возвращающая true, если значения упорядочены, и false в ином случае
template <typename Comparator>
vector<const Cat*> GetSortedCats(const vector<Cat>& cats, const Comparator& comp) {
    ...
}

int main() {
    const vector<Cat> cats = { ... };

    auto sorted_cats = GetSortedCats(cats, [](const Cat& lhs, const Cat& rhs) {
        // Сравниваем кошек по породе и имени
        return tie(lhs.breed, lhs.name) < tie(rhs.breed, rhs.name);
    });
    // sorted_cats - вектор указателей на кошек, отсортированных по кличке и имени
    ...
}

```

Чтобы вывести информацию о кошках из массива указателей, напишите функцию  `PrintCatPointerValues`:

```cpp
// Выводит в поток out кошек, на которых ссылаются указатели вектора cat_pointers.
// Пример вывода:
// {{Tom, male, breed: Bengal, age:2}, {Charlie, male, breed: Balinese, age:7}}
void PrintCatPointerValues(const vector<const Cat*>& cat_pointers, ostream& out) {
    ...
}

int main() {
    ...
    auto sorted_cats = GetSortedCats(...);
    PrintCatPointerValues(sorted_cats, cout);
    ...
}

```

В заготовке кода есть готовые операции вывода кошек в поток.

### Ограничения

Вектор кошек, передаваемый в функцию  `GetSortedCats`, может содержать от 0 до 1000000 кошек. Клички кошек могут содержать буквы английского алфавита в разном регистре и пробелы, например: “Cat in Boots”.

### Что отправлять на проверку

Загрузите в тренажёр код программы без функции  `main`. Функция  `main`, если она будет загружена в тренажёр, будет заменена на версию из тренажёра.

### Как будет тестироваться ваш код

Функции  `GetSortedCats`  и  `PrintCatPointerValues`  будут протестированы кодом, подобным тому, что сейчас находится в функции  `main`.

### Подсказка

Чтобы получить отсортированное представление, создайте вектор указателей, ссылающихся на элементы оригинального контейнера кошек. Затем отсортируйте этот вектор как нужно. Программа должна сортировать указатели, сравнивая их значения, а не их адреса. Пример:

```cpp
#include <algorithm>
#include <cassert>
#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> items = {5, 2, 3, 4};
    vector<const int*> item_pointers;
    // Перебирать элементы вектора здесь следует по константной ссылке,
    // а не по значению.
    // В противном случае item_pointers будут хранить адреса объектов,
    // область видимости которых ограничена телом цикла
    for (const int& item : items) {
        item_pointers.push_back(&item);
    }

    // сортируем указатели в порядке убывания чисел, на которые они ссылаются.
    sort(item_pointers.begin(), item_pointers.end(), [](const int* lhs, const int* rhs) {
        // Чтобы сравнить значения, надо разыменовать указатели
        return *lhs > *rhs;
    });

    for (const int* item_ptr : item_pointers) {
        cout << *item_ptr << ", "s;
    }
}
```

</details>
