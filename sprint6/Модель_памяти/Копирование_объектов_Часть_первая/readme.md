<details>
<summary>Теория:</summary>

# Копирование объектов. Часть первая

В своих предыдущих программах вы, сами того не подозревая, хранили данные в динамической памяти, когда использовали строки и контейнеры  `vector`,  `map`  и  `set`. Эти стандартные классы размещают элементы в куче, а пользователю предоставляют простые и удобные операции вроде вставки и удаления элементов. Благодаря им вы концентрируетесь на прикладных задачах вроде поисковой системы и не отвлекаетесь на преодоление трудностей, которые возникают при работе с динамической памятью.

Когда дело касается объектов, хранящих данные в динамической памяти, многие привычные вещи вроде копирования становятся сложнее в реализации. Вспомним класс «Осьминог» из предыдущего урока.

![1.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint6/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8/%D0%9A%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2_%D0%A7%D0%B0%D1%81%D1%82%D1%8C_%D0%BF%D0%B5%D1%80%D0%B2%D0%B0%D1%8F/img/1.png?raw=true)


_Представление экземпляра класса  `Octopus`  в памяти_

В классе «Осьминог»‎ задача искусственно усложнена тем, что в векторе  `tentacles_`  не сами щупальца, а указатели на них. Это сделано намеренно. Так вы увидите трудности, с которыми сталкиваются программисты классов, работающих с динамической памятью.

Чтобы устранить утечки памяти, потребовалось не только добавить деструктор, удаляющий щупальца осьминога, но и обработать возможное исключение  `bad_alloc`  в конструкторе класса. Однако в классе  `Octopus`  осталась ошибка, которая может проявлять себя очень странно. Создадим в программе ещё одного осьминога, проинициализировав его значением первого:

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;

// Щупальце
class Tentacle {
public:
    explicit Tentacle(int id)
        : id_(id) {
    }

    int GetId() const {
        return id_;
    }

private:
    int id_ = 0;
};

// Осьминог
class Octopus {
public:
    Octopus() {
        Tentacle* t = nullptr;
        try {
            for (int i = 1; i <= 8; ++i) {
                t = new Tentacle(i);      // Может выбросить исключение bad_alloc
                tentacles_.push_back(t);  // Может выбросить исключение bad_alloc

                // Обнуляем указатель на щупальце, которое уже добавили в tentacles_,
                // чтобы не удалить его в обработчике catch повторно
                t = nullptr;
            }
        } catch (const bad_alloc&) {
            // Удаляем щупальца, которые успели попасть в контейнер tentacles_
            Cleanup();
            // Удаляем щупальце, которое создали, но не добавили в tentacles_
            delete t;
            // Конструктор не смог создать осьминога с восемью щупальцами,
            // поэтому выбрасываем исключение, чтобы сообщить вызывающему коду об ошибке
            // throw без параметров внутри catch выполняет ПЕРЕВЫБРОС пойманного исключения
            throw;
        }
    }

    const Tentacle& GetTentacle(int index) const {
        if (index < 0 || static_cast<size_t>(index) >= tentacles_.size()) {
            throw out_of_range("Invalid tentacle index"s);
        }
        // Чтобы превратить указатель в ссылку, разыменовываем его
        return *tentacles_[index];
    }

    ~Octopus() {
        // Осьминог владеет объектами в динамической памяти (щупальца),
        // которые должны быть удалены при его разрушении.
        // Деструктор - лучшее место, чтобы прибраться за собой.
        Cleanup();
    }

private:
    void Cleanup() {
        // Удаляем щупальца осьминога из динамической памяти
        for (Tentacle* t : tentacles_) {
            delete t;
        }
        // Очищаем массив указателей на щупальца
        tentacles_.clear();
    }

    // Вектор хранит указатели на щупальца. Сами объекты щупалец находятся в куче
    vector<Tentacle*> tentacles_;
};

int main() {
    {
        Octopus octopus;
        // Мы просто хотели ещё одного осьминога
        Octopus octopus1 = octopus;
        // Всё было хорошо и не предвещало беды...
        // ... до этого момента
    }
    cout << "Congratulations. Everything is OK!"s << endl;
}

```

Скопируйте код в свою IDE и запустите. В зависимости от настроек компилятора и ОС программа может вести себя по-разному. Например, так:

```
Segmentation fault

```

Или не вывести ничего:

Внесите изменения в функцию  `main`  и снова запустите программу:

```cpp
int main() {
    {
        Octopus octopus;
        // Мы просто хотели ещё одного осьминога
        Octopus octopus1 = octopus;
        cout << "Tentacle id="s << octopus1.GetTentacle(3).GetId() << endl;
    }
    cout << "OK"s << endl;
}

```

Возможный и ожидаемый вывод программы:

```
Tentacle id=4
OK

```

Но вывод может быть другим:

```
Tentacle id=4

```

Ситуацию, которая возникает в программе, называется «**неопределённое поведение**». То есть программа может вести себя как угодно: упасть, выдать ожидаемый результат или отправить в прошлое Терминатора, чтобы убить Сару Коннор. Но сейчас нас интересует не то, что программа может сделать, а причины, которые к этому привели.

Данную программу от ранее работавшей отличает создание копии осьминога:

```cpp
int main() {
    // Оригинальный осьминог
    Octopus octopus;
    // Копия первого осьминога
    Octopus octopus1 = octopus;
}

```

Первый осьминог инициализируется конструктором по умолчанию. Для инициализации второго осьминога использован копирующий конструктор. Его ещё называют конструктором копирования.

Копирующий конструктор создаёт новый объект на основе существующего. В качестве своего параметра этот конструктор принимает константную ссылку на объект того же типа:

```cpp
#include <string>

using namespace std;

class Object {
public:
    // Явно заданный конструктор копирования.
    // Ожидается, что копия будет идентична оригиналу,
    // поэтому поля копии инициализируем значением полей оригинала
    Object(const Object& other)
        : id_(other.id_)
        , name_(other.name_) {
    }

    // ...

private:
    int id_;
    string name_;
};

```

Вызов копирующего конструктора может быть явным, как у нашего осьминога, и неявным — например, при передаче параметра в функцию по значению или при возврате объекта из функции:

```cpp
void PlayWithOctopus(Octopus o) {
    cout << "tentacle:"s << o.GetTentacle(1).GetId() << endl;
}

int main() {
    Octopus o1;

    // В функцию PlayWithOctopus будет неявно передана копия объекта o1
    PlayWithOctopus(o1);
    cout << "OK"s << endl;
}

```

Компилятор может сгенерировать не только конструктор по умолчанию, но и копирующий конструктор. В этом случае для инициализации каждого поля объекта будет вызван его копирующий конструктор. В классе  `Octopus`  компилятор сгенерирует конструктор копирования, который создаст копию массива указателей на щупальца осьминога:

```cpp
#include <vector>

using namespace std;

// Щупальце
class Tentacle {
    // ...
};

// Осьминог
class Octopus {
public:
    // ...

    // Сгенерированный компилятором конструктор копирования
    // копирует массив указателей на щупальца
    Octopus(const Octopus& other)
        : tentacles_(tentacles) {
    }

    // ...

private:
    // ...

    // Вектор хранит указатели на щупальца. Сами объекты щупалец находятся в куче
    vector<Tentacle*> tentacles_;
};

```

Получим ситуацию, изображённую на этом рисунке:

![2.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint6/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8/%D0%9A%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2_%D0%A7%D0%B0%D1%81%D1%82%D1%8C_%D0%BF%D0%B5%D1%80%D0%B2%D0%B0%D1%8F/img/2.png?raw=true)

_Копия осьминога будет ссылаться на те же щупальца, что и оригинал_

Когда на один объект ссылаются несколько указателей — это нормально.

![3.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint6/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8/%D0%9A%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2_%D0%A7%D0%B0%D1%81%D1%82%D1%8C_%D0%BF%D0%B5%D1%80%D0%B2%D0%B0%D1%8F/img/3.png?raw=true)

Проблемы начинаются при выходе из блока, где объявлены переменные  `octopus`  и  `octopus1`. Сначала будет вызван деструктор  `octopus1`. Он удалит щупальца осьминога:

![4.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint6/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8/%D0%9A%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2_%D0%A7%D0%B0%D1%81%D1%82%D1%8C_%D0%BF%D0%B5%D1%80%D0%B2%D0%B0%D1%8F/img/4.png?raw=true)

_Деструктор  `octopus1`  удалит щупальца осьминога_

После удаления  `octopus1`  указатели, которые хранятся в массиве щупалец осьминога  `octopus`, станут невалидными — они более не ссылаются на существующие объекты. Такие указатели нельзя использовать для доступа к объекту. Нельзя даже вызвать операцию  `delete`. Все эти действия приведут к неопределённому поведению при удалении осьминога  `octopus`: в своём деструкторе он передаст в оператор  `delete`  невалидный указатель.

Вы познакомились с копирующим конструктором. Он инициализирует экземпляр класса, копируя уже имеющийся. Этот конструктор принимает константную ссылку на копируемый объект. Всякий раз, когда в программе явно или неявно создаётся копия существующего объекта, используется копирующий конструктор.

Сгенерированный компилятором конструктор копирования создаёт копию объекта, копируя все поля оригинала. Это поведение хорошо работает для классов и структур, хранящих объекты-значения, но плохо для копирования классов, которые содержат данные в динамической памяти. В нашем случае проблема возникла при копировании осьминога. Копия осьминога должна иметь собственный набор щупалец, а не пользоваться щупальцами оригинала.

Когда сгенерированный компилятором конструктор копирования не подходит, вы можете написать его вручную, реализовав желаемую семантику копирования объектов. Этим вы займётесь в следующих уроках. А в задании этого урока вам предстоит поэкспериментировать с неопределённым поведением.

</details>

<details>
<summary>Задание:</summary>

## Задание

Проверьте неопределённое поведение при копировании осьминогов в действии. Напишите функцию  `main`: создайте в ней осьминога и несколько его копий.

Конкретных требований в этой задаче нет. Что именно сделать с классом  `Octopus`, зависит только от вашего любопытства и полёта фантазии. После того, как поэкспериментируете вдоволь, нажимайте кнопку «Проверить», чтобы перейти к следующему уроку. Тесты в этой задаче тривиальные — они проверят только, что код можно скомпилировать.

### Что отправлять на проверку

Поэкспериментируйте с неопределённым поведением. После того, как удовлетворите своё любопытство, нажимайте «Проверить», чтобы перейти к следующему уроку.

### Как будет тестироваться ваш код

Решение проверяться не будет. Главное — не допускайте синтаксических ошибок.

### Подсказка

Создайте в функции  `main`  осьминога и несколько его копий. Для закрепления эффекта попробуйте проделать эти действия в цикле.

</details>
