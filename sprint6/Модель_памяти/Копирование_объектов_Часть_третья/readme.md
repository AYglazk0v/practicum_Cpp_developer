<details>
<summary>Теория:</summary>

# Копирование объектов. Часть третья

Вы создали свой первый умный указатель  `ScopedPtr`, который позволил сохранить объект в динамической памяти и автоматически контролировать время его жизни. У  `ScopedPtr`  есть и другие полезные свойства:

-   Исключает неинициализированное состояние. Он либо пустой, либо хранит адрес существующего объекта;
-   Запрещает копирование указателя. Тем самым исключает ситуацию, когда два указателя одновременно владеют одним объектом;
-   Вместо неопределённого поведения при разыменовании нулевого указателя  `ScopedPtr`  выбрасывает исключение  `logic_error`, которое можно поймать и обработать приложением.

Эти свойства указателя позволяют сделать управление объектами в динамической памяти проще. Вместо такого:

```cpp
int main() {
    vector<Object*> objects;
    Object* ptr = nullptr;
    try {
        for (int i = 0; i < 5; ++i) {
            ptr = new Object();
            objects.push_back(ptr);
            // Обнуляем ptr (этот указатель уже скопирован в objects)
            ptr = nullptr;
        }
    } catch (...) {
        delete ptr;
    }
    // Удаляем объекты из массива указателей
    for (Object* obj_ptr : objects) {
        delete obj_ptr;
    }
}

```

Можно написать лаконичнее:

```cpp
int main() {
    vector<Object*> objects;
    try {
        for (int i = 0; i < 5; ++i) {
            // Пока указатель не добавлен в контейнер objects, им владеет умный указатель
            ScopedPtr<Object> ptr(new Object());
            objects.push_back(ptr.GetRawPtr());

            // Вызываем Release, чтобы указатель не удалил объект, уже 
            // вставленный в вектор.
            ptr.Release();
        }
    } catch (...) {
    }
    for (Object* obj_ptr : objects) {
        delete obj_ptr;
    }
}

```

Тем не менее удалять объекты, на которые ссылаются указатели внутри вектора, всё ещё приходится вручную. Чтобы автоматизировать процесс, разработаем класс-обёртку  `PtrVector`  — вектор указателей. Он автоматически удаляет объекты в своём деструкторе. Код станет ещё проще:

```cpp
int main() {
    PtrVector<Object> objects;
    for (int i = 0; i < 3; ++i) {
        ScopedPtr<Object> ptr(new Object());
        objects.GetItems().push_back(ptr.GetRawPtr());
        ptr.Release();
    }

    cout << "PtrVector copy has been destroyed"s << endl;

    // Деструктор PtrVector автоматически удалит объекты, на которые
    // ссылаются хранящиеся внутри него указатели
}

```

Также  `PtrVector`  будет допускать копирование:

```cpp
PtrVector<Object> objects;

// ...

PtrVector<Object> objects_copy(objects);

```

Во время этого он создаст копии всех объектов, указатели на которые содержатся в  `objects`.

</details>

<details>
<summary>Задание 1:</summary>

## Задание 1

Разработайте шаблонный класс  `PtrVector`, оборачивающий вектор указателей. Объекты, на которые ссылаются эти указатели, должны размещаться в динамической памяти. В деструкторе  `PtrVector`  должен удалить объекты по хранящимся в нём указателям. Данные он размещает в контейнере  `vector`.

Конструктор копирования  `PtrVector`  должен копировать объекты исходного вектора. При этом нулевые указатели исходного вектора остаются нулевыми в векторе-копии.

______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

_Исходный PtrVector и его копия_

### Ограничения

Сохраните сигнатуры всех публичных методов класса  `PtrVector`  неизменными, чтобы код скомпилировался без ошибок.

### Пример

Пример использования дан в заготовке решения.

### Что отправлять на проверку

В решении должна быть реализация  `PtrVector`  со всеми методами и  `#include`-директивы. Функция  `main`  учитываться не будет.

### Как будет тестироваться ваш код

Размещаемые во внутреннем векторе указатели будут ссылаться на объекты, которые созданы в куче с применением операции  `new`  либо равны  `nullptr`.

### Подсказка

-   В деструкторе  `PtrVector`  примените операцию  `delete`  к каждому указателю внутри  `items_`.
-   Обработку исключений в коде копирующего конструктора можно упростить: используйте метод  `reserve`  и зарезервируйте в векторе место для хранения нужного количества щупалец. Тогда метод  `push_back`  не будет выбрасывать исключений.

</details>

<details>
<summary>Задание 2:</summary>

## Задание 2

Для съёмок блокбастера «Атака октоклонов» нужно изготовить 1000 копий осьминогов на основе имеющегося осьминога-прототипа.

В классе  `Octopus`  не задан пользовательский конструктор копирования. Копирующий конструктор, сгенерированный компилятором, копирует осьминогов некорректно: несколько осьминогов используют щупальца прототипа. Это приводит к неопределённому поведению.

Реализуйте следующий функционал:

-   Корректное клонирование осьминогов, при котором копия будет иметь свой набор щупалец, а не пользоваться щупальцами оригинала. Щупальца копии осьминога должны прицепляться к тем же щупальцам, что и оригинал.
-   Метод  `AddTentacle`  для добавления новых щупалец. Добавление должно сохранять адрес размещения существующих щупалец в памяти.  `id`  щупальца должен быть равен текущему количеству щупалец, увеличенному на 1.

Проверки, которые есть в функции  `main`, упростят разработку.

### Ограничения

Гарантируется, что количество щупалец, передаваемое в параметризованный конструктор класса  `Octopus`, неотрицательное. Проверять их количество в конструкторе необязательно. Максимальное количество щупалец, которое будет иметь осьминог, не превысит несколько десятков.

### Что отправлять на проверку

Решение должно включать исходный код класса  `Octopus`  и используемых им классов, а также нужные для компиляции директивы  `#include`. Функция  `main`  не учитывается.

### Как будет тестироваться ваш код

Класс  `Octopus`  будет протестирован кодом, подобным представленному в функции  `main`  из заготовки решения. Сохраните сигнатуры всех публичных методов классов  `Octopus`  и  `Tentacle`  неизменными, чтобы код скомпилировался без ошибок.

### Подсказка

-   Используйте классы  `ScopedPtr`  и  `PtrVector`. С ними класс  `Octopus`  станет заметно проще.
-   Когда щупальца хранятся внутри  `PtrVector`, создавать собственный конструктор копирования и деструктор для класса  `Octopus`  не придётся — конструктор копирования  `PtrVector`  корректно скопирует щупальца, а деструктор удалит их.

</details>
