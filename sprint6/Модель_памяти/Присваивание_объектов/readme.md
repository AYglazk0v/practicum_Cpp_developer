<details>
<summary>Теория:</summary>

# Присваивание объектов

В прошлых уроках вы научились копировать объекты, содержащие указатели на подобъекты в динамической памяти. Вы разработали умный указатель  `ScopedPtr`, который реализует семантику владения объектом в динамической памяти, и класс  `PtrVector`, автоматизирующий удаление и копирование объектов внутри вектора указателей. Так вы сделали копирование осьминогов не только надёжным, но и простым. В реальных задачах умные указатели и «‎обёртки»‎ тоже упрощают написание надёжного кода.

> Надёжные дома создаются из качественных кирпичей.

В этом уроке вы научитесь правильно реализовывать присваивание объектов. Присваивание — одна из специальных операций C++. Для пользовательских типов компилятор может реализовать её автоматически. Поэтому вам не приходилось беспокоиться о ней, когда вы присваивали один объект другому:

```cpp
#include <cassert>
#include <string>

using namespace std;

struct Cat {
    string name;
    int age = 0;
};

int main() {
    Cat cat1{"Tom"s, 3};
    Cat cat2;

    // Сгенерированный компилятором метод operator= выполнит 
    // присваивание соответствующих полей класса Cat.
    cat2 = cat1;

    assert(cat1.name == cat2.name);
    assert(cat1.age == cat2.age);
}

```

Операция  `=`, которую сгенерировал компилятор, присваивает значения полей одного объекта соответствующим полям другого. В большинстве случаев это именно то, что нужно!

Но, как вы уже знаете, привычные вещи становятся труднее в реализации, когда объект владеет другими объектами в динамической памяти или иными ресурсами.

В классе  `Octopus`  сгенерированная операция  `=`  присвоит массив щупалец одного осьминога другому:

```cpp
int main() {
    {
        Octopus octopus1(3);
        octopus.GetTentacle(1).LinkTo(octopus.GetTentacle(2));
        Octopus octopus2;

        octopus2 = octopus1;
        // Этот assert выстрелит, так как операция присваивания присвоит массив 
        // указателей на щупальца первого осьминога второму, и осьминоги будут 
        // использовать один и тот же набор щупалец.
        assert(&octopus2.GetTentacle(1) != &octopus1.GetTentacle(1));
        assert(octopus2.GetTentacle(1).GetLinkedTentacle() == &octopus1.GetTentacle(2));

        // После присваивания оба осьминога будут ссылаться на одни и те же щупальца

        // Деструктор octopus2 удалит щупальца, на которые ссылается octopus1,
        // и все указатели octopus1 станут невалидными.

        // Деструктор octopus1 выполнит удаление щупальцев с невалидными указателями,
        // что приведёт к неопределёному поведению.
    }
    cout << "OK"s << endl;
}

```

В результате оба осьминога будут использовать одни и те же объекты щупалец в динамической памяти.

______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

Программа вновь поведёт себя непредсказуемо.

Когда у класса с пользовательским конструктором копирования используется неявно сгенерированная операция присваивания, компилятор может об этом предупредить:

```
prog.cc:162:20: warning: implicitly-declared 'Octopus& Octopus::operator=(const Octopus&)' is deprecated [-Wdeprecated-copy]
  162 |         octopus1 = octopus;
      |                    ^~~~~~~
prog.cc:125:5: note: because 'Octopus' has user-provided 'Octopus::Octopus(const Octopus&)'
  125 |     Octopus(const Octopus& other) {
      |     ^~~~~~~

```

Чтобы решить проблему, переопределите эту операцию и реализуйте в ней присваивание значений объектов, а не указателей.

В С++ операцию присваивания можно переопределить только внутри класса в виде метода с именем  `operator=`. Левым аргументом операции присваивания выступает текущий экземпляр класса, а правый аргумент передаётся через её единственный параметр. Тип правого аргумента операции может быть любым, а самих операций присваивания может быть определено несколько. Как правило, операция присваивания возвращает ссылку на свой левый аргумент. Это позволяет использовать результат операции в составе выражений, например  `x = y = z`.

В С++ действует эмпирическое «Правило трёх». Если класс или структура объявляют один из следующих методов, скорее всего, они должны объявить все три:

-   деструктор,
-   конструктор копирования,
-   операция присваивания.

Эти особые функции класса может сгенерировать компилятор. Если программист переопределил одну из них, значит, сгенерированная компилятором версия не удовлетворяет потребностям класса в одном случае, и, вероятно, не удовлетворит в остальных.

Для структуры  `Cat`  операция присваивания, аналогичная сгенерированному компилятором, выглядит так:

```cpp
struct Cat {
    string name;
    int age = 0;

    Cat& operator=(const Cat& rhs) {
        // оптимизация самоприсваивания
        if (this != &rhs) {
            name = rhs.name;
            age = rhs.age;
        }

        // this - указатель на текущий экземпляр класса.
        // В операции присваивания он ссылается на левый аргумент операции.
        return *this; // возвращаем ссылку на левый аргумент операции присваивания
    }
};

```

Обратите внимание на защиту от присваивания объекта самому себе. Это идиоматичный способ избежать лишних действий и некорректной работы при самоприсваивании объекта.

Без этой проверки в структуре  `Cat`  самоприсваивание приведёт в худшем случае к замедлению программы. А вот для класса  `PtrVector`  может привести к некорректной работе:

```cpp
#include <cassert>
#include <vector>

using namespace std;

template <typename T>
class PtrVector {
public:
    ...
    // Внутри шаблона класса можно ссылаться на собственный тип, используя краткую запись:
    // PtrVector вместо PtrVector<T>

    PtrVector& operator=(const PtrVector& rhs) {
        // При присваивании PtrVector самому себе произойдёт удаление не только
        // своих элементов, но и элементов rhs.
        for (auto p : items_) {
            delete p;
        }
        items_.clear();

        items_.reserve(rhs.items_.size());
        for (T* p : rhs.items_) {
            items_.push_back(p ? new T(*p) : nullptr);
        }
        return *this;
    }
private:
    vector<T*> items_;
};

int main() {
    PtrVector<int> v;
    v.GetItems().push_back(new int(1));
    v.GetItems().push_back(new int(2));

    v = v;

    // Этот assert выстрелит, так как элементы v удалятся при самоприсваивании
    assert(v.GetItems().size() == 2);
}

```

Другая проблема: если при копировании элементов операция  `new`  выбросит исключение,  `PtrVector`  окажется в промежуточном состоянии. Прежнее содержимое потеряется, а новые элементы до конца скопированы не будут.

Удобнее, когда методы класса обеспечивают строгую гарантию безопасности исключений: операция либо завершается успешно, либо происходит выбрасывание исключения и состояние объекта останется прежним. Такая семантика выполнения также называется “commit or rollback”.

Обеспечить строгую гарантию безопасности исключений в пользовательской операции присваивания можно, применив идиому “copy-and-swap”. В ней операция присваивания переиспользует функционал конструктора копирования.

-   Чтобы создать временную копию присваиваемого объекта, примените конструктор копирования. Если во время создания копии будет выброшено исключение, оно повлияет на временную копию, а не на текущий экземпляр класса.
-   Обменяйте текущее состояние объекта и временной копии. Эта операция не должна выбрасывать исключений. При выходе из операции присваивания прежнее состояние будет разрушено, а текущее состояние будет равно состоянию правого аргумента.

Применим copy-and-swap и реализуем операцию присваивания:

```cpp
class Object {
public:
    // копирующий конструктор
    Object(const Object& other);

    // копирующая операция присваивания
    Object& operator=(const Object& rhs) {
        if (this != &rhs) {
            // Реализация операции присваивания с помощью идиомы Copy-and-swap.
            // Если исключение будет выброшено, то на текущий объект оно не повлияет.
            auto rhs_copy(rhs);

            // rhs_copy содержит копию правого аргумента.
            // Обмениваемся с ним данными.
            swap(rhs_copy);

            // Теперь текущий объект содержит копию правого аргумента,
            // а rhs_copy - прежнее состояние текущего объекта, которое при выходе
            // из блока будет разрушено.
        }

        return *this;
    }

    // обменивает состояние текущего объекта с other без выбрасывания исключений
    void swap(Object& other) noexcept;

    ~Object();
};
```

</details>

<details>
<summary>Задание 1:</summary>

## Задание 1

Реализуйте операцию присваивания в классе  `PtrVector`. Операция должна обеспечивать строгую гарантию безопасности исключений. Если в процессе присваивания будет выброшено исключение,  `PtrVector`  должен остаться в состоянии, в котором он был до выполнения этой операции.

В заготовке кода вы видите тесты, которые упрощают проверку задачи. Также там приведена допустимая реализация  `PtrVector`  из предыдущей задачи. Вы можете заменить её на свою.

### Ограничения

Сохраните сигнатуры всех публичных методов класса  `PtrVector`  неизменными, чтобы код скомпилировался без ошибок.

Ваши реализации методов должны обеспечивать строгую гарантию исключений.

### Что отправлять на проверку

В решении должна быть реализация  `PtrVector`  со всеми методами, включая  `operator=`, а также  `#include`-директивы. Функция  `main`  учитываться не будет.

### Как будет тестироваться ваш код

Указатели, которые передаются на вход класса  `PtrVector`  , ссылаются на объект, созданный в куче с использованием операции  `new`, либо равны  `nullptr`.

### Подсказка

-   Чтобы написать надёжную операцию присваивания, используйте идиому copy-and-swap.
-   Пригодится метод  `swap`  класса  `vector`. Этот метод обменивает содержимое двух контейнеров за время O(1) и не выбрасывает исключений.

</details>

<details>
<summary>Задание 2:</summary>

## Задание 2

Добавьте реализацию класса`Octopus`  с присваиванием, обеспечивающим строгую гарантию безопасности исключений. Проверьте, что класс работает корректно, используя следующую функцию  `main`:

```cpp
int main() {
    // Проверка присваивания осьминогов
    {
        Octopus octopus1(3);

        // Настраиваем состояние исходного осьминога
        octopus1.GetTentacle(2).LinkTo(octopus1.GetTentacle(1));

        // До присваивания octopus2 имеет своё собственное состояние
        Octopus octopus2(10);

        octopus2 = octopus1;

        // После присваивания осьминогов щупальца копии имеют то же состояние,
        // что и щупальца присваиваемого объекта
        assert(octopus2.GetTentacleCount() == octopus1.GetTentacleCount());
        for (int i = 0; i < octopus2.GetTentacleCount(); ++i) {
            auto& tentacle1 = octopus1.GetTentacle(i);
            auto& tentacle2 = octopus2.GetTentacle(i);
            assert(&tentacle2 != &tentacle1);
            assert(tentacle2.GetId() == tentacle1.GetId());
            assert(tentacle2.GetLinkedTentacle() == tentacle1.GetLinkedTentacle());
        }
    }

    // Проверка самоприсваивания осьминогов
    {
        Octopus octopus(3);

        // Настраиваем состояние осьминога
        octopus.GetTentacle(0).LinkTo(octopus.GetTentacle(1));

        vector<pair<Tentacle*, Tentacle*>> tentacles;
        // Сохраняем информацию о щупальцах осьминога и его копии
        for (int i = 0; i < octopus.GetTentacleCount(); ++i) {
            tentacles.push_back({&octopus.GetTentacle(i), octopus.GetTentacle(i).GetLinkedTentacle()});
        }

        // Выполняем самоприсваивание
        octopus = octopus;

        // После самоприсваивания состояние осьминога не должно измениться
        assert(octopus.GetTentacleCount() == static_cast<int>(tentacles.size()));
        for (int i = 0; i < octopus.GetTentacleCount(); ++i) {
            auto& tentacle_with_link = tentacles.at(i);
            assert(&octopus.GetTentacle(i) == tentacle_with_link.first);
            assert(octopus.GetTentacle(i).GetLinkedTentacle() == tentacle_with_link.second);
        }
    }
}

```

Классы  `Octopus`  и  `Tentacle`  возьмите из своего решения задачи предыдущего урока.

### Ограничения

Сохраните сигнатуры всех публичных методов классов  `Octopus`  и  `Tentacle`  неизменными, чтобы код скомпилировался без ошибок.

### Что отправлять на проверку

Решение должно включать исходный код класса  `Octopus`  и используемых им классов, а также необходимые для компиляции директивы  `#include`. Функция  `main`  учитываться не будет.

### Как будет тестироваться ваш код

Гарантируется, что количество щупалец, передаваемое в параметризованный конструктор класса  `Octopus`, неотрицательное. Проверять их количество в конструкторе необязательно. Максимальное количество щупалец, которое будет иметь осьминог, не превышает нескольких десятков.

### Подсказка

Используйте обновлённый класс  `PtrVector`, где корректно реализована операция присваивания. В класс  `Octopus`  вносить изменения не нужно. Помните: надёжный дом создаётся из надёжных кирпичей.

</details>
