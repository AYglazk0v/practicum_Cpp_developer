
<details>
<summary>Теория:</summary>

# Поиск в отсортированном векторе, словаре и множестве

В этом уроке заполним таблицу полностью: разберём остальные методы поиска в отсортированном векторе, в словаре и множестве.

### Отсортированный вектор

Помимо функции  `binary_search`, для поиска элементов в отсортированном векторе применяют функции  `lower_bound`,  `upper_bound`  и  `equal_range`.

-   [upper_bound](https://ru.cppreference.com/w/cpp/algorithm/upper_bound)

Эта функция вернёт итератор на элемент, больший искомого. Допустим, у нас есть отсортированный вектор:

```cpp
vector<int> v = {1, 1, 2, 3, 4, 4, 4, 5, 6};
auto it = upper_bound(v.begin(), v.end(), 4);
cout << "Номер позиции в векторе "s << distance(v.begin(), it) << endl;
cout << "Значение элемента "s << *it << endl;

```

Будем искать первый элемент больше четвёрки. Здесь это пятёрка. Именно на позицию пятёрки будет указывать итератор, возвращённый функцией  `upper_bound`:

1 1 2 3 4 4 4  **5**  6

Программа выведет:

```
Номер позиции в векторе 7
Значение элемента 5

```

-   [lower_bound](https://ru.cppreference.com/w/cpp/algorithm/lower_bound)

Эта функция вернёт итератор на элемент, больший или равный искомому. Возьмём тот же пример и будем искать первый элемент, больший или равный четвёрке:

```cpp
vector<int> v = {1, 1, 2, 3, 4, 4, 4, 5, 6};
auto it = lower_bound(v.begin(), v.end(), 4);
cout << "Номер позиции в векторе "s << distance(v.begin(), it) << endl;
cout << "Значение элемента "s << *it << endl;

```

Получим итератор на позицию первой четвёрки в данном векторе:

1 1 2 3  **4**  4 4 5 6

Программа выведет:

```
Номер позиции в векторе 4
Значение элемента 4

```

-   [equal_range](https://ru.cppreference.com/w/cpp/algorithm/equal_range)

Эта функция вернёт пару итераторов. Первый из них — результат  `lower_bound`, а второй — результат  `upper_bound`. Казалось бы, зачем нам функция, которая дублирует работу двух других. На самом деле поиск двух результатов так реализуется эффективнее, чем если бы сначала была вызвана функция  `lower_bound`, а потом  `upper_bound`. Искать пару сразу проще, чем каждый элемент по отдельности. Такой приём вы уже видели на примере  `minmax_element`.

```cpp
vector<int> v = {1, 1, 2, 3, 4, 4, 4, 5, 6};
auto [lower, upper] = equal_range(v.begin(), v.end(), 4);
cout << "Номер начальной позиции в векторе "s << distance(v.begin(), lower) << endl;
cout << "Номер конечной позиции в векторе "s << distance(v.begin(), upper) << endl;

```

Пара итераторов в примере будет указывать на диапазон:

1 1 2 3  **4 4 4 5**  6

Концепция полуинтервала продолжает работать и здесь, поэтому внимательно посмотрим на пятёрку. Мы получили полуинтервал, в рамках которого все элементы равны данному. Результат  `upper_bound`  играет роль конца диапазона. То есть пятёрка в диапазон не входит, но станет его окончанием. Программа выведет:

```
Номер начальной позиции в векторе 4
Номер конечной позиции в векторе 7

```

Если бы в векторе не оказалось четвёрок,  `lower_bound`  и  `upper_bound`  вместе указывали бы на пятёрку. Это было бы то самое место, куда четвёрку можно вставить без нарушения сортировки.

Чтобы определить количество элементов, равных данному, достаточно расстояния между итераторами, которые вернула  `equal_range`. А чтобы перебрать все нужные элементы, используют цикл от левой до правой границы найденного диапазона.

Обновим таблицу.

### Методы поиска

|**Что и как хотим найти? / Где ищем?**|**Неотсортированный вектор**|**Отсортированный вектор**|**Множество или словарь**|
|--|--|--|--|
|Проверка существования|Функция  `find`|Функция `binary_search`|
|Проверка существования и поиск первого подходящего элемента|Функция  `find`|Функция  `lower_bound`  и проверка найденного элемента на равенство искомому|
|Поиск первого элемента, большего или равного данному|Функция  `find_if`|Функция  `lower_bound`|
|Поиск первого элемента, большего данного|Функция  `find_if`|Функция  `upper_bound`|
|Подсчёт количества|Функция  `count`|Функция  `equal_range`  и расстояние между итераторами|
|Перебор по всем подходящим элементам|Функция  `find`  в цикле|Функция  `equal_range`  и цикл от левой до правой границы|

### Множества и словари

У множеств и словарей есть свои методы, одноимённые с функциями, которые мы уже разобрали. Эти методы работают эффективнее, чем функции, так как изначально знают, с каким контейнером имеют дело. Поиск организуется в соответствии с устройством конкретного контейнера. Но есть специфические моменты:

-   Проверить существование элемента во множестве или словаре можно, применив специальный метод  `contains`. Правда, он появится только в следующем стандарте языка — в С++20. Поэтому в нынешнем стандарте используют метод  `count`. Если элемент в контейнере есть, метод  `count`  вернёт 1, а если нет — 0.
-   Перебор всех подходящих элементов для множества и словаря не имеет значения, так как если элемент существует, он один — перебирать просто нечего.
-   То же можно сказать о подсчёте количества: результат всегда будет или 0, или 1.

Теперь сделаем финальную версию таблицы.

### Методы поиска


|**Что и как хотим найти? / Где ищем?**|**Неотсортированный вектор**|**Отсортированный вектор**|**Множество или словарь**|
|--|--|--|--|
|Проверка существования|Функция  `find`|Функция  `binary_search`|Метод  `contains`, метод  `count`|
|Проверка существования и поиск первого подходящего элемента|Функция  `find`|Функция  `lower_bound`  и проверка найденного элемента на равенство искомому|Метод  `find`|
|Поиск первого элемента, большего или равного данному|Функция  `find_if`|Функция  `lower_bound`|Метод  `lower_bound`|
|Поиск первого элемента, большего данного|Функция  `find_if`|Функция  `upper_bound`|Метод  `upper_bound`|
|Подсчёт количества|Функция  `count`|Функция  `equal_range`  и расстояние между итераторами|Метод  `count`|
|Перебор по всем подходящим элементам|Функция  `find`  в цикле|Функция  `equal_range`  и цикл от левой до правой границы|Метод  `find`|

</details>

<details>
<summary>Задание 1:</summary>

## Задание 1

Напишите функцию  `FindNearestElement`  для множества целых чисел  `numbers`  и данного числа  `border`. Она должна возвращать итератор на элемент множества, ближайший к  `border`. Если ближайших элементов несколько, верните итератор на наименьший из них. Если множество пустое, верните итератор на конец. Для поиска примените методы поиска по множеству. Они более эффективны, чем простой перебор элементов.

### Пример использования

```cpp
int main() {
    set<int> numbers = {1, 4, 6};
    cout << *FindNearestElement(numbers, 0) << " " << *FindNearestElement(numbers, 3) << " "
         << *FindNearestElement(numbers, 5) << " " << *FindNearestElement(numbers, 6) << " "
         << *FindNearestElement(numbers, 100) << endl;

    set<int> empty_set;

    cout << (FindNearestElement(empty_set, 8) == end(empty_set)) << endl;
    return 0;
}

```

### Пример вывода

```
1 4 4 6 6
1

```

### Как будет тестироваться ваш код

Помимо правильности работы кода, мы проверим его скорость. Выберите подходящий способ поиска для контейнера.

### Подсказка

Ближайшим элементом может оказаться элемент меньше, чем  `border`, сам  `border`  или элемент больше  `border`. Используйте алгоритм  `lower_bound`, чтобы найти позицию элемента, который будет не меньше, чем  `border`. Найденный элемент будет равным  `border`  или ближайшим с бó‎льшей стороны. Если возможно,  [сделайте шаг назад](https://ru.cppreference.com/w/cpp/iterator/prev)  и найдите ближайший элемент с меньшей стороны. Останется только сравнить, насколько они отстают от  `border`, и выбрать ближайший. Когда вы в начале контейнера, шагать назад не получится.

Используйте метод контейнера  `lower_bound`, а не общую функцию, чтобы ускорить свой код.

</details>

<details>
<summary>Задание 2:</summary>

## Задание 2

Напишите функцию  `FindStartsWith`, которая

-   принимает отсортированный набор строк в виде итераторов  `range_begin`,  `range_end`  и один символ  `prefix`;
-   возвращает полуинтервал [`range_begin`,  `range_end`) строк в виде пары итераторов. Эти строки начинаются с символа  `prefix`.

Если итоговый диапазон пуст, его границы должны указывать на место в контейнере, куда можно без нарушения порядка сортировки вставить любую строку, начинающуюся с символа  `prefix`  — подобно алгоритму  `equal_range`. Гарантируется, что строки состоят лишь из строчных латинских букв, а символ  `prefix`  — строчная латинская буква.

### Пример использования

```cpp
int main() {
    const vector<string> sorted_strings = {"moscow", "murmansk", "vologda"};

    const auto m_result = FindStartsWith(begin(sorted_strings), end(sorted_strings), 'm');
    for (auto it = m_result.first; it != m_result.second; ++it) {
        cout << *it << " ";
    }
    cout << endl;

    const auto p_result = FindStartsWith(begin(sorted_strings), end(sorted_strings), 'p');
    cout << (p_result.first - begin(sorted_strings)) << " " << (p_result.second - begin(sorted_strings)) << endl;

    const auto z_result = FindStartsWith(begin(sorted_strings), end(sorted_strings), 'z');
    cout << (z_result.first - begin(sorted_strings)) << " " << (z_result.second - begin(sorted_strings)) << endl;

    return 0;
}

```

### Пример вывода

```
moscow murmansk
2 2
3 3

```

### Подсказка

Символы, которые относятся к типу данных  `char`, можно складывать с числами. Вычитать из них числа тоже можно. Так вы получите следующие или предыдущие буквы в алфавитном порядке. Например, для строки  `s`  выражение  `-s[0]`  заменит её первую букву на предыдущую.

Выражение  `'a' + 1`  имеет тип  `int`. Поэтому может понадобиться привести его к типу  `char`, применив  `static_cast`.

</details>

<details>
<summary>Задание 3:</summary>

## Задание 3

Обобщим предыдущую задачу. Теперь префикс будет не одним символом типа  `char`, а строкой с любым количеством символов.

### Пример использования

```cpp
int main() {
    const vector<string> sorted_strings = {"moscow", "motovilikha", "murmansk"};

    const auto mo_result = FindStartsWith(begin(sorted_strings), end(sorted_strings), "mo");
    for (auto it = mo_result.first; it != mo_result.second; ++it) {
        cout << *it << " ";
    }
    cout << endl;

    const auto mt_result = FindStartsWith(begin(sorted_strings), end(sorted_strings), "mt");
    cout << (mt_result.first - begin(sorted_strings)) << " " << (mt_result.second - begin(sorted_strings)) << endl;

    const auto na_result = FindStartsWith(begin(sorted_strings), end(sorted_strings), "na");
    cout << (na_result.first - begin(sorted_strings)) << " " << (na_result.second - begin(sorted_strings)) << endl;

    return 0;
}

```

### Пример вывода

```
moscow motovilikha
2 2
3 3

```

### Подсказка

Эта задача аналогична предыдущей, но с одной тонкостью. Как составить ближайшую строку, которая будет больше  `prefix`? Просто увеличить на единицу последний символ.

</details>
