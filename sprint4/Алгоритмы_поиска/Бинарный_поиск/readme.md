<details>
<summary>Теория + тестирование:</summary>

# Бинарный поиск

В прошлом уроке вы освоили алгоритмы поиска в неотсортированном векторе, а в этом займётесь отсортированным вектором. Вектор и строка в данном случае эквивалентны.

Рассмотрим алгоритм, позволяющий проверить существование элемента в отсортированном векторе. В математике такой алгоритм называется двоичным или бинарным поиском. Предположим, перед нами отсортированный вектор чисел:

```
1 2 4 4 6 7 8 8 8 9 11

```

Попытаемся найти в этом векторе число девять:

-   Найдём средний элемент. Здесь это семь.
    
-   7 != 9, но при этом 7 < 9, а вектор отсортирован. Значит все элементы слева от семи нам не подходят, ведь они меньше семи, и девятки там точно нет:
    
    ```
    1 2 4 4 6 7 8 8 8 9 11
    
    ```
    
-   Найдём средний элемент части, расположенной справа от семёрки. Это последняя восьмёрка:
    
    ```
    8 8 8 9 11
    
    ```
    
-   8 != 9 и 8 < 9. Снова отбросим правую часть и продолжим поиск.
    
-   Найдём середину в оставшейся части. Там всего два элемента. В качестве середины можно взять элемент справа или слева.
    
-   Возьмём элемент слева и поймём: это именно то, что мы искали:
    
    ```
    9 11
    
    ```
    

Такой метод реализован в функции  [`binary_search`](https://ru.cppreference.com/w/cpp/algorithm/binary_search):

```cpp
template< class ForwardIt, class T >
bool binary_search( ForwardIt first, ForwardIt last, const T& value );

```

Функция  `binary_search`  принимает итераторы на начало и конец диапазона поиска, а также значение, которое мы ищем. После своей работы функция возвращает  `true`, если элемент найден и  `false`, если он отсутствует.

----------

Зная, как работает бинарный поиск, подумайте и ответьте на вопрос. Сколько примерно итераций нужно, чтобы найти элемент в отсортированном векторе из одного миллиона элементов?

-   Одной-двух итераций достаточно. Искать в отсортированном векторе — это легко и быстро!
    
-   Несколько десятков. Ведь каждый раз мы будем отсекать половину, где элемента точно нет.
    
-   Несколько тысяч. Бинарный поиск дает выигрыш примерно в 100 раз по сравнению с простым перебором.
    
-   Точно миллион. Не переберём весь вектор — не узнаем.Добавим новый пункт в сводную таблицу:
    

### Методы поиска

|**Что и как хотим найти? / Где ищем?**|**Неотсортированный вектор**|**Отсортированный вектор**|**Множество или словарь**|
|--|--|--|--|
|Проверка существования|Функция  `find`|Функция  `binary_search`|
|Проверка существования и поиск первого подходящего элемента|Функция  `find`|
|Поиск первого элемента, большего или равного данному|Функция  `find_if`|
|Поиск первого элемента, большего данного|Функция  `find_if`|
|Подсчёт количества|Функция  `count`|
|Перебор по всем подходящим элементам|Функция  `find`  в цикле|

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Зная, как работает бинарный поиск, подумайте и ответьте на вопрос. Сколько примерно итераций нужно, чтобы найти элемент в отсортированном векторе из одного миллиона элементов?

-   **(-)**  Одной-двух итераций достаточно. Искать в отсортированном векторе — это легко и быстро!
    
    -   Не так всё просто.
-   **(+)**  Несколько десятков. Ведь каждый раз мы будем отсекать половину, где элемента точно нет.
    
    -   Верно!
-   **(-)**  Несколько тысяч. Бинарный поиск дает выигрыш примерно в 100 раз по сравнению с простым перебором.
    
    -   Не так всё сложно.
-   **(-)**  Точно миллион. Не переберём весь вектор — не узнаем.
    
    -   Бинарный поиск работает иначе.

</details>
