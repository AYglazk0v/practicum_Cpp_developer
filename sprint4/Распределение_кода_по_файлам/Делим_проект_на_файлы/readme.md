<details>
<summary>Теория:</summary>

# Делим проект на файлы

Вы прошли путь воина. Узнали о препроцессинге, компиляции и компоновке. Вы можете различить заголовочный файл и файл с реализацией. Понимаете, что делать с шаблонами функций. Каждая ваша функция имеет только одно определение. Вы умеете создавать заголовочные файлы независимыми, как степной ветер. Вы думаете как компилятор. Вы думаете как пользователь. Вы думаете как настоящие программисты.

От маленького файла, который можно было охватить одним взглядом, вы выросли до многофайлового проекта, где каждый файл отвечает за свой фронт работ. Все вместе они выполняют общую задачу. Кирпичи посчитаны, стены покрашены, двери установлены, и даже полочки висят.

Чтобы двигаться дальше, договоримся больше не писать  `using namespace std`  в заголовочных файлах. Это выражение говорит компилятору: «Если встречаешь что-нибудь, чего не видишь в текущем контексте (функции, классе, файле), ищи это в библиотеке  `std`»‎. Заявляя такое, вынуждаем все файлы, которые включат этот файл, использовать  `std`. Представьте, что написали собственный вектор, — а вы сделаете это уже скоро. У вас есть:

-   vector.h;
-   main.cpp, куда будет включаться vector.h;
-   ещё один файл some_header.h.

При этом vector.h не будет содержать  `using namespace std`, а some_header.h будет.

```cpp
// main.cpp
#include "vector.h"
#include "some_header.h"

int main() {
    vector<int> my_vector;
    // код программы
}

```

Пока всё в порядке: ваш  `vector`  определён в этом файле. Но если забудете включить vector.h, компилятор об этом не скажет. В some_header.h содержится  `using namespace std`, и компилятор просто решит, что вектор, использующий  `main`, — это вектор библиотеки  `std`. Но ожидали вы совершенно другого. Поведение программы становится непредсказуемым. Чтобы избежать этого, в заголовочных файлах пишут так:

```cpp
std::vector<int> my_vector;

```

Вы уже знакомы с областями видимости.  `using namespace std`  тоже действует только в своей области видимости. Если объявить его глобально, он начинает действовать везде. Но можно поступать мудрее и определять  `using namespace std`  только в функции или в любом другом блоке. Если вам нужно  `using namespace std`  в заголовочном файле, сделайте это в небольшом блоке. Так вы ограничите область видимости. К файлам с реализацией это не относится. Они не включаются в другие файлы, и там смело можно писать  `using namespace std`.

И последнее. Если используете функцию  `abs`  в заголовочном файле, убедитесь, что вызываете её  `std::abs`. Иначе некоторые компиляторы могут решить, что вы хотите вызвать эту функцию для типа  `int`, и при её вызове аргументы округлятся.

Дело в том, что в глобальном пространстве имён может быть одноимённая функция  `abs`, которая принимает аргументы типа  `int`. Это сделано для совместимости с языком C. Чтобы использовать C++-вариант функции  `abs`, который понимает аргументы других типов, вызовите функцию  `std::abs`.

Примените свои знания в бою.

</details>

<details>
<summary>Задание:</summary>

## Задание

Это задание — итоговый проект четвёртого спринта. Вы будете сдавать его на проверку через репозиторий на GitHub.

В уроке «Очередь запросов» вы сделали задание и сохранили решение себе. Сейчас это решение вам понадобится.

Код вашей поисковой системы находится в одном файле. Разделите код на файлы, сохраняя функциональность. Каждый файл должен иметь понятное название и логически объединять в себе функции, классы и переменные.

### Подсказка

**Один из вариантов разделения:**

document.cpp

document.h

main.cpp

paginator.h

read_input_functions.cpp

read_input_functions.h

request_queue.cpp

request_queue.h

search_server.cpp

search_server.h

string_processing.cpp

string_processing.h

То, что пишется в объявлении метода класса слева (например explicit или static) в файле с реализацией писать не нужно. А то, что пишется справа (например, const), должно остаться на месте.

</details>
