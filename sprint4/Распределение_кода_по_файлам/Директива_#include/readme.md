<details>
<summary>Теория:</summary>

# Директива #include

Представьте, что вам нужно сделать ремонт. Квартира у вас небольшая, справится и один рукастый рабочий: поменяет сантехнику и проводку, положит плитку, покрасит стены. Но если нужно построить дом, гораздо удобнее позвать бригаду, где есть прораб, каменщик, сантехник и маляр. Каждый специализируется на своём участке работ. Так же и с проектами в программировании.

До сих пор вы писали только совсем маленькие программы. Они умеют делать что-нибудь небольшое, помещаются в один файл, их можно охватить одним взглядом. Но в реальном мире таких программ практически не бывает. Обычно они намного больше.

Вы, наверное, заметили, что чем больше кода, тем дольше работает компилятор — даже в маленьких программах. А теперь представьте, что у вас файл размером в миллионы строк, и кто-нибудь вносит в него небольшие изменения. Каждый раз этот файл пришлось бы компилировать заново! Время программиста дорого, нельзя позволять ему так долго пить кофе в ожидании компиляции.

Код нужно делить на файлы:

-   чтобы в нём было проще ориентироваться;
-   чтобы не перекомпилировать весь проект, а только тот файл, где произошло изменение.

Начинаем строить новый дом. Вы наняли замечательного строителя Тома, который может по размерам стены посчитать, сколько для неё нужно кирпичей.

Файл builder.h:

```cpp
class Builder {
public:
    double CalcBricksNeeded(double wall_width, double wall_height) const {
		    return wall_width * wall_height * 5;
	  }
};

```

Файл main.cpp:

```cpp
#include "builder.h"

int main() {
    Builder tom;
		double wall_height = 3, wall_width = 2;
    const auto num_of_bricks = tom.CalcBricksNeeded(wall_width, wall_height);
}

```

В прошлом уроке вы узнали, что компилятор проверяет файл строчку за строчкой. Кажется, в файле main.cpp нет информации о том, кто такой  `Builder`  и что он умеет build. Но это только на первый взгляд.

Чтобы рассмотреть файл получше, зайдём в консоль. Напишем в консоли команду  **g++ -E main.cpp**. Ключ -E просит компилятор показать, что происходит на первом этапе перевода файла на язык компьютера. Этих этапов несколько, к ним вернёмся в следующих уроках.

```cpp
class Builder {
public:
    double CalcBricksNeeded(double wall_width, double wall_height) const {
		    return wall_width * wall_height * 5;
	  }
};

int main() {
    Builder tom;
		double wall_height = 3, wall_width = 2;
    const auto num_of_bricks = tom.CalcBricksNeeded(wall_width, wall_height);
}

```

Директива  `#include`  просто заменена текстом самого файла builder.h. Это происходит перед тем, как компилятор начинает проверять код строчка за строчкой. Теперь у компилятора есть вся информация о строителе Томе и его способности к вычислению количества кирпичей.

Для включения файлов используют кавычки:

```cpp
#include "builder.h"

```

А для включения стандартных библиотек — скобки-уголки:

```cpp
#include <iostream>
```

</details>

<details>
<summary>Задание 1:</summary>

## Задание 1

При строительстве дома возводят стены. Теперь у вас есть отдельный класс  `Wall`. Посмотрите, как поменялся метод  `CalcBricksNeeded`  в классе  `Builder`. Внесите изменения в код. Пусть программа сообщает, сколько кирпичей нужно для стены 3,5 x 2,45 метра.

### Подсказка

Класс  `Builder`  ещё не знаком с классом  `Wall`. Для вывода результата на экран тоже нужен свой  `#include`. Обратите внимание на скобочки для названий включаемых файлов.

</details>

<details>
<summary>Задание 2:</summary>

## Задание 2

Теперь стены пора красить. Вызовите маляра Билла. Напишите класс  `Painter`, который сможет покрасить стены.

### Подсказка

Не забудьте добавить  `#include`. Используйте новый метод класса  `Wall`  , чтобы изменить цвет.

</details>
