<details>
<summary>Теория + тестирование:</summary>

# Механизм сборки многофайловых проектов

Разберёмся, как работает механизм сборки многофайловых проектов. Вы уже знаете, что этот процесс называется компиляцией. Компилятор — переводчик с языка С++ на язык компьютера. Процессор, который выполняет вычисления, понимает только простые команды. Он не знает, что такое класс или функция. Он умеет читать команды из памяти, перемещаться по ней, складывать и вычитать числа. Компилятор «переводит»‎ в три этапа.

### Этап 1. Препроцессинг

С этим этапом вы знакомы, хоть и не знали его название. Во время препроцессинга компилятор читает код как текст, не вникая в суть. Он проходит файл за файлом и обрабатывает так называемые директивы препроцессора. Пример директивы —  `#include`, которая просто подменяется текстом из другого файла. Основной признак директивы — знак #. По окончанию этого этапа у вас будут файлы с расширением .ii (или просто .i).

### Этап 2. Собственно компиляция

Есть неоднозначность в том, что весь процесс называется так же, как его отдельный этап. Но обычно всё понятно из контекста.

Задачи на этапе компиляции:

-   Проверить каждый файл на наличие ошибок в синтаксисе языка.
-   Проверить типы выражений, параметров, переменных и их соответствие друг другу. Простой пример такой проверки — ошибка компиляции, возникающая, когда вы пытаетесь передать параметр в функцию, которая не принимает параметры. Код не скомпилируется.
-   Оптимизация. Не всё, что вы пишете, станет инструкцией для процессора. Компилятор может что-нибудь убрать, чтобы избежать лишних действий. Например, вы создали переменную, но никогда её не используете. Компилятор это видит и может её просто проигнорировать. Или у вас есть условие, которое всегда выполняется. Так, вызовы функции  `Foo`  с точки зрения компилятора будут бесполезны, и он их оптимизирует:

```cpp
void Foo() {
	  bool x = true;
	  if (x) {
			  return;
		}
}

```

На этом этапе ваши файлы переводятся с языка С++ в команды для процессора. На выходе получаются объектные файлы с расширением .o.

### Этап 3. Компоновка

На этапе компиляции могло получиться несколько объектных файлов, но пока они не связаны в одну программу. Этим занимается компоновщик. Чтобы понять принцип работы компоновщика, представим каждый объектный файл как страну. У неё есть ресурс, который она может экспортировать. А другого ресурса ей не хватает, и она вынуждена его импортировать.

Предположим, у нас три объектных файла. Напишем их на псевдокоде, немного похожем на С++, но вспомним, что на самом деле объектные файлы — это команды на языке процессора.

brasil.o

```cpp
// Функция, которая возвращает кофе
Coffee GetCoffee() {
		Oil oil = GetOil();
		Sun sun;
    Water water;
		Coffee coffee = oil + sun + water;
    return coffee;
}

// Вектор очень талантливых игроков в футбол
vector<FootballPlayers> talented_football_players;

```

india.o

```cpp
// Немного ассан йоги
enum class Assana {
    SHAVASANA,
    TADASANA,
    VRIKSHASANA
}

// Вектор программистов, ищущих работу
vector<SoftwareDevelopers> indian_software_developers;

```

norway.o

```cpp
// Просто функция, которая возвращает нефть
Oil GetOil() {
    Oil oil;
	  return oil;
}

// Йога на фьордах для всех желающих
void DoYoga() {
	  Do(SHAVASANA);
    Do(TADASANA);
	  Do(VRIKSHASANA);
}

// Небольшой норвежский клуб играет в футбол
void PlayFootball() {
	  Play(talented_football_players);
}

// Чашечка кофе с утра
void DrinkCoffee() {
	  Coffee coffee = GetCoffee();
    Drink(coffee);
}

```

### Таблица импорта/экспорта Бразилии

|**Экспорт**|**Импорт**|
|--|--|
|**Coffee GetCoffee()**|Oil GetOil()|
|**vector  talented_football_players**|

### Таблица импорта/экспорта Индии

|**Экспорт**|**Импорт**|
|--|--|
|**Assana::SHAVASANA, Assana::TADASANA, Assana::VRIKSHASANA**|
|**vector  indian_software_developers**|

### Таблица импорта/экспорта Норвегии

|**Экспорт**|**Импорт**|
|--|--|
|**Oil GetOil()**|Assana::SHAVASANA, Assana::TADASANA, Assana::VRIKSHASANA|
|**void DoYoga()**|vector  talented_football_players|
|**void PlayFootball()**|Coffee GetCoffee()|
**void DrinkCoffee()**|

![1.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint4/%D0%A0%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BA%D0%BE%D0%B4%D0%B0_%D0%BF%D0%BE_%D1%84%D0%B0%D0%B9%D0%BB%D0%B0%D0%BC/%D0%9C%D0%B5%D1%85%D0%B0%D0%BD%D0%B8%D0%B7%D0%BC_%D1%81%D0%B1%D0%BE%D1%80%D0%BA%D0%B8_%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%8B%D1%85_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%BE%D0%B2/1.png?raw=true)

Компоновщик определяет, какой файл экспортировать и чего не хватает. После этого для каждого пункта импорта компоновщик ищет подходящий пункт экспорта. Функцию  `GetOil()`, которая нужна Бразилии, компоновщик найдёт в Норвегии. Ассаны йоги для Норвегии — у Индии, а футболистов и кофе — у Бразилии. Каждый запрос на импорт найдёт свой экспорт. Неопределённостей не осталось, процесс компоновки прошёл успешно.

Теперь вы знаете, как работает компоновщик, и можете понять суть правила об одном определении. Когда есть два определения для одного и того же, компоновщик просто не может понять, какое из них он должен взять, и сообщает об ошибке. Будь у нас две функции  `GetCoffee`, увидели бы именно такую ошибку.

После того как компоновщик закончил работу, получаем один файл, готовый к исполнению. Обычно он имеет расширение .exe.

### Сводная таблица по этапам сборки многофайлового проекта

|**Название этапа**|**Что происходит**|
|--|--|
|Препроцессинг|Замена директив препроцессора на текст (пример: замена  `#include`  на текст файла)|
|Компиляция|Проверка синтаксиса, соответствия типов, оптимизация, перевод кода в машинные команды|
|Компоновка|Поиск для каждого «‎импорта»‎ своего «экспорта»|

----------

Укажите ошибки в этой программе

```cpp
/*1*/ #include <string>
/*2*/ 
/*3*/ using namespace std;
/*4*/ 
/*5*/ class Foo {
/*6*/     int Bar(string action);
/*7*/     void Buz(vector data);
/*8*/ }

```

```cpp
/*9*/  #include "Foo.h"
/*11*/ 
/*12*/  void Do();
/*13*/ 
/*14*/  int Foo::Bar(vector<int> action) {
/*15*/      Do();
/*16*/	    return 0.3;
/*17*/  }

```

-   `/*1*/`  — ошибка компоновки. Подключена библиотека, которая не используется.
    
-   `/*1*/`— ошибка препроцессора. Неверный синтаксис. Должно быть  `#include "string"`.
    
-   `/*5*/`  — ошибка компиляции. Неверный синтаксис. Скобка должна быть на новой строчке.
    
-   `/*7*/`  — ошибка компоновки. Не хватает библиотеки для  `vector`.
    
-   `/*7*/`  — ошибка компиляции. Не хватает библиотеки для  `vector`.
    
-   `/*7*/`  — ошибка компиляции. Вектор — шаблон; должен быть указан тип данных.
    
-   `/*7*/`— ошибка компоновки. Метод  `Buz`  нигде не определён.
    
-   `/*8*/`  — ошибка компиляции. Не хватает  `;`.
    
-   `/*9*/`  — ошибка препроцессинга. Должно быть  `#include "Foo.cpp"`.
    
-   `/*14*/`  — ошибка компоновки. Тип аргумента, указанный в объявлении, не совпадает с типом в определении.
    
-   `/*14*/`— ошибка компиляции. Тип аргумента, указанный в объявлении, не совпадает с типом в определении.
    
-   `/*15*/`  — ошибка компоновки. Функция  `Do`  не определена.
    
-   `/*16*/`— ошибка компиляции. 0,3 не может быть возвращено, если указан тип возвращаемого значения  `int`.
    
-   `/*17*/`  — ошибка компиляции. Не хватает  `;`.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

----------

Укажите ошибки в этой программе

```cpp
/*1*/ #include <string>
/*2*/ 
/*3*/ using namespace std;
/*4*/ 
/*5*/ class Foo {
/*6*/     int Bar(string action);
/*7*/     void Buz(vector data);
/*8*/ }

```

```cpp
/*9*/  #include "Foo.h"
/*11*/ 
/*12*/  void Do();
/*13*/ 
/*14*/  int Foo::Bar(vector<int> action) {
/*15*/      Do();
/*16*/	    return 0.3;
/*17*/  }

```

-   **(-)**  `/*1*/`  — ошибка компоновки. Подключена библиотека, которая не используется.
    
    -   Библиотека  `string`  в файле используется.
-   **(-)**  `/*1*/`— ошибка препроцессора. Неверный синтаксис. Должно быть  `#include "string"`.
    
    -   Синтаксис верный. Библиотека  `string`  стандартная и должна быть написана в треугольных скобках.
-   **(-)**  `/*5*/`  — ошибка компиляции. Неверный синтаксис. Скобка должна быть на новой строчке.
    
    -   С точки зрения компилятора это не ошибка.
-   **(-)**  `/*7*/`  — ошибка компоновки. Не хватает библиотеки для  `vector`.
    
    -   Это не ошибка компоновки. Такая ошибка появится ещё на этапе компиляции: без соответствующей библиотеки компилятор не поймёт, что такое  `vector`.
-   **(+)**  `/*7*/`  — ошибка компиляции. Не хватает библиотеки для  `vector`.
    
    -   Верно. Без подключения соответствующей библиотеки компилятор не понимает, что такое  `vector`.
-   **(+)**  `/*7*/`  — ошибка компиляции. Вектор — шаблон; должен быть указан тип данных.
    
    -   Верно!
-   **(-)**  `/*7*/`— ошибка компоновки. Метод  `Buz`  нигде не определён.
    
    -   Не ошибка, так как никто этот метод не вызывает. Ни компилятор, ни компоновщик не будут искать определение такого метода.
-   **(+)**  `/*8*/`  — ошибка компиляции. Не хватает  `;`.
    
    -   Верно. Компилятор ждёт этот символ после определения класса.
-   **(-)**  `/*9*/`  — ошибка препроцессинга. Должно быть  `#include "Foo.cpp"`.
    
    -   Если подключить  `#include "Foo.cpp"`, во время препроцессинга файл будет включён сам в себя.  `#include "Foo.h"`  — абсолютно верно.
-   **(-)**  `/*14*/`  — ошибка компоновки. Тип аргумента, указанный в объявлении, не совпадает с типом в определении.
    
    -   Это ошибка не компоновки, а компиляции. Функция объявлена и определена в одном модуле. Экспорта или импорта нет. Компилятор увидит несоответствие.
-   **(+)**  `/*14*/`— ошибка компиляции. Тип аргумента, указанный в объявлении, не совпадает с типом в определении.
    
    -   Верно. Функция объявлена и определена в одном модуле. Компилятор увидит несоответствие.
-   **(+)**  `/*15*/`  — ошибка компоновки. Функция  `Do`  не определена.
    
    -   Верно. У функции  `Do`  есть объявление, поэтому компилятор не найдёт ошибку. Но когда компоновщик начнёт работу, обнаружится, что функции  `Do`  в программе нет. Её никто не экспортирует.
-   **(-)**  `/*16*/`— ошибка компиляции. 0,3 не может быть возвращено, если указан тип возвращаемого значения  `int`.
    
    -   Это не ошибка с точки зрения процесса компиляции. Программа скомпилируется и запустится, но результат может быть не таким, как вы ждёте. 0,3 будет просто конвертировано в  `integer`, и функция вернёт 0.
-   **(-)**  `/*17*/`  — ошибка компиляции. Не хватает  `;`.
    
    -   Это не ошибка. После тела функции  `;`  ставить не нужно.

</details>
