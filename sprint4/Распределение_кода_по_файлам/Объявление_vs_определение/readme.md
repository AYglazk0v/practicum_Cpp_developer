<details>
<summary>Введение:</summary>

# Введение

До сих пор вы работали над проектами в одном файле. В этой теме вы научитесь разделять код на файлы и собирать многофайловые проекты. Вы начнёте видеть код глазами пользователя и компилятора, поймёте разницу между определением и объявлением функции или класса и увидите, из каких этапов состоит компиляция.

</details>

<details>
<summary>Теория + тестирование:</summary>

# Объявление vs определение

Рассмотрим простой код:

```cpp
#include <iostream>

using namespace std;

int main() {
    Foo();
}

void Foo() {
    cout << "Функция Foo выполняется"s << endl;
}

```

Дело в том, что компилятор читает код строчку за строчкой. И до строчки с первым вызовом  `Foo`  ему всё было понятно. Когда компилятор видит вызов функции  `Foo`, он ещё ничего о ней не знает: какие параметры функция принимает, что возвращает, да и вообще, существует ли она на этом свете. Поправить ситуацию просто. Перенесём функцию  `Foo`  над  `main`, и всё заработает:

```cpp
#include <iostream>

using namespace std;

void Foo() {
    cout << "Функция Foo выполняется"s << endl;
}

int main() {
    Foo();
}

```

Но бывают случаи посложнее:

```cpp
#include <iostream>

using namespace std;

void Egg(int x) {
    if (1 == x) {
        cout << "Яйцо вызывает курицу"s << endl;
        Hen();
    } else {
        cout << "А вот и цыплёнок!"s << endl;
    }
}

void Hen() {
    cout << "Курица вызывает яйцо"s << endl;
    Egg(0);
}

int main() {
    Egg(1);
}

```

----------

Предположим, код скомпилировался, хотя этому не бывать. Проникнем в замысел автора и предположим, что программа должна вывести.

-   ```
    Яйцо вызывает курицу
    
    ```
    
-   ```
    Яйцо вызывает курицу
    Курица вызывает яйцо
    А вот и цыплёнок!
    
    ```
    
-   `А вот и цыплёнок!` Сначала  `Egg`  вызовет  `Hen`, потом  `Hen`  вызовет  `Egg`, и только после этого из  `Egg`  сможет вылупиться цыплёнок.
    

Теперь разберёмся, как сделать так, чтобы программа компилировалась, а компилятор не говорил, что “Hen identifier not found”. Почему он не нашёл функцию  `Hen`, если она находится прямо под функцией  `Egg`, — непонятно. Но всё просто. Компилятор проверяет код строчку за строчкой и добирается до первого упоминания функции  `Hen`. Раньше компилятор её не встречал, поэтому решает, что это ошибка.

Окей, компилятор. Ты прав, курица должна быть раньше яйца. Поднимем  `Hen`  над  `Egg`:

```cpp
#include <iostream>

using namespace std;

void Hen() {
    cout << "Курица вызывает яйцо"s << endl;
    Egg(0);
}

void Egg(int x) {
    if (1 == x) {
        cout << "Яйцо вызывает курицу"s << endl;
        Hen();
    } else {
        cout << "А вот и цыплёнок!"s << endl;
    }
}

int main() {
    Egg(1);
}

```

Но теперь та же проблема с вызовом  `Egg`  из функции  `Hen`. Неясно, что должно быть раньше. Чтобы решить это задачу, дадим компилятору нужную информацию, не вдаваясь в детали.

Объявление функции или класса — ответ на вопрос «Что это такое?»‎, а определение — ответ на вопрос «Как это работает?»‎. Компилятору нужно объявление до того, как функция или класс будут использованы. Так он разберётся в коде. Объявление функции содержит возвращаемый тип, имя функции и принимаемые параметры. В примере с одной функцией  `Foo`  это будет выглядеть так:

```cpp
#include <iostream>

using namespace std;

void Foo();

int main(){
    Foo();
}

void Foo() {
    cout << "Функция Foo выполняется"s << endl;
}

```

До первого вызова  `Foo`  компилятор уже видел объявление этой функции, поэтому спокойно закончит процесс без ошибок.

Чтобы перейти к заданию, важно отметить ещё два момента:

1.  Определение — то же, что объявление, но объявление — не то же самое, что определение. То есть функция с телом — это и объявление, и определение, но функция без тела — это только объявление, и без определения код не заработает.
2.  Сказанное в уроке верно не только для функций, но и для классов. Нельзя создавать объекты, использовать методы класса и делать с ним что-либо ещё до того, как компилятор узнает о его существовании и о том, что этот класс умеет.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Предположим, код скомпилировался, хотя этому не бывать. Проникнем в замысел автора и предположим, что программа должна вывести.

-   **(-)**  `Яйцо вызывает курицу`
    
-   **(+)**  `Яйцо вызывает курицу Курица вызывает яйцо А вот и цыплёнок!`
    
-   **(-)**  `А вот и цыплёнок!`

</details>

<details>
<summary>Задание:</summary>

## Задание

Решите проблему с яйцом и курицей так, чтобы порядок определения функций перестал иметь значение.

### Подсказка

Попробуйте сначала объявить функции, а потом определить их.

</details>
