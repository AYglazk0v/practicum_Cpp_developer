<details>
<summary>Теория:</summary>

# Очередь и дек

Разобравшись с LIFO (last in, first out), перейдём к FIFO (first in, first out). Очередь — естественный способ хранения и использования различных объектов. Через очередь передаются запросы на обработку. Через очередь пересылаются данные в сети. Всё, что требует порядка выполнения, использует очередь. В C++ для этого существует стандартный контейнер  [queue](https://ru.cppreference.com/w/cpp/container/queue).

У очереди две специализации:

1.  Приоритетная очередь. Элементы сортируются по их приоритету. Первым на удаление из неё пойдёт элемент с наивысшим приоритетом. Возможны два подхода к реализации такой очереди:
    -   искать подходящее по приоритету место в очереди в момент вставки элемента. Тогда при удалении можно будет просто убрать первый;
    -   всегда добавлять элемент в конец, а в момент удаления искать элемент с наивысшим приоритетом.

В стандартной библиотеке есть специальный контейнер  [priority_queue](https://ru.cppreference.com/w/cpp/container/priority_queue).

1.  Дек — очередь с двусторонним доступом. Она позволяет добавлять и удалять элементы с обоих концов. От вектора дек отличается тем, что не гарантирует хранение всех элементов в памяти последовательно. С одной стороны, это делает дек более гибким. Он может увеличиваться и уменьшаться в зависимости от количества элементов без копирования элементов в новый отрезок памяти. С другой стороны, перемещаться по элементам вектора проще, ведь они заведомо расположены рядом. Выбирая между  `deque`  и  `vector`, отдавайте предпочтение  `deque`, если основными операциями будут вставка и удаление с концов контейнера. А  `vector`  удобнее, когда нужен поиск или любой другой последовательный проход по элементам. В стандартной библиотеке есть специальный контейнер  [deque](https://ru.cppreference.com/w/cpp/container/deque).

</details>

<details>
<summary>Задание:</summary>

## Задание

Внутри контейнера  `queue`  в стандартной библиотеке находится  `deque`. Класс  `queue`  даёт доступ только к определённым возможностям класса  `deque`. Вам реализовывать класс  `queue`  с применением  `deque`  не нужно. Сделайте свою реализацию, используя два стека.

Вы спросите, зачем заниматься такой ерундой. Вспомним задачу о нахождении минимума среди элементов стека без перебора. Структура стека позволяет сделать это достаточно легко. Но структура  `deque`  так не сможет. Поэтому, если для очереди понадобится поддержка поиска минимума или максимума без перебора элементов, реализация с применением стеков — самая подходящая.

Напишите реализацию методов класса  `Queue`, отвечающих принципу FIFO, если внутри контейнера два стека.

## Пример использования

```cpp
int main() {
    Queue<int> queue;
    vector<int> values(5);

    // заполняем вектор для тестирования очереди
    iota(values.begin(), values.end(), 1);
    // перемешиваем значения
    random_shuffle(values.begin(), values.end());

    PrintRange(values.begin(), values.end());

    cout << "Заполняем очередь"s << endl;

    // заполняем очередь и выводим элемент в начале очереди
    for (int i = 0; i < 5; ++i) {
        queue.Push(values[i]);
        cout << "Вставленный элемент "s << values[i] << endl;
        cout << "Первый элемент очереди "s << queue.Front() << endl;
    }

    cout << "Вынимаем элементы из очереди"s << endl;

    // выводим элемент в начале очереди и вытаскиваем элементы по одному
    while (!queue.IsEmpty()) {
        // сначала будем проверять начальный элемент, а потом вытаскивать,
        // так как операция Front на пустой очереди не определена
        cout << "Будем вынимать элемент "s << queue.Front() << endl;
        queue.Pop();
    }
    return 0;
}

```

## Пример вывода

```
5 2 4 3 1
Заполняем очередь
Вставленный элемент 5
Первый элемент очереди 5
Вставленный элемент 2
Первый элемент очереди 5
Вставленный элемент 4
Первый элемент очереди 5
Вставленный элемент 3
Первый элемент очереди 5
Вставленный элемент 1
Первый элемент очереди 5
Вынимаем элементы из очереди
Будем вынимать элемент 5
Будем вынимать элемент 2
Будем вынимать элемент 4
Будем вынимать элемент 3
Будем вынимать элемент 1

```

### Подсказка

Посмотрите на вставку элемента. Сначала вариантов немного: просто складывайте элементы в первый стек. Когда накопится несколько элементов, вы хотите что-нибудь оттуда вытащить. По принципу FIFO первым должен выйти тот элемент, который сейчас находится на дне первого стека. Нужно поправить эту ситуацию. Переложите все элементы первого стека во второй.

</details>
