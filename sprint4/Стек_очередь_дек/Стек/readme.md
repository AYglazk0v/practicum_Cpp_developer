
<details>
<summary>Введение:</summary>

# Введение, FIFO и LIFO

Эти странные сочетания букв в названии урока — не два итальянских брата, а аббревиатуры, обозначающие принципы работы абстрактного контейнера:

-   FIFO (first in, first out) — «Первый зашёл, первый вышел»‎;
-   LIFO (last in, first out) — «‎Последний зашёл, первый вышел»‎.

Оба принципа часто встречаются в реальной жизни. Представьте, что вы в магазине. Взяли тележку на входе, протёрли ручку антибактериальной салфеткой и отправились собирать продукты по списку. С полной тележкой вы подходите к кассе и видите оба принципа в действии:

1.  Перед вами ещё несколько человек. Того, кто первый пришёл, кассир обслужит первым. Это FIFO — «Первый зашёл, первый вышел»‎.
2.  Подошла ваша очередь, и вы начинаете разгружать тележку. Прежде всего на ленте окажется то, что в тележке сверху. То есть то, что вы положили в неё последним. Это LIFO — «‎Последний зашёл, первый вышел»‎.

Эти принципы из повседневной жизни нашли применение в программировании. Принцип FIFO называется очередью, а LIFO — стеком. Этот стек напрямую связан со стеком вызовов функций. Как именно — узнаете в этой теме.

Пока речь идёт не о контейнерах и библиотеках, а об абстракции, у которой может быть бесконечное количество реализаций. Реализации в примерах и заданиях — не единственные возможные.

В этой теме вы узнаете, как некоторые контейнеры языка С++ помогают реализовать принцип работы очереди или стека.

</details>

<details>
<summary>Теория:</summary>

# Стек

Вы уже видели, как работает LIFO в ситуации с тележкой в магазине. Другим примером может быть магазин с патронами. Первым из ствола вылетит тот патрон, который вставлен последним. Более близкое к программированию применение стека — знакомый вам стек функций. Он организован точно так же, как магазин с патронами.

Рассмотрим пример:

```cpp
void Bar() {
    int x = 2;
}

void Foo() {
    int x = 1;
    Bar();
}

int main() {
    int x = 0;
    Foo();
}

```

1.  Всё начинается с функции  `main`. Она добавляется в стек.
2.  `main`  вызывает функцию  `Foo`. Все локальные переменные функции  `Foo`  оказываются сверху функции  `main`. При этом локальные переменные функции  `main`  не доступны из стека функции  `Foo`. Можно не бояться, что у них совпадают имена.
3.  Функция  `Foo`  вызывает функцию  `Bar`. Происходит то же самое, что на прошлом шаге, только теперь на верх стека добавляется функция  `Bar`.
4.  Предположим,  `Bar`  закончила работу. Теперь её можно удалить из стека. Сверху теперь снова оказалась функция  `Foo`  и все её локальные переменные на месте.
5.  Теперь функция  `Foo`  тоже закончила работу. Сверху стека оказалась функция  `main`, с которой всё начиналось.
6.  Функция  `main`  закончила своё выполнение. Стек пуст. Это значит, что программа завершила работу, а возвращаемое значение функции  `main`  и есть возвращаемое значение всей программы.

Попробуйте так же нарисовать стек для рекурсивной функции.

Из всех примеров вытекает, какими должны быть методы класса  `Stack`:

-   Вставка элемента в стек —  `Push`;
-   Удаление элемента из стека —  `Pop`;
-   Получение значения вершины стека —  `Peek`;
-   Размер стека —  `Size`;
-   Проверка на пустоту —  `IsEmpty`. Проверить контейнер на пустоту можно и через функцию  `Size`. Но она будет долго пересчитывать все элементы. А  `IsEmpty`  позволяет без пересчёта узнать, пуст контейнер или нет.

</details>

<details>
<summary>Задание 1:</summary>

## Задание 1

Чтобы работать со стеком по всем правилам LIFO, напишите класс, который поможет это сделать. Храните элементы стека в векторе. Напишите свою реализацию методов  `Push`,  `Pop`,  `Peek`,  `Size`  и  `IsEmpty`. Для удобства добавьте ещё метод  `Print`. Элементы могут быть разных типов, поэтому нужен класс-шаблон.

Методов  `Peek`  два, потому что один из них будет вызываться в случае константного объекта, а другой — в остальных случаях. При этом возвращаемое значение будет разным. Если объект константный, нужно гарантировать, что пользователь не изменит тот объект, на который ему передаётся ссылка. Поэтому в константном методе возвращается  `const Type&`. В другом случае можно спокойно вернуть ссылку без  `const`, так как стек не будет неизменяемым объектом — пользователь может свободно его менять. Этот же принцип будет выполняться всегда, когда предоставляете пользователю доступ к элементам контейнера.

### Пример использования

```cpp
int main() {
    Stack<int> stack;
    for (uint32_t i = 0; i < 10; ++i) {
        stack.Push(i);
        stack.Print();
    }
    while (!stack.IsEmpty()) {
        stack.Pop();
        stack.Print();
    }
}

```

### Пример вывода

```
0
0 1
0 1 2
0 1 2 3
0 1 2 3 4
0 1 2 3 4 5
0 1 2 3 4 5 6
0 1 2 3 4 5 6 7
0 1 2 3 4 5 6 7 8
0 1 2 3 4 5 6 7 8 9
0 1 2 3 4 5 6 7 8
0 1 2 3 4 5 6 7
0 1 2 3 4 5 6
0 1 2 3 4 5
0 1 2 3 4
0 1 2 3
0 1 2
0 1
0

```

### Подсказка

Добавление и удаление в вектор должны происходить с одного конца. Удобнее сделать это именно с конца, а не с начала. Примените стандартные методы контейнера  `vector`.

</details>

<details>
<summary>Задание 2:</summary>

## Задание 2

Удобно, когда  `IsEmpty`  не пересчитывает все элементы, а другим способом отвечает, пуст стек или нет. В этом задании вы сделаете подобный трюк. Напишите реализацию класса  `StackMin`, у которого кроме стандартных методов класса  `Stack`  будет дополнительный метод  `PeekMin`. Он должен уметь вернуть минимальный по значению на данный момент элемент в стеке. Важно организовать стек так, чтобы для поиска минимума не пришлось перебирать все элементы в стеке. Перебора элементов не должно быть ни в методе  `PeekMin`, ни в каком другом. Возьмите эту заготовку класса и дополните её своей реализацией:

```cpp
template <typename Type>
class StackMin {
public:
    void Push(const Type& element) {
    // напишите реализацию метода
    }
    void Pop() {
    // напишите реализацию метода
    }
    const Type& Peek() const {
        return elements_.Peek();
    }
    Type& Peek() {
        return elements_.Peek();
    }
    void Print() const {
        // работу этого метода мы проверять не будем,
        // но если он вам нужен, то можете его реализовать
        elements_.Print();
    }
    uint64_t Size() const {
        return elements_.size();
    }
    bool IsEmpty() const {
        return elements_.IsEmpty();
    }
    const Type& PeekMin() const {
    // напишите реализацию метода
    }
    Type& PeekMin() {
    // напишите реализацию метода
    }
private:
    Stack<Type> elements_;
    // возможно, здесь вам понадобится что-то изменить
};

```

### Пример использования

```cpp
int main() {
    StackMin<int> stack;
    vector<int> values(5);

    // заполняем вектор для тестирования нашего стека
    iota(values.begin(), values.end(), 1);
    // перемешиваем значения
    random_shuffle(values.begin(), values.end());

    // заполняем стек
    for (int i = 0; i < 5; ++i) {
        stack.Push(values[i]);
    }

    // печатаем стек и его минимум, постепенно убирая из стека элементы
    while (!stack.IsEmpty()) {
        stack.Print();
        cout << "Минимум = "s << stack.PeekMin() << endl;
        stack.Pop();
    }
}

```

### Пример вывода

```
5 2 4 3 1
Минимум = 1
5 2 4 3
Минимум = 2
5 2 4
Минимум = 2
5 2
Минимум = 2
5
Минимум = 5

```

### Подсказка

Когда нужно что-то вернуть без пересчётов и вычислений, обычно эту информацию нужно где-то хранить. Просто добавить в  `private`  член класса  `minimum`  будет недостаточно. Посмотрим на такой случай:

-   Добавим в стек 1.  `minimum_`  станет равен 1.
-   Добавим в стек 5.  `minimum_`  останется равен 1, так как 1 < 5.
-   Добавим в стек 1.  `minimum_`  всё ещё 1.
-   Добавим в стек 2.  `minimum_`  также остался 1.
-   Вытащим из стека 2. Ничего не поменялось.
-   Вытащим из стека 1. Стек ещё не пуст, в нём остались 1 и 5. Но теперь не понять, чему равен минимум, не вытаскивая все элементы из стека и не перебирая их.

Придумаем, как выбраться из тупика. Вероятно, хранить нужно не один последний минимальный элемент. Если удаляем элемент из стека, нужно знать, какой теперь минимум. Было бы здорово для каждого элемента в стеке знать, чему равен минимум, если этот элемент — вершина стека. Тогда алгоритм начинает работать так:

-   Добавим в стек 1. Минимум в этом случае равен самому элементу. Нужно сохранить эту пару: элемент 1 — минимум 1.
-   Добавим в стек 5. Минимум остался равен 1. Сохраняем: элемент 5 — минимум 1.
-   Добавим в стек 1. Минимум тот же. Сохраняем: элемент 1 — минимум 1.
-   Добавляем 2. Сохраняем: элемент 2 — минимум 1.
-   Вытаскиваем 2. На вершине оказалось «элемент 1 — минимум 1». И нет проблем дальше вытаскивать следующий элемент и отвечать на запрос про текущий минимум.

</details>

<details>
<summary>Задание 3:</summary>

## Задание 3

Продолжите исследовать стек и то, как его можно реализовать.

В этот раз напишите класс  `SortedStack`, который бы всегда поддерживал свои элементы в отсортированном виде. При вставке сортировка должна сохраняться. На вершине стека всегда должен быть минимум. Не используйте в этой задаче алгоритмы сортировки — её можно решить без них.

Методы стека перестанут быть такими простыми, эффективными и быстрыми, как раньше. В них могут появиться условия и циклы. Это цена, которую вы платите за то, что стек будет постоянно находиться в сортированном состоянии.

Используйте заготовку и допишите необходимую реализацию методов  `Push`  и  `Pop`:

```cpp
template <typename Type>
class SortedStack {
public:
    void Push(const Type& element) {
    // напишите реализацию метода
    }
    void Pop() {
    // напишите реализацию метода
    }
    const Type& Peek() const {
    return elements_.Peek();
    }
    Type& Peek() {
    return elements_.Peek();
    }
    void Print() const {
    elements_.Print();
    }
    uint64_t Size() const {
    return elements_.Size();
    }
    bool IsEmpty() const {
    return elements_.IsEmpty();
    }
private:
    Stack<Type> elements_;
};

```

### Пример использования

```cpp
int main() {
    SortedStack<int> stack;
    vector<int> values(5);

    // заполняем вектор для тестирования нашего стека
    iota(values.begin(), values.end(), 1);
    // перемешиваем значения
    random_shuffle(values.begin(), values.end());

    // заполняем стек и проверяем, что сортировка сохраняется после каждой вставки
    for (int i = 0; i < 5; ++i) {
        cout << "Вставляемый элемент = "s << values[i] << endl;
        stack.Push(values[i]);
        stack.Print();
    }
}

```

### Пример вывода

```
Вставляемый элемент = 5
5
Вставляемый элемент = 2
5 2
Вставляемый элемент = 4
5 4 2
Вставляемый элемент = 3
5 4 3 2
Вставляемый элемент = 1
5 4 3 2 1

```

### Подсказка

Вам нужно вставить новый элемент. Ответьте на некие три вопроса, которые вы где-то уже видели.

1.  **Какие параметры принимает функция?**  Функция  `Push`  принимает элемент для вставки. Это вы уже знаете.
2.  **В каком случае мы можем остановить алгоритм**  поиска места для вставки и вставить элемент без дальнейших действий? Если стек пуст или если элемент больше или равен элементу на вершине стека.
3.  **Что делать, если алгоритм не остановился?**  Это значит, что элемент сверху больше того, который вы хотите вставить. Вытащите его, но сохраните, чтобы потом вернуть. Теперь у вас есть стек без верхнего элемента. Попробуйте повторить для него весь алгоритм.

В итоге вы найдёте место для вставки, вставите новый элемент, а дальше нужно будет вернуть все вытащенные элементы на место.

</details>
