<details>
<summary>Введение:</summary>
# Введение

Вы уже сталкивались с алгоритмами поиска и методами контейнеров  `find`  и  `count`. Алгоритм  [`find`](https://ru.cppreference.com/w/cpp/algorithm/find)  и его родственники  `find_if`  и  `find_if_not`  ищут элемент в контейнере. Алгоритмы  [`count`](https://ru.cppreference.com/w/cpp/algorithm/count)  и  `count_if`  возвращают количество элементов, равных переданному параметру, и количество элементов, для которых выполняется некое условие.

Когда у контейнера есть собственные методы поиска, лучше использовать их, а не общий алгоритм. Например, при поиске в словаре или множестве метод  `find`  будет эффективнее, чем алгоритм  `find`:

```cpp
map<int, string> my_map;
my_map[0] = "первый"s;
my_map[1] = "второй"s;
my_map[2] = "третий"s;
// результаты этих двух поисков будут одинаковы,
// но первый будет сделан более эффективно
auto it_more_efficient = my_map.find(1);
auto it = find(my_map.begin(), my_map.end(), 1);

```

Простой поиск элемента, проверка его существования и подсчёт элементов — не единственные алгоритмы поиска. В этой теме вы научитесь:

-   искать первый элемент, равный данному или больший,
-   искать первый элемент, больший, чем данный,
-   делать всё это в отсортированном и неотсортированном векторе, строке, в словаре и множестве.

Чтобы систематизировать знания, вы будете отмечать методы и функции в таблице.

### Методы поиска

|Что и как хотим найти? / Где ищем?|Неотсортированный вектор|Отсортированный вектор|Множество или словарь|
|--|--|--|--|
|Проверка существования|
|Проверка существования и поиск первого подходящего элемента|
|Поиск первого элемента, большего или равного данному|
|Поиск первого элемента, большего данного|
|Подсчёт количества|
|Перебор по всем подходящим элементам|
</details>

<details>
<summary>Теория:</summary>

# Понятие итератора

Программисты любят использовать то, что уже написано. Причин на это много. Среди них наверняка есть и лень. Но гораздо важнее другое: если что-нибудь уже написано, значит это протестировано, ошибки найдены и исправлены. Если не все, то хотя бы часть. Поэтому программисты рады, когда менять в коде надо совсем мало. Чем меньше, тем лучше. Меньше изменений, меньше ошибок, меньше времени на разработку.

Чтобы избежать будущих изменений и сделать код более гибким, программисты прибегают к приёму, который можно назвать «добавление уровня абстракции».

Рассмотрим пример:

```cpp
#include <iostream>

using namespace std;

int main() {
    cout << "Платочки белые"s << endl;
    cout << "Платочки белые"s << endl;
    cout << "Платочки белые"s << endl;
    cout << "Платочки белые, глаза печальные"s << endl;
    cout << "Вагончик тронется"s << endl;
    cout << "Вагончик тронется"s << endl;
    cout << "Вагончик тронется"s << endl;
    cout << "Вагончик тронется, перрон останется"s << endl;
}

```

Если окажется, что платочки не белые, а синие, придётся поправить это в четырёх местах. Шанс ошибиться и забыть внести нужное исправление достаточно большой.

Добавляем новый уровень абстракции — переменные, куда положим строки:

```cpp
#include <iostream>
#include <string>

using namespace std;

int main() {
    string chorus_1 = "Платочки белые"s;
    string chorus_2 = "Вагончик тронется"s;
    cout << chorus_1 << endl;
    cout << chorus_1 << endl;
    cout << chorus_1 << endl;
    cout << chorus_1 <<", глаза печальные"s << endl;
    cout << chorus_2 << endl;
    cout << chorus_2 << endl;
    cout << chorus_2 << endl;
    cout << chorus_2 << ", перрон останется"s << endl;
}

```

Теперь заменить цвет платочков стало гораздо проще. Мы абстрагировались от конкретной строки и работаем с переменной. Переменная — наш новый уровень абстракции. Если пофантазировать с этим примером дальше, можно найти и такую абстракцию как цикл. За ней будет прятаться повторение строчек нужное количество раз. А мы увидим, что циклов уже два, и добавим ещё один уровень абстракции — функцию. Потом подумаем, что, может быть, не хотим выводить всю песню на консоль, и было бы здорово записать её в файл или отправить в сеть. Будут появляться всё более и более высокие уровни абстракции, которые позволят делать код гибче. Именно так когда-то была придумана концепция итераторов.

Отвлекитесь от платочков, нас ждут более насущные дела — итерация по контейнерам.

Для каждого контейнера переход от одного элемента к другому может осуществляться разными способами. Например, чтобы перейти с одного элемента вектора на другой, нужно просто сдвинуться в памяти компьютера вперёд на размер одного элемента вектора. Во множестве и словаре будет иначе. Возникают вопросы:

-   Должен ли запускаемый алгоритм знать эти различия?
-   Если пишем алгоритмы под каждый контейнер, каков шанс, что ошибка, найденная в одном из алгоритмов, будет исправлена в другом?

Гораздо удобнее придумать новую абстракцию и научить алгоритмы работать с ней, а за каждой абстракцией спрятать конкретную реализацию.


Вспомним уже известный вам алгоритм  `count`:

```cpp
const vector<int> xs = {1, 2, 1, 1, 5};
cout << count(xs.begin(), xs.end(), 1) << endl; // 3

```

Методы  `xs.begin()`  и  `xs.end()`  возвращают итераторы, и дальше алгоритм  `count`  работает именно с итераторами. Через них алгоритм получает доступ к элементам контейнера, может итерировать по элементам, но к самому контейнеру у алгоритма доступа нет. Вектор остаётся неизменным. Не меняется порядок элементов, размер не увеличивается и не уменьшается. Сделать это через итераторы нельзя. Получается, что итераторы ещё и защищают контейнер от неожиданных изменений. При этом заменить  `vector`  на другой контейнер не составит труда.

</details>

<details>
<summary>Задание 1:</summary>

## Задание 1

Научимся применять новый алгоритм  `find_if`. Результат его работы — итератор, указывающий на первый элемент в контейнере, для которого выполняется некое условие. В качестве параметров он принимает итератор на начало контейнера, итератор на конец и лямбда-функцию, аналогично алгоритму  `count_if`. Воспользуйтесь алгоритмом  `find_if`  и найдите в заданном векторе языков программирования первый язык, начинающийся на “C”. Чтобы получить доступ к элементу контейнера через итератор, примените оператор  `*`:

```cpp
cout << *it << endl;

```

Считайте, что искомый элемент в контейнере существует.

### Пример вывода:

```
С#
```

### Подсказка

Чтобы правильно вызвать  `find_if`, пригодятся лямбда-функции. Вернитесь к уроку о них, если возникли сложности.

</details>

<details>
<summary>Задание 2:</summary>

## Задание 2

Как вы помните, итераторы даны нам для гибкости кода и для простоты внесения изменений. Пусть теперь вектор будет хранить не просто строки, а структуры. Найдите первый и единственный в данном случае язык, начинающийся на “J”. Попробуйте самостоятельно разобраться, как правильно вывести результат на экран. Всё так же продолжайте считать, что искомый элемент в контейнере есть.

### Пример вывода:

```
Java, 24
```

### Подсказка

Чтобы получить доступ к отдельным полям структуры через итератор, используйте  `->`.

</details>
