<details>
<summary>Теория + тестирование:</summary>

# Концепция полуинтервалов

В этом уроке вы познакомитесь с концепцией полуинтервалов и узнаете, как она связана с итераторами.

### Элемент, которого нет

Вернёмся к задаче из предыдущего урока:

```cpp
#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

struct Lang {
    string name;
    int age;
};

int main() {
    vector<Lang> langs = {{"Python"s, 29}, {"Java"s, 24}, {"C#"s, 20}, {"Ruby"s, 25}, {"C++"s, 37}};
    // Выведите первый язык, начинающийся на J, используя алгоритм find_if
    auto result = find_if(langs.begin(), langs.end(), [](const Lang &lang) {
        return lang.name[0] == 'J';
    });
    cout << result->name << ", "s << result->age << endl;
}

```

Попробуем найти то, чего в контейнере нет. Например, поищем хоть что-нибудь, начинающееся с “K”:

```cpp
#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

struct Lang {
    string name;
    int age;
};

int main() {
    vector<Lang> langs = {{"Python"s, 29}, {"Java"s, 24}, {"C#"s, 20}, {"Ruby"s, 25}, {"C++"s, 37}};

    auto result = find_if(langs.begin(), langs.end(), [](const Lang &lang) {
        return lang.name[0] == 'K';
    });
    cout << result->name << ", "s << result->age << endl;
}

```

Попытайтесь запустить этот код. Скорее всего, программа просто упадёт. Но понять, получилось ли что-то найти, хочется. Это несложно. Если ничего не найдено, функция вернёт в качестве результата тот же итератор, что возвращается при использовании метода  `end`. Но называть его «‎концом контейнера» пока не будем — сначала нужно разобраться. Говоря «‎конец контейнера», можем иметь в виду два места:

1.  Последний элемент контейнера;
2.  Место, не содержащее никакого элемента и находящееся за последним из них.

![1.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint4/%D0%98%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B/%D0%9A%D0%BE%D0%BD%D1%86%D0%B5%D0%BF%D1%86%D0%B8%D1%8F_%D0%BF%D0%BE%D0%BB%D1%83%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%B2%D0%B0%D0%BB%D0%BE%D0%B2/1.png?raw=true)

Во втором случае речь об итераторе, который возвращает метод  `end`. Этот итератор указывает на некое место за пределами контейнера. Так можно понять, что элемент в контейнере не найден.

Мы называем что-либо интервалом, если начало и конец НЕ входят в число элементов. В математике это принято обозначать так:

(1; 10)— здесь и 1, и 10 НЕ входят в интервал. То есть входят в него целые числа 2, 3, 4, 5, 6, 7, 8 и 9.

Мы называем что-либо полуинтервалом, если что-нибудь одно (начало или конец) не включено в число элементов. В математике это выглядит так:

[1; 10) — здесь 1 будет элементом, а 10 уже нет. В полуинтервал входят целые числа 1, 2, 3, 4, 5, 6, 7, 8, и 9. Число 10 всё ещё никуда не входит.

Переводя идею интервалов на итераторы, получаем концепцию полуинтервалов.

### Веди себя как итератор

Идею полуинтервалов разберём подробно. Но перед этим посмотрим, что такое итератор в принципе.

Это не тип данных и не контейнер. Итератор не содержит никаких данных, он может только указывать на них. Похож на ссылку, но его можно двигать. Ещё он умеет показывать на что-нибудь, что элементом не будет, а ссылка обязательно должна указывать на нечто содержательное.

По своей сути итератор — это объект, для которого определены некоторые действия. Например, оператор  `*`  позволяет получить доступ к элементу контейнера, на который итератор указывает. Так же определён оператор  `++`, чтобы передвигаться от элемента к элементу. К итератору можно добавлять число и сдвигаться на некое количество позиций.

Всё это подразумевается, когда итератор передаётся в алгоритм. Если объект, полученный алгоритмом в качестве итератора, будет уметь делать то, что должен делать итератор, он будет признан итератором.

А теперь, зная, что к итератору можно прибавлять числа, посмотрим на полуинтервалы в примере. В нашем векторе языков программирования пять элементов, а позиций, на которые может условно указывать итератор — шесть. Если  `langs.begin()`  указывает на нулевой элемент, то  `langs.begin() + 5`  указывает на  `langs.end()`, и между ними ровно пять элементов. Удобно, что разность итераторов равна количеству элементов в соответствующем полуинтервале.

______

Что будет верно для пустого контейнера?

-   Итератор  `begin`  будет равен итератору  `end`.
    
-   Расстояние между итератором  `begin`  и итератором  `end`  будет равно 0.
    
-   Итератор  `end`  для этого случая не определён.
    
-   Итератор  `begin`  для этого случая не определён.

</details>

<details>
<summary>Ответ:</summary>

Что будет верно для пустого контейнера?

-   **(+)**  Итератор  `begin`  будет равен итератору  `end`.
    
    -   Действительно, итераторы будут равны.
-   **(+)**  Расстояние между итератором  `begin`  и итератором  `end`  будет равно 0.
    
    -   Верно. Итераторы одного контейнера можно вычитать друг из друга и получать расстояние между ними, выраженное в количестве элементов. В этом случае расстояние будет равно 0.
-   **(-)**  Итератор  `end`  для этого случая не определён.
    
    -   Итератор  `end`  будет определён.
-   **(-)**  Итератор  `begin`  для этого случая не определён.
    
    -   Итератор  `begin`  будет определён.

</details>

<details>
<summary>Задание 1:</summary>

### Задание 1

Напишите функцию  `PrintRange`, которая была бы шаблоном от типа итератора и принимала полуинтервал итераторов, а затем выводила бы значение элемента. Можно предполагать, что оператор вывода для элемента контейнера определён. Пусть элементы выводятся через пробел. В конце вывода должен быть символ конца строки. Функция  `PrintRange`  полезная. Сохраните решение у себя локально или в своём  `git`-хранилище. Оно вам ещё много раз пригодится.

### Пример вызова функции

```cpp
int main() {
    set<int> test = {1, 1, 1, 2, 3, 4, 5, 5};
    PrintRange(test.begin(), test.end());
}
```

### Пример вывода

```
1 2 3 4 5
```

### Подсказка

Помните, что итератор — это набор определённых действий, и операторов сравнения среди них нет. Но есть  `!=`.

</details>

<details>
<summary>Задание 2:</summary>

## Задание 2

Напишите функцию-шаблон  `FindAndPrint`, которая бы принимала контейнер и переменную типа элемента контейнера. Функция должна распечатать на первой строчке часть контейнера, предшествующую найденному элементу, а на второй строчке часть, последующую элементу, включая сам элемент. Если элемент в контейнере не найден, выведите весь контейнер одной строкой. Используйте ваше решение из предыдущей задачи для вывода результатов на экран.

### Пример вызова функции

```cpp
int main() {
    set<int> test = {1, 1, 1, 2, 3, 4, 5, 5};
    FindAndPrint(test, 3);
    FindAndPrint(test, 0);
}

```

### Пример вывода

```
1 2
3 4 5
1 2 3 4 5

```

### Подсказка

Вы можете применить функцию  `find`  или  `find_if`  стандартной библиотеки  `<algorithm>`.

</details>
