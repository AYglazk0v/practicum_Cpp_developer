<details>
<summary>Теория + тестирование:</summary>

# Категории итераторов

В прошлых уроках мы обращались со всеми итераторами одинаково. Но на самом деле они отличаются друг от друга. В этом спринте вы изучите алгоритмы, которые упрощают жизнь программиста. Но для этого сначала разберёмся, какие категории итераторов существуют и чем они отличаются.

Вспомним, что итератор — это не тип данных, а набор действий, которые с ними можно совершить. Соответственно, типы итераторов отличаются по набору поддерживаемых действий. Видя тот или иной тип итератора в качестве аргумента для функции, можно понять, какие действия этот итератор должен поддерживать.

### Итератор чтения (Input iterator)

Поддерживаемые операции:

-   Чтение значения элемента. Это значит, что внутри метода или функции, принимающей такой итератор, нужно будет прочитать элемент по итератору. Вот так:  `*it`;
-   Операторы сравнения  `==`  и  `!=`. Это мы использовали, когда в цикле  `for`  сравнивали итератор с  `end`;
-   Оператор  `++`  (как префиксный, так и постфиксный) для перемещения на следующий элемент.

Такие итераторы гарантируют возможность чтения элемента, но не гарантируют запись. Они должны поддерживать минимальный набор действий над собой.

Посмотрим на заголовок алгоритма  [find](https://ru.cppreference.com/w/cpp/algorithm/find). Обратите внимание на  `InputIt`. Это значит, что алгоритм будет обращаться к элементам контейнера, чтобы их прочитать. Итераторы всех изученных контейнеров — это итераторы чтения. Так что в  `find_if`  их передать можно:

```cpp
template< class InputIt, class T >
InputIt find( InputIt first, InputIt last, const T& value );

```

### Итератор записи (Output iterator)

Поддерживаемые операции:

-   Запись значения в элемент. Это значит, что метод или функция через итератор будут пытаться обратиться к элементу и записать в него какое-нибудь значение. Вот так:  `*it = new_value`;
-   Операторы сравнения  `==`  и  `!=`;
-   Оператор  `++`  (как префиксный, так и постфиксный).

Итераторы не обязаны гарантировать возможность чтения.

Пример алгоритма, использующего такой итератор, —  [`copy`](https://ru.cppreference.com/w/cpp/algorithm/copy). Он копирует диапазон от  `first`  до  `last`  в диапазон, начинающийся с  `d_first`. При этом  `first`  и  `last`  будут использованы только для чтения, а  `d_first`  — только для записи. Итераторами записи также будут, например, неконстантные итераторы вектора или строки. Если имеете дело со множеством или с константным контейнером, изменить значение по итератору ожидаемо не выйдет:

```cpp
template< class InputIt, class OutputIt >
OutputIt copy( InputIt first, InputIt last, OutputIt d_first );

```

### Однонаправленный итератор (Forward iterator)

Однонаправленный итератор — итератор чтения с возможностью обойти элементы контейнера, но только в одном направлении. Обход контейнера может быть сделан несколько раз. Только вперёд и ни шагу назад. Иначе говоря, оператор декремента  `--`  у них может быть не определён. Пример алгоритма, использующего такой итератор —  [`replace`](https://ru.cppreference.com/w/cpp/algorithm/replace).

### Двунаправленный итератор (Bidirectional iterator)

Двунаправленный итератор — это однонаправленный итератор, которого научили ходить назад. Для двунаправленного итератора должен быть определён оператор декремента. Пример алгоритма, использующего такой итератор, —  [`reverse`](https://ru.cppreference.com/w/cpp/algorithm/reverse).

### Итератор произвольного доступа (Random access iterator)

Самые строгие требования предъявляются к итератору произвольного доступа. Кроме всех операций, поддерживаемых двунаправленным итератором, в его наборе должны быть:

-   Операции сложения и вычитания с числами для перемещения сразу на определённое расстояние от текущей позиции;
-   Возможность вычитать итераторы друг из друга;
-   Операторы сравнения  `>`,  `<`,  `>=`,  `<=`;
-   Оператор  `[ ]`. Выражение  `it[n]`  равносильно выражению  `*(it + n)`, то есть оно позволяет получить доступ к элементу, отстоящему от итератора it на n позиций

Пример алгоритма, для которого нужны итераторы произвольного доступа, —  [`random_shuffle`](https://ru.cppreference.com/w/cpp/algorithm/random_shuffle).

Если краем глаза заглянем в документацию, увидим, что на самом деле все категории итераторов — пустые классы. Они нужны только для того, чтобы пользователь по списку аргументов функции мог понять, какие операции внутри функции будут применяться и что передаваемый итератор должен поддерживать. Вся ответственность за передачу итератора нужной категории лежит на пользователе.

### Advance, distance и next

Бывает, что внутри кода нужно сдвинуть итератор на несколько шагов или узнать расстояние между двумя итераторами. При этом итераторов произвольного доступа среди имеющихся нет. В таких случаях применяют функции  [advance](https://ru.cppreference.com/w/cpp/iterator/advance),  [distance](https://ru.cppreference.com/w/cpp/iterator/distance)  и  [next](https://ru.cppreference.com/w/cpp/iterator/next).

`Advance`  шаг за шагом сместит итератор  `it`  на нужное количество элементов.  `n`  может быть и отрицательным. Тогда итератор должен поддерживать требования к категории двунаправленных итераторов, а не просто итераторов чтения. Иначе поведение функции не определено. Пример:

```cpp
template< class InputIt, class Distance >
void advance( InputIt& it, Distance n );

```

`Distance`  просто считает, сколько надо сделать шагов от  `first`  до  `last`. Если дойти от  `first`  до  `last`  или от  `last`  до  `first`  невозможно, поведение функции не определено, и полагаться на результат не стоит. Пример:

```cpp
template< class InputIt >
typename [std::iterator_traits](http://ru.cppreference.com/w/cpp/iterator/iterator_traits)<InputIt>::difference_type
distance( InputIt first, InputIt last );

```

`Next`  похожа на  `advance`, но не меняет сам итератор — он остаётся на месте. Next возвращает итератор на новую позицию, а  `advance`  сдвигает итератор, переданный в качестве параметра. Кроме этого, если не передадим в  `next`  параметр количества позиций, по умолчанию нам вернётся итератор на следующую позицию. Пример:

```cpp
template< class ForwardIt >
ForwardIt next( ForwardIt it,
                typename std::iterator_traits<ForwardIt>::difference_type n = 1 );

```

Для итераторов произвольного доступа эффективнее использовать оператор вычитания и сложения. Например, если вы уже внутри метода или функции, которая работает только с итераторами произвольного доступа, выберите арифметические операции. Функции  `advance`,  `distance`  и  `next`  сначала должны определить, какой итератор перед ними. У арифметических операций дополнительной проверки на то, какая категория итератора применяется, нет. Но в случаях, когда хотите поддержать и другие категории итераторов, используйте  `distance`  и  `advance`. Так вы избежите ошибок компиляции. О них — далее.

### Что будет, если сделать, как не надо

Отправим в алгоритм итератор неподходящей категории. Воспользуемся тем, что

-   итератор контейнера  `set`  — двунаправленный, как сообщает  [документация](https://ru.cppreference.com/w/cpp/container/set);
-   алгоритм  `random_shuffle`  требует итераторы категории произвольного доступа.

Логики в том, чтобы вызывать  `random_shuffle`  для контейнера  `set`, нет никакой, но нам интересно посмотреть поведение компилятора:

```cpp
set<string> unique_langs = {"Python"s, "Java"s, "C#"s, "Ruby"s, "C++"s};
random_shuffle(unique_langs.begin(), unique_langs.end());

```

Запустив компиляцию, увидим ошибки. Например, такую:

```
error: no match for 'operator+' (operand types are 'std::_Rb_tree_const_iterator<std::__cxx11::basic_string<char> >' and 'int')
for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)

```

Компилятор пытается найти оператор сложения для итератора и для числа. Но оператора у него нет, так как двунаправленные итераторы не умеют складываться с числами. А без этого не работает алгоритм. Компилятор не находит подходящий метод и сообщает об ошибке.

При этом компилятор не говорит, что мы передали итератор не той категории. С этой точки зрения всё в порядке: в качестве итераторов можно передавать любые типы. Главное, чтобы компилятор смог найти все нужные для работы алгоритма методы.

----------

Какие операции должны поддерживать итераторы  `first`  и  `last`, передаваемые в эту функцию? Возможны несколько верных ответов.

```cpp
template <class InputIterator, class UnaryPredicate>
   InputIterator find_if (InputIterator first, InputIterator last, UnaryPredicate pred);

```

-   Инкремент
    
-   Декремент
    
-   Чтение
    
-   Запись
    

----------

Какие операции должны поддерживать итераторы  `first`  и  `last`, передаваемые в эту функцию? Возможны несколько верных ответов.

```cpp
template <class BidirectionalIterator, class UnaryPredicate>
  BidirectionalIterator partition (BidirectionalIterator first,
                                   BidirectionalIterator last, UnaryPredicate pred);

```

-   Инкремент
    
-   Декремент
    
-   Чтение
    
-   Запись
    

----------

К какой категории относится стандартный библиотечный итератор контейнера  `vector`? Чтобы ответить, используйте документацию C++ по  [ссылке](https://ru.cppreference.com/)  или любой другой удобный вам ресурс. Верный ответ только один, не нужно отмечать все подкатегории.

-   Итератор чтения
    
-   Однонаправленный итератор
    
-   Двунаправленный итератор
    
-   Итератор произвольного доступа
    
-   Итератор записи
    
-   Категория не определена
    

----------

К какой категории относится стандартный библиотечный итератор контейнера  `map`? Чтобы ответить, используйте документацию C++ по  [ссылке](https://ru.cppreference.com/)  или любой другой удобный вам ресурс. Верный ответ только один, не нужно отмечать все подкатегории..

-   Итератор чтения
    
-   Однонаправленный итератор
    
-   Двунаправленный итератор
    
-   Итератор произвольного доступа
    
-   Итератор записи
    
-   Категория не определена

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

----------

Какие операции должны поддерживать итераторы  `first`  и  `last`, передаваемые в эту функцию? Возможны несколько верных ответов.

```cpp
template <class InputIterator, class UnaryPredicate>
   InputIterator find_if (InputIterator first, InputIterator last, UnaryPredicate pred);

```

-   **(+)**  Инкремент
    
-   **(-)**  Декремент
    
-   **(+)**  Чтение
    
-   **(-)**  Запись
    

----------

Какие операции должны поддерживать итераторы  `first`  и  `last`, передаваемые в эту функцию? Возможны несколько верных ответов.

```cpp
template <class BidirectionalIterator, class UnaryPredicate>
  BidirectionalIterator partition (BidirectionalIterator first,
                                   BidirectionalIterator last, UnaryPredicate pred);

```

-   **(+)**  Инкремент
    
-   **(+)**  Декремент
    
-   **(+)**  Чтение
    
-   **(-)**  Запись
    

----------

К какой категории относится стандартный библиотечный итератор контейнера  `vector`? Чтобы ответить, используйте документацию C++ по  [ссылке](https://ru.cppreference.com/)  или любой другой удобный вам ресурс. Верный ответ только один, не нужно отмечать все подкатегории.

-   **(-)**  Итератор чтения
    
-   **(-)**  Однонаправленный итератор
    
-   **(-)**  Двунаправленный итератор
    
-   **(+)**  Итератор произвольного доступа
    
-   **(-)**  Итератор записи
    
-   **(-)**  Категория не определена
    

----------

К какой категории относится стандартный библиотечный итератор контейнера  `map`? Чтобы ответить, используйте документацию C++ по  [ссылке](https://ru.cppreference.com/)  или любой другой удобный вам ресурс. Верный ответ только один, не нужно отмечать все подкатегории..

-   **(-)**  Итератор чтения
    
-   **(-)**  Однонаправленный итератор
    
-   **(+)**  Двунаправленный итератор
    
-   **(-)**  Итератор произвольного доступа
    
-   **(-)**  Итератор записи
    
-   **(-)**  Категория не определена

</details>
