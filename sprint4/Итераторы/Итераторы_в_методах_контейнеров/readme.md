
<details>
<summary>Теория:</summary>

# Итераторы в методах контейнеров

Элементы любого контейнера можно перебрать, используя итераторы. Это прямое назначение итераторов. Зная место в контейнере, можно, например, удалить элемент или вставить новый. Итераторы позволяют не думать о порядковом номере элемента в контейнере. В этом уроке вы узнаете о возможностях итераторов в методах контейнера и научитесь обходить подводные камни при работе с ними.

### Метод Insert

Один из примеров использования итераторов в методах контейнеров — метод  `insert`. Он даёт возможность вставить элемент в определённое место в контейнере — перед итератором, который передадим в качестве параметра.

Рассмотрим пример. Применим уже известный вам алгоритм  `find`, чтобы найти всё в том же векторе языков С++. Этот алгоритм вернёт итератор на элемент С++ в векторе. Затем возьмём метод  `insert`, вставим в наш вектор предка С++ — язык С — и выведем результат:

```cpp
#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

template <typename It>
void PrintRange(It range_begin, It range_end) {
    for (auto it = range_begin; it != range_end; ++it) {
        cout << *it << " "s;
    }
    cout << endl;
}

int main() {
    vector<string> langs = {"Python"s, "Java"s, "C#"s, "Ruby"s, "C++"s};
    auto it = find(langs.begin(), langs.end(), "C++"s);
    langs.insert(it, "C"s);
    PrintRange(langs.begin(), langs.end());
}

```

Вот наш вектор:

```
Python Java C# Ruby C C++

```

Язык С добавился в вектор перед С++. Иначе говоря, элемент был добавлен перед итератором, переданным в качестве аргумента. Разберёмся, почему это удобно.

В нашем векторе было пять элементов и шесть возможных позиций итераторов. Если бы метод  `insert`  вставлял элемент после переданного итератора, вставить на первое место в контейнер было бы невозможно. Дело в том, что если передать в качестве параметра итератор  `begin`, элемент вставится на второе место. А при передаче итератора  `end`  возникла бы неопределённость. Элемента, на который указывает  `end`, в контейнере нет, и как вставить элемент после него — непонятно.

Поэтому логично делать вставку до переданного итератора. В этом случае вызов  `insert`  с итератором  `end`  равносилен для вектора методу  `push_back`.

Метод  `insert`  можно использовать ещё несколькими способами:

-   `container.insert(it, range_begin, range_end)`  — вставит полуинтервал от  `range_begin`  до  `range_end`  до позиции  `it`;
-   `container.insert(it, count, value)`  — вставит  `count`  раз элемент  `value`  до позиции  `it`;
-   `container.insert(it, {1, 2, 3})`  — вставит  `{1, 2, 3}`  до  `it`.

Если есть вставка, должно быть и удаление. В задачах к этому уроку вы самостоятельно разберётесь с методом  `erase`, который работает по аналогии с  `insert`.

### Важный эффект применения методов контейнера

Работая с итераторами, мы никак не модифицировали сам контейнер. Не меняли его размер, ничего не вставляли и не удаляли. Могли просто пройти по элементам, найти что-нибудь, поменять элементы местами, но контейнер при этом оставался неизменным. Итераторы сами по себе менять его не умеют. Итератор — всего лишь абстракция. Она подразумевает перемещение по контейнеру, а не изменение.

То есть раньше мы могли спокойно вызвать метод  `begin`, сохранить результат в локальную переменную, использовать какой-нибудь алгоритм и не переживать, что с переменной что-то случилось:

```cpp
#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

template <typename It>
void PrintRange(It range_begin, It range_end) {
    for (auto it = range_begin; it != range_end; ++it) {
        cout << *it << " "s;
    }
    cout << endl;
}

int main() {
    vector<string> langs = {"Python"s, "Java"s, "C#"s, "Ruby"s, "C++"s};
    // Присвоим локальной переменной значение итератора начала вектора
    auto it_begin = langs.begin();
    auto it_end = langs.end();
    auto it = find(it_begin, it_end, "C++"s);
    // Никаких проблем, все итераторы остались на своих местах
    PrintRange(it_begin, it);
    PrintRange(it, it_end);
}

```

Но теперь мы знаем методы, которые изменяют контейнер. Под капотом этих методов с контейнером может произойти всё что угодно. В том числе он может быть скопирован в другой контейнер, а исходный контейнер будет при этом разрушен, и мы, пользователи, никогда об этом не узнаем. Реализация этих методов для нас — «чёрный ящик», она инкапсулирована.

Поэтому запомните: если контейнер каким бы то ни было способом был изменён, возможно, что ранее использованные итераторы инвалидированы. Работать с ними уже нельзя. Итератор не знает, что с контейнером что-то произошло, и не может модифицировать сам себя. За это отвечает пользователь.

```cpp
#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

template <typename It>
void PrintRange(It range_begin, It range_end) {
    for (auto it = range_begin; it != range_end; ++it) {
        cout << *it << " "s;
    }
    cout << endl;
}

int main() {
    vector<string> langs = {"Python"s, "Java"s, "C#"s, "Ruby"s, "C++"s};
    // Присвоим локальной переменной значение итератора начала вектора
    auto it_begin = langs.begin();
    auto it_end = langs.end();
    auto it = find(it_begin, it_end, "C++"s);
    // Здесь контейнер изменяется, а вместе с ним и все его итераторы!
    langs.insert(it, "C"s);
    // Непредсказуемое поведение
    PrintRange(it_begin, it_end);
}
```

Мы не знаем, куда будет указывать локальная переменная после использования метода  `insert`. Нужно вызвать метод  `begin`  снова, чтобы гарантировать правильность работы кода:

```cpp
#include <algorithm>
#include <iostream>
#include <string>
#include <vector>

using namespace std;

template <typename It>
void PrintRange(It range_begin, It range_end) {
    for (auto it = range_begin; it != range_end; ++it) {
        cout << *it << " "s;
    }
    cout << endl;
}

int main() {
    vector<string> langs = {"Python"s, "Java"s, "C#"s, "Ruby"s, "C++"s};
    // Присвоим локальной переменной значение итератора начала вектора
    auto it_begin = langs.begin();
    auto it_end = langs.end();
    auto it = find(it_begin, it_end, "C++"s);
    // Здесь контейнер изменяется, а вместе с ним и все его итераторы!
    langs.insert(it, "C"s);
    // Обновим значения переменных
    it_begin = langs.begin();
    it_end = langs.end();
    // Теперь все точно сработает правильно
    PrintRange(it_begin, it_end);
}
```

Подробности о том, что происходит с итераторами после работы метода, лучше смотреть в документации. У каждого метода свои тонкости.

</details>

<details>
<summary>Задание 1:</summary>

## Задание 1

Напишите функцию-шаблон  `EraseAndPrint`. Она должна принимать контейнер и итератор на позицию, которую надо удалить. После этого  `EraseAndPrint`  должна выводить на первой строчке часть контейнера до удалённого элемента, а на второй строчке — часть контейнера после удалённого элемента.

### Пример использования

```cpp
int main() {
    vector<string> langs = {"Python"s, "Java"s, "C#"s, "Ruby"s, "C++"s};
    EraseAndPrint(langs, langs.begin());
}

```

### Пример вывода

```
// пустая строка
Java C# Ruby C++

```

### Подсказка

```cpp
template <typename Container, typename Iterator>
void EraseAndPrint(Container& container, Iterator it)
```

</details>

<details>
<summary>Задание 2:</summary>

## Задание 2

Кажется, пользователю функции удобнее просто сказать номер позиции на удаление, чем отправлять итератор. Модифицируйте функцию из прошлой задачи так, чтобы она принимала не итератор, а число — номер позиции.

### Пример использования

```cpp
int main() {
    vector<string> langs = {"Python"s, "Java"s, "C#"s, "Ruby"s, "C++"s};
    EraseAndPrint(langs, 2);
}

```

## Пример вывода

```cpp
Python Java
Ruby C++
```

### Подсказка

Если к итератору begin добавить нужное число, то он укажет точно туда, куда надо

</details>

<details>
<summary>Задание 3:</summary>

## Задание 3

Теперь сделайте так, чтобы функция принимала контейнер и три числа. Первое число — позиция, которая должна быть удалена. Второе и третье число — полуинтервал позиций в полученном после удаления контейнере. Они тоже должны быть удалены. Выведите на экран сначала контейнер после удаления первой позиции, а потом после удаления диапазона.

### Пример использования

```cpp
int main() {
    vector<string> langs = {"Python"s, "Java"s, "C#"s, "Ruby"s, "C++"s};
    EraseAndPrint(langs, 0, 0, 2);
}

```

### Пример вывода

```cpp
Java C# Ruby C++
Ruby C++
```

### Подсказка

Метод  `erase`  умеет принимать два параметра: итератор на начало удаляемого полуинтервала и итератор на его конец.

</details>
