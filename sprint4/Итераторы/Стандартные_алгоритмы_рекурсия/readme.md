<details>
<summary>Теория:</summary>

# Стандартные алгоритмы — рекурсия

Вы уже достаточно знаете об итераторах, чтобы освоить алгоритмы. Изучать их начнём с интересного явления в программировании — рекурсии. Она понадобится вам дальше, когда будете писать алгоритм для сортировки элементов в контейнере.

### Как работает рекурсия

Идея рекурсии проста. В тот момент, когда ваш алгоритм должен начать повторять одно и то же действие, он вызывает сам себя. По сути, рекурсия — это цикл, только действия цикла находятся в функции, которая на каждом шаге вызывает саму себя.

Но, как и у любого цикла, у рекурсии должно быть условие окончания работы, позволяющее функции не вызвать саму себя и тем самым начать процесс выхода.

Чтобы разобраться, вычислим факториал числа. Но сначала вспомним, что такое факториал:

```
0! = 1 (так принято)
1! = 1
2! = 1 * 2 = 2
3! = 1 * 2 * 3 = 6
4! = 1 * 2 * 3 * 4 = 24

```

Иначе говоря:

```
n! = (n-1)! * n

```

То есть, чтобы вычислить факториал числа, нужно узнать факториал числа на единицу меньше, а потом умножить его на само число. И делать это до тех пор, пока число не станет равно единице, ведь для неё факториал определён и равен ей самой — ничего считать не надо. Вычислим факториал в цикле. Тогда это выглядело бы так:

```cpp
uint64_t Factorial(int num) {
    int factorial = 1;
    while (num > 1) {
        factorial *= num;
        --num;
    }
    return factorial;

```

На каждом шаге умножаем факториал, полученный на предыдущем шаге, на число из текущего шага. Цикл заканчивается, когда доходим до единицы. Случай с нулём обрабатывается корректно, и мы просто не заходим в цикл. Нам важно написать цикл именно так. Это наглядно проиллюстрирует, как работает рекурсия.

Заменим цикл на рекурсивный вызов и получим:

```cpp
uint64_t Factorial(int num) {
    int factorial = 1;
    if (0 != num) {
        factorial = Factorial(num - 1) * num;
    }
    return factorial;
}

```

Чтобы увидеть происходящее в рекурсии, добавим вывод на экран:

```cpp
uint64_t Factorial(int num) {
    int factorial = 1;
    cout << "Текущее число = "s << num << endl;
    if (num != 0) {
        factorial = Factorial(num - 1) * num;
    }
    cout << "Значение факториала "s << factorial << "для числа "s << num << endl;
    return factorial;
}

```

При подсчёте факториала для числа четыре будет выведено следующее:

```cpp
Текущее число = 4
Текущее число = 3
Текущее число = 2
Текущее число = 1
Текущее число = 0
Значение факториала 1 для числа 0
Значение факториала 1 для числа 1
Значение факториала 2 для числа 2
Значение факториала 6 для числа 3
Значение факториала 24 для числа 4

```

Сначала как будто «падаем» в рекурсию до конца — пока не достигнем условия выхода. Дальше начинаем «раскручиваться»‎ обратно: возвращаем предыдущему вызову функции текущий результат, умножая его на число, потом опять возвращаем результат выше до тех пор, пока не вернёмся к первому вызову, где число было равно четырём. Делаем последние вычисления и возвращаем конечный результат.

В предыдущем спринте вы изучали раскрутку стека. Стек функций показывает, какие функции в каком порядке были вызваны. К этой информации можно обратиться во время отладки программы. Но внутри стека сохраняются и все данные о локальных переменных и аргументах каждого вызова. То есть несмотря на то, что функция вызывает сама себя, на самом деле это ничем не отличается от вызова разных функций. На стеке будут храниться аргументы и переменные каждого конкретного вызова.

Когда рекурсивная функция делает  `return`  или просто заканчивает своё выполнение, если возвращаемый тип  `void`, возвращаемся по стеку к предыдущему вызову. Все данные переменных и аргументов в стеке останутся в том виде, в каком они были при вызове функции самой себя.

Посмотрим, что будет, если условие выхода не выполнится. Предположим, мы написали его неправильно:

```cpp
uint64_t Factorial(int num) {
    int factorial = 1;
    cout << "Текущее число = "s << num << endl;
    // обратите внимание на изменение в условии выхода
    if (num != 1) {
        factorial = Factorial(num - 1) * num;
    }
    cout << "Значение факториала "s << factorial << "для числа "s << num << endl;
    return factorial;
}

```

Если теперь попытаемся вычислить факториал нуля, функция будет вызывать себя бесконечно. Это приведёт к тому, что стек функций станет слишком большим, чтобы храниться в памяти, и программа не сможет продолжить работу.

### Как работать с рекурсией

Хорошего программиста отличают не тайные знания о хитростях языка и не крутейшая среда разработки. Самый умный программист никогда не пишет код сразу. Первое, что он (или она) делает — берёт ручку, листок бумаги и создаёт так называемый «псевдокод». Обдумывает, как программа, класс или функция должны выглядеть. Рисует квадратики и стрелочки, пишет на своем родном, человеческом, языке. Пытается понять каждую деталь, которую ему предстоит написать. Потом меняет угол зрения. Представляет себя пользователем своей программы, придумывает, какие тесты может сделать. Записывает их и там же, на бумаге, ручкой проверяет, будет ли его программа работать для этих тестов. После этого хороший программист открывает лучшую среду разработки и пишет свой гениальный код.

Программист похуже в это время уже третий раз переписывает свою программу, правит баги, проходит отладку и снова обнаруживает что-нибудь, о чём не подумал (или не подумала).

Рекурсия позволяет писать красивые, элегантные и лаконичные решения. Но планировать её следует тщательно. Иначе в случае ошибки вы рискуете получить не просто неверное значение, а переполнение стека и зависание программы. Кроме того, несмотря на изящество, для рекурсии сложно делать отладку. Каждый раз нужно внимательно следить, в каком вызове функции вы находитесь. Особо коварные баги любят прятаться в рекурсиях, зная, что найти их там тяжело.

Перед тем как писать рекурсию, возьмите листок бумаги и препарируйте свою задачу. Ответьте на три вопроса:

1.  **Какие параметры она будет принимать?**  Часто верные параметры — уже половина решения. В нашем примере всё просто — это число, для которого ищем факториал.
2.  **Какие действия должна совершить функция на каждом шаге?**  В нашем случае это просто умножение текущего числа на результат факториала для числа, меньшего на единицу.
3.  **Каково условие завершения?**  В случае с факториалом, если число стало равно одному, никакие вычисления дальше не нужны, и можем начинать «‎раскручиваться» обратно.

Когда ответы на все три вопроса для вас ясны, и вы подумали про тесты, приступайте к написанию кода. Лучшие рекурсивные решения — это тщательно спланированные.

</details>

<details>
<summary>Задание 1:</summary>

## Задание 1

Напишите рекурсивную функцию  `Fibonacci`, которая принимает порядковый номер числа Фибоначчи и возвращает значение этого числа.

Ряд Фибоначчи выглядит так:

`0, 1, 1, 2, 3, 5, 8, 13, ...`,

где каждое n-ое число — это сумма двух предыдущих чисел.

Как и любую рекурсивную задачу, эту можно решить циклом. Но здесь от вас ожидается именно рекурсивное решение.

### Пример использования

```cpp
int main() {
    cout << Fibonacci(6) << endl;
}

```

## Пример вывода

```
8

```

### Подсказка

В каждой задаче с рекурсией нужно определить три важные вещи:

1.  Какие параметры принимает функция? Здесь сложности нет, она просто принимает порядковый номер.
2.  Какие действия должна совершить функция на каждом шаге? С этим здесь вы справитесь сами.
3.  Каково условие завершения? А может быть их тут вообще два? Что если аргумент равен нулю? А если единице?

</details>

<details>
<summary>Задание 2:</summary>

## Задание 2

Напишите рекурсивную функцию  `IsPowOfTwo`, которая возвращает  `true`, если число — неотрицательная степень двойки, или  `false`, если оно таковым не будет. Операцией возведения в степень в этой задаче пользоваться нельзя. Единица является нулевой степенью двойки (2^0 = 1), и ответ должен быть  `true`.

### Пример использования

```cpp
int main() {
    int result = IsPowOfTwo(1024);
    cout << result << endl;
}

```

## Пример вывода

В случае  `true`  на экран выводится 1, в случае  `false`  — 0. В нашем случае 1024 — это степень двойки.

```
1

```

### Подсказка

1.  **Какие параметры принимает функция?**  Проверяемое число.
2.  **Какие действия должна совершить функция на каждом шаге?**  Если число — степень двойки, оно должно делиться на два. Результат деления тоже должен быть степенью двойки. Проверить остаток от деления на два можно, используя оператор %.
3.  **Каково условие завершения?**  Действуйте аналогично предыдущей задаче.

</details>

<details>
<summary>Задание 3:</summary>

## Задание 3

А теперь по-настоящему серьёзный вызов: Ханойская башня — популярная головоломка XIX века по версии Википедии.

Даны три стержня. На один из них нанизаны восемь колец разного размера. Кольца лежат меньшее на большем. Задача в том, чтобы перенести пирамиду из восьми колец на другой стержень за наименьшее число ходов. За один раз можно переносить только одно кольцо, причём нельзя класть большее кольцо на меньшее.

Решите эту задачу рекурсивным методом. Напишите функцию  `SolveHanoi`, которая принимает ссылку на вектор из трёх стержней-башен. На первой башне надето определённое количество дисков — не обязательно восемь, как в классической задаче. Количество можно узнать, воспользовавшись методом  `GetDisksNum`. Класс  `Tower`  уже имеет некоторые методы или части методов. Другие методы вы можете дописывать так, как вам нужно для решения. В результате работы функции  `SolveHanoi`  все диски в правильном порядке должны оказаться на третьей башне.

Чтобы решить задачу, вспомните, что во все методы класса неявно передаётся указатель на объект  `this`. А если применить оператор  `*`, можно получить доступ к самому элементу. Чтобы освежить в памяти детали, вернитесь к уроку «Перегрузка операций присваивания».

### Пример использования

```cpp
int main() {
    int towers_num = 3;
    int disks_num = 3;
    vector<Tower> towers;
    // добавим в вектор три пустые башни
    for (int i = 0; i < towers_num; ++i) {
        towers.push_back(0);
    }
    // добавим на первую башню три кольца
    towers[0].SetDisks(disks_num);

    SolveHanoi(towers);
}

```

### Пример результата работы

Ниже не пример вывода на экран — в задаче он не требуется. Это пример того, что должно произойти с вектором башен после вызова  `SolveHanoi`:

```
Вектор башен до перемещения:
Башня 1: 3 2 1
Башня 2: 0 0 0
Башня 3: 0 0 0

Вектор башен после перемещения:
Башня 1: 0 0 0
Башня 2: 0 0 0
Башня 3: 3 2 1

```

### Подсказка

1.  **Какие параметры принимает функция?**  Здесь это самое интересное. Функция  `SolveHanoi`  сама по себе рекурсивной не будет. Используйте другую. Вам пригодится это:
    
    ```cpp
    // disks_num - количество перемещаемых дисков
    // destination - конечная башня для перемещения
    // buffer - башня, которую нужно использовать в качестве буфера для дисков
    void MoveDisks(int disks_num, Tower& destination, Tower& buffer) {
        if (// условие выхода ещё не выполнено) {
            // действия из шага рекурсии
        }
    }
    
    
    void SolveHanoi(vector<Tower>& towers) {
        int disks_num = towers[0].GetDisksNum();
        // запускаем рекурсию
        // просим переложить все диски на последнюю башню
        // с использованием средней башни как буфера
        towers[0].MoveDisks(disks_num, towers[2], towers[1]);
    }
    
    ```
    
2.  **Какие действия должна совершить функция на каждом шаге?**  Препарируйте задачу. Порисуйте диски, найдите повторяющийся паттерн. Скорее всего, он будет состоять из нескольких действий.
    
3.  **Каково условие завершения?**  Всё просто — как только дисков не осталось, не нужно ничего больше перемещать.

</details>
