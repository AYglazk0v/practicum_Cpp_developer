<details>
<summary>Теория + тестирование:</summary>

# Стандартные алгоритмы из

Вы уже знакомы с некоторыми алгоритмами из стандартной библиотеки  `<algorithm>`. Теперь вы можете расширить знания — освоить алгоритмы, в применении которых нужны итераторы.

Алгоритмов в библиотеке много. Работая над реальными задачами, вы не раз будете самостоятельно разбираться с алгоритмами, библиотеками и методами контейнеров. Прямо сейчас вы научитесь это делать, используя официальную документацию C++  [по ссылке](https://ru.cppreference.com/w/). Возьмём алгоритм  `remove_if`.

Откройте страницу  [https://ru.cppreference.com/w/cpp/algorithm/remove](https://ru.cppreference.com/w/cpp/algorithm/remove).

Казалось бы, из названия алгоритма следует функционал. Но это не совсем так. Посмотрите, как выглядит заголовок функции.  `remove`  и  `remove_if`  принимают полуинтервал итераторов, из которого должны быть удалены элементы. Удаляются они в следующих ситуациях:

-   если равны некоему значению (в случае с  `remove`);
-   если функция, переданная в  `remove_if`, возвращает  `true`.

Контейнер в алгоритм не передаётся, только его итераторы.

----------

Какой вывод в общем случае можно сделать из того, что сам контейнер в функцию не передаётся?

-   Функция может сама определить по переданным в неё итераторам, какой контейнер используется
    
-   Библиотечные функции не идеальны — разработчики забыли добавить контейнер в качестве аргумента.
    
-   Функция работает с любыми контейнерами.
    
-   Размер и количество элементов в контейнере изменяться не будут.
    

----------

Прочитайте описание работы алгоритма  `remove`  в официальной документации  [по ссылке](https://ru.cppreference.com/w/cpp/algorithm/remove)  и выберите верное утверждение.

-   Функция заполняет вектор итераторов, указывающих на элементы, которые надо удалить. Таким образом контейнер не изменяется, но у пользователя появляется достаточно информации, чтобы удалить элементы далее самостоятельно, используя возвращенный из функции вектор.
    
-   Алгоритм сдвигает все элементы, подлежащие удалению, в конец контейнера. При этом относительный порядок элементов, которые не удаляются, остается таким же, как и был до вызова алгоритма. Функция возвращает итератор, указывающий на первый “удаленный” элемент, или другими словами, на новый конец диапазона.
    
-   Алгоритм помечает элементы на удаление, и в дальнейшем этот же контейнер можно передать в соответствующий контейнеру метод erase, который удалит помеченные элементы.Отлично, теперь вы умеете получать информацию из официальной документации C++, понимаете, что такое контейнеры, шаблоны и типы итераторов, и можете найти в библиотеке  `<algorithm>`  [по ссылке](https://ru.cppreference.com/w/cpp/header/algorithm)  нужные алгоритмы. То есть освоить её самостоятельно. А чтобы вам было не так скучно, решите задачи по ходу.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

----------

Какой вывод в общем случае можно сделать из того, что сам контейнер в функцию не передаётся?

-   **(-)**  Функция может сама определить по переданным в неё итераторам, какой контейнер используется
    
    -   К сожалению (или всё-таки к счастью), мы не можем получить информацию о контейнере по его итераторам.
-   **(-)**  Библиотечные функции не идеальны — разработчики забыли добавить контейнер в качестве аргумента.
    
    -   Эй, разработчики не настолько забывчивые!
-   **(-)**  Функция работает с любыми контейнерами.
    
    -   Это не совсем верно, так как различные контейнеры имеют итераторы разных категорий. Иногда действий, которые можно совершить над итератором конкретного контейнера, бывает недостаточно для использования алгоритма. Например, алгоритм  `sort`  требует в качестве аргументов итераторы категории произвольного доступа, но далеко не все итераторы библиотечных контейнеров удовлетворяют этому требованию.
-   **(+)**  Размер и количество элементов в контейнере изменяться не будут.
    
    -   Это верный ответ. Контейнер не изменится. В нём может поменяться порядок элементов и их значения, но свойства контейнера останутся теми же. Через итераторы получить к ним доступ невозможно.

----------

Прочитайте описание работы алгоритма  `remove`  в официальной документации  [по ссылке](https://ru.cppreference.com/w/cpp/algorithm/remove)  и выберите верное утверждение.

-   **(-)**  Функция заполняет вектор итераторов, указывающих на элементы, которые надо удалить. Таким образом контейнер не изменяется, но у пользователя появляется достаточно информации, чтобы удалить элементы далее самостоятельно, используя возвращенный из функции вектор.
    
-   **(+)**  Алгоритм сдвигает все элементы, подлежащие удалению, в конец контейнера. При этом относительный порядок элементов, которые не удаляются, остается таким же, как и был до вызова алгоритма. Функция возвращает итератор, указывающий на первый “удаленный” элемент, или другими словами, на новый конец диапазона.
    
-   **(-)**  Алгоритм помечает элементы на удаление, и в дальнейшем этот же контейнер можно передать в соответствующий контейнеру метод erase, который удалит помеченные элементы.

</details>

<details>
<summary>Задание 1:</summary>

## Задание

Напишите функцию  `GetPermutations`, которая получает в качестве аргумента итератор на начало контейнера и итератор на его конец и возвращает вектор строк со всеми возможными перестановками элементов этого контейнера, выведенными через пробел.

Мы немного обновили для вашего удобства функцию  `PrintRange`. Теперь это функция  `PrintRangeToString`, и она печатает не на экран, а в строку. Используйте в этой задаче эту обновлённую версию.

### Пример использования

```cpp
int main() {
    vector<int> permutation(3);
    // iota             -> http://ru.cppreference.com/w/cpp/algorithm/iota
    // Заполняет диапазон последовательно возрастающими значениями
    iota(permutation.begin(), permutation.end(), 1);

    auto result = GetPermutations(permutation.begin(), permutation.end());
    for (const auto& s : result) {
        cout << s;
    }
    return 0;
}

```

### Пример вывода

```
3 2 1
3 1 2
2 3 1
2 1 3
1 3 2
1 2 3

```

### Подсказка

Разберитесь с этими строками-ребусами и найдёте алгоритмы, которые помогут вам решить задачу. 1. esrever

2.

```
n o i t a t u m r e p _ v e r p

n o i t a t u m r e p _ v e p r

n o i t a t u m r e p _ r v p e

n o i t a t u m r e p _ r v e p

n o i t a t u m r e p _ r p v e

n o i t a t u m r e p _ r p e v

n o i t a t u m r e p _ r e v p

n o i t a t u m r e p _ r e p v

n o i t a t u m r e p _ p v r e
```

</details>

<details>
<summary>Задание 2:</summary>

## Задача 2

Напишите функцию-шаблон  `MergeSort`. Она должна принимать итераторы категории произвольного доступа, указывающие на начало и конец контейнера, который нужно отсортировать. Сортируйте по возрастанию. Считайте определённой операцию сравнения между элементами.

Есть много разных способов сортировать, но в этой задаче реализуйте сортировку методом слияния. Алгоритм такой сортировки:

1.  Разделить контейнер на две примерно равные части;
2.  Отсортировать каждую из этих частей;
3.  Объединить две части так, чтобы сортировка сохранилась.

Пункт два в свою очередь решается теми же шагами. Этот алгоритм может быть реализован как рекурсивно, так и итеративно (с применением цикла).

Не используйте стандартный алгоритм сортировки  `sort`  и всех его «‎родственников»‎ — это будет слишком просто.

### Пример использования

```cpp
int main() {
    vector<int> test_vector(10);

    // iota             -> http://ru.cppreference.com/w/cpp/algorithm/iota
    // Заполняет диапазон последовательно возрастающими значениями
    iota(test_vector.begin(), test_vector.end(), 1);

    // random_shuffle   -> https://ru.cppreference.com/w/cpp/algorithm/random_shuffle
    // Перемешивает элементы в случайном порядке
    random_shuffle(test_vector.begin(), test_vector.end());

    // Выводим вектор до сортировки
    PrintRange(test_vector.begin(), test_vector.end());

    // Сортируем вектор с помощью сортировки слиянием
    MergeSort(test_vector.begin(), test_vector.end());

    // Выводим результат
    PrintRange(test_vector.begin(), test_vector.end());

    return 0;
}

```

### Пример вывода

```
9 2 10 3 1 6 8 4 5 7
1 2 3 4 5 6 7 8 9 10

```

### Подсказка

Предположим, наш диапазон состоит из двух элементов.

1.  Разделите его пополам. В каждой части получилось по одному элементу.
2.  Каждая из половин уже отсортирована, ведь она состоит всего из одного элемента.
3.  Найдите подходящий алгоритм, который соединяет два отсортированных диапазона.

</details>
