<details>
<summary>Введение:</summary>

# Введение

Вы изучаете не только синтаксис языка и его библиотеки. Большую часть курса занимает эффективность кода. Программы на C++ быстрые, поэтому его широко используют для обработки видео на YouTube и для обработки запросов в поисковой системе Яндекс.

Но чтобы язык мог показать себя во всей красе, программы нужно уметь готовить. Незаметные для неискушенного взгляда изменения могут значительно ускорить код. В этой теме вы узнаете, как такие изменения вносить.

</details>

<details>
<summary>Теория+тестирование:</summary>

# Временные объекты

Вы изучаете не только синтаксис языка и его библиотеки. Большую часть курса занимает эффективность кода. Программы на C++ быстрые, поэтому его широко используют для обработки видео на YouTube и для обработки запросов в Яндекс.Поиске. Но чтобы язык мог показать себя во всей красе, программы нужно уметь готовить.

Незаметные для неискушенного взгляда изменения могут значительно ускорять код. Вы уже знаете много приёмов ускорения, включая правильный подбор контейнеров, использование профилировщика и даже учёт кэширования процессора. Рассмотрим пример:

```cpp
#include <iostream>
#include <string>

using namespace std;

class Number {
private:
    int a_;

public:
    Number() {
        cout << "Default Ctor"s << endl;
    }
    Number(int num)
        : a_(num) 
    {
        cout << "Ctor(int)"s << endl;
    }
    Number(const Number& other)
        : a_(other.a_) 
    {
        cout << "Copy Ctor"s << endl;
    }
    ~Number() {
        cout << "Dtor"s << endl;
    }
    Number& operator=(const Number& other) {
        a_ = other.a_;
        cout << "Op="s << endl;
        return *this;
    }
    Number operator+(const Number& second) {
        cout << "Op+" << endl;
        return a_ + second.a_;
    }
};

int main() {
    Number a(1), b(1), c;
    c = a + b;
    cout << "End of calculations"s << endl;
}

```

----------

Попробуйте угадать, что будет выведено на экран:

-   ```cpp
    Ctor(int)
    Ctor(int)
    Default Ctor
    Op+
    Ctor(int)
    Op=
    Dtor
    End of calculations
    Dtor
    Dtor
    Dtor
    
    ```
    
-   ```cpp
    Ctor(int)
    Ctor(int)
    Default Ctor
    Op+
    Ctor(int)
    Ctor(int)
    Dtor
    Op=
    Dtor
    End of calculations
    Dtor
    Dtor
    Dtor
    
    ```
    
-   ```cpp
    Ctor(int)
    Ctor(int)
    Op+
    Ctor(int)
    End of calculations
    Dtor
    Dtor
    Dtor
    
    ```
    

Первый вариант ответа отличается от второго тем, что конструктор и деструктор вызываются четыре раза. При этом очевидных объектов только три:  `a`,  `b`  и  `c`. Четвёртый — временный — объект возникает здесь:

```cpp
return a_ + second.a_;

```

У этого объекта нет имени. Невозможно узнать его адрес. Но он должен быть создан, чтобы функция могла его вернуть. После этого вызывается  `operator=`, объект копируется в объект  `c`  и сразу уничтожается.

Программа работает, но создание временного объекта, а потом ещё и его копирование выглядят лишними. Совсем неудобно получилось бы, если объекты класса  `Number`  были тяжёлыми, их конструктор и копирование были сложнее, чем O(1), в процессе динамически выделялась память, могли возникнуть исключения.

В языке С++ есть механизмы, которые помогают избавиться от лишних действий. Вы научитесь их замечать и применять в ближайших уроках.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Попробуйте угадать, что будет выведено на экран:

-   **(+)**  `cpp Ctor(int) Ctor(int) Default Ctor Op+ Ctor(int) Op= Dtor End of calculations Dtor Dtor Dtor`

> Всё верно. Вы, случайно, не компилятор?

-   **(-)**  `cpp Ctor(int) Ctor(int) Default Ctor Op+ Ctor(int) Ctor(int) Dtor Op= Dtor End of calculations Dtor Dtor Dtor`

> Получилось, что созданных объектов больше, чем разрушенных. Но судя по коду программы, такого быть не может.

-   **(-)**  `cpp Ctor(int) Ctor(int) Op+ Ctor(int) End of calculations Dtor Dtor Dtor`

> Хотелось бы, чтобы вы были правы, но в этом примере создаётся не три объекта, а четыре.

</details>
