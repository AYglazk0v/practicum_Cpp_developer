
<details>
<summary>Теория + тестирование:</summary>

# Copy elision и NRVO

В этом уроке вы узнаете о двух механизмах оптимизации, которые применяет компилятор, чтобы избежать лишних действий. Компилятор умеет их использовать вне зависимости от действий программиста. Но знать об этих механизмах важно: они таят в себе небольшие опасности, которых нужно избегать.

### Copy elision

Вернёмся к примеру из прошлого урока:

```cpp
...
Number operator+(const Number& second) {
    cout << "Op+" << endl;
    return a_ + second.a_;
}
...

int main() {
    ...
    c = a + b;
    ...
}

```

Из функции возвращался временный объект, который потом присваивался объекту  `c`  и разрушался сразу после этого:

```cpp
Op+
Ctor(int)
Op=
Dtor

```

Но присмотритесь. Объект, который создаётся в  `return`, и объект, возвращаемый из функции, совершенно не обязаны быть одним и тем же объектом. Если строго следовать тому, что написано в коде, порядок действий должен быть таким:

1.  Из функции нужно вернуть тип  `Number`, выражение  `a_ + second.a_`  имеет тип  `int`. Компилятор знает, что делать — вызвать конструктор  `Ctor(int)`. Получается первый временный объект.
2.  Объект — результат работы функции — создан. Но теперь нужно его вернуть. Вызывается конструктор копирования, и первый временный объект копируется во второй, а второй передаётся в  `main`.
3.  Первый временный объект разрушается.
4.  Второй временный объект копируется через оператор присваивания в объект  `c`.
5.  Второй временный объект разрушается.

Странно, что в выводе на экран процесс не виден. Дело в том, что в этом случае работает механизм, призванный защитить программу от лишних вызовов конструктора копирования. Посмотрите на второй шаг — его компилятор оптимизировал.

Этот механизм называется “copy elision”. В русскоязычных текстах иногда используют термин «пропуск копии»‎, но чаще употребляется английское название.

В примере вы встретились с copy elision в ситуации, когда временный объект возвращается из функции, и компилятор предпочитает не вызывать лишний раз конструктор копирования.

----------

Посмотрите на примеры и разберитесь, где ещё сработает этот вид оптимизации:

```cpp
// класс кота Шрёдингера
class SchrodingerCat {
    ...
}

// класс Коробки
class Box {
    ... 
    // кота из коробки можно вытащить
    SchrodingerCat GetCat() {
        is_empty_ = true;
        return box.cat;
    }
    
    bool HasCat() {
        return !is_empty_;
    }
    ...
}

int main() {
    // пока в коробку не заглянешь,
    // не узнаешь, есть ли там кот
    Box black_box(); // (1)
    if (black_box.HasCat()) { // (2)
        SchrodingerCat fluffy = black_box.GetCat(); // (3)
    }
}

```

-   Когда вызывается конструктор коробки, появляется временный объект. Потом он копируется в создаваемый объект.
    
-   Чтобы обратиться к методу  `HasCat`, коробку сначала надо скопировать, используя конструктор копирования. Так происходит при обращении к любым методам класса.
    
-   Кот  `fluffy`  инициализируется при создании временным объектом. Кажется, здесь можно избежать копирования.
    

В первом случае временный объект возвращался из функции и присваивался уже существующей переменной. Конструктор копирования пропускался, но вызывался оператор присваивания. Здесь создаётся новая переменная, и в момент её инициализации конструктор копирования не вызывается.

Резюмируем. Copy elision — это вид оптимизации, позволяющий компилятору пропустить вызов конструктора копирования:

-   при возврате из функции временного объекта;
-   при инициализации объекта временным объектом.

### NRVO

Немного поменяем пример. Для вас уже очевидно, что имеет место copy elision:

```cpp
SchrodingerCat GetCat() {
    is_empty_ = true;
    return SchrodingerCat(); // копирование временного объекта не произойдет
}

```

Внесём ещё одно изменение:

```cpp
SchrodingerCat GetCat() {
   SchrodingerCat cat;
   cout << "Кажется, в коробке есть кот!"s << endl;
   is_empty_ = true;
   return cat;
}
...
int main() {
   ...
   auto fluffy = box.GetCat();
   ...
}

```

----------

`cat`  — временный объект?

-   Нет.
    
-   Да, ведь его срок под этим небом слишком короток, чтобы считаться постоянным объектом. И вообще, коты в коробках живут недолго.
    

NRVO,  **или**  Named Return Value Optimization — второй вид оптимизации компилятора, помогающий избегать лишних копирований. Как видно из названия, речь идёт о возвращении из функции некой именованной переменной.

### Там, где живут чудовища

Но не всё так гладко, как может показаться. Ниже — список опасностей и места, где они поджидают неопытных программистов.

1.  Копирование копированию рознь.
    
    Будем доставать из коробки пару котов и добавим вывод на экран:
    
    ```cpp
    class SchrodingerCat {
    public:
        SchrodingerCat() = default;
        SchrodingerCat(const SchrodingerCat& other) {
            cout << "Cctor"s << endl;
        }
        SchrodingerCat& operator=(const SchrodingerCat& other) {
            cout << "Op="s << endl;
            return *this;
        }
        ~SchrodingerCat() = default;
    };
    
    
    class Box {
    public:
        // достанем пару котов
        pair<SchrodingerCat, SchrodingerCat> GetCats() {
            SchrodingerCat cat1;
            SchrodingerCat cat2;
            is_empty_ = true;
            // временная пара котов -> пара, которая возвращается из функции
            return {cat1, cat2};
        }
        bool HasCat() {
            return !is_empty_;
        }
    
    
    private:
        bool is_empty_ = false;
    };
    
    
    int main() {
        Box black_box;
        if (black_box.HasCat()) {
            pair<SchrodingerCat, SchrodingerCat> cat_pair;
            // копируем пару котов в переменную cat_pair
            cat_pair = black_box.GetCats();
        }
    }
    
    ```
    
    В этом примере можно было ожидать, что конструктор копирования не вызовется. Возвращаем временный объект из функции по значению — это совпадает с одним из случаев, когда ожидается copy elision. Но из  `cat1`  и  `cat2`  должна быть создана пара. Именно там конструктор копирования всё-таки будет вызван. Этот случай компилятор не может оптимизировать. Результат вывода на экран:
    
    ```cpp
    Cctor
    Cctor
    Op=
    Op=
    
    ```
    
2.  Не всё, что кажется временным, — временно. Поле временного объекта — не временный объект. Поэтому copy elision в этом случае работать не будет. Если возвращаете из функции значение поля, задумайтесь, насколько дорого вам будет обходиться его копирование.
    
3.  Copy elision полезен, но коварен. Если конструктор копирования или деструктор включают в себя действия, результат которых важен в дальнейшем, компилятор не обратит на это внимания, и действие совершено не будет.
    
4.  Copy elision и NRVO позволяют пропустить вызов конструктора копирования, но конструктор копирования у класса объекта должен существовать. Иначе говоря, этот код не скомпилируется:
    

```cpp
class SchrodingerCat {
	...
	// негоже копировать котов
	SchrodingerCat (const SchrodingerCat& other) = delete;
	...
}

class Box {
	... 
	SchrodingerCat GetCat() {
		SchrodingerCat cat();
		cout << "Кажется, в коробке есть кот!"s << endl;
		is_empty_ = true;
		// вызов конструктора копирования будет пропущен,
		// но конструктор удалён,
		// возникнет ошибка компиляции
		return cat;
	}
	...
}

```

----------

Кажется, в целом компилятор отлично справляется и без дополнительных усилий программиста.

-   Вот именно, где ссылка на следующий спринт?
    
-   Кажется, вы что-то не договариваете.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Посмотрите на примеры и разберитесь, где ещё сработает этот вид оптимизации:

```cpp
// класс кота Шрёдингера
class SchrodingerCat {
    ...
}

// класс Коробки
class Box {
    ... 
    // кота из коробки можно вытащить
    SchrodingerCat GetCat() {
        is_empty_ = true;
        return box.cat;
    }
    
    bool HasCat() {
        return !is_empty_;
    }
    ...
}

int main() {
    // пока в коробку не заглянешь,
    // не узнаешь, есть ли там кот
    Box black_box(); // (1)
    if (black_box.HasCat()) { // (2)
        SchrodingerCat fluffy = black_box.GetCat(); // (3)
    }
}

```

-   **(-)**  Когда вызывается конструктор коробки, появляется временный объект. Потом он копируется в создаваемый объект.

> При конструировании объекта создаётся один объект, а не два. Ничего не копируется, и copy elision сработать негде.

-   **(-)**  Чтобы обратиться к методу  `HasCat`, коробку сначала надо скопировать, используя конструктор копирования. Так происходит при обращении к любым методам класса.

> К счастью, объект не нужно копировать. Он передаётся в метод через указатель  `this`.

-   **(+)**  Кот  `fluffy`  инициализируется при создании временным объектом. Кажется, здесь можно избежать копирования.

> Абсолютно верно! Это второй случай, когда copy elision позволяет избежать ненужного копирования.

----------

`cat`  — временный объект?

-   **(+)**  Нет.
    
-   **(-)**  Да, ведь его срок под этим небом слишком короток, чтобы считаться постоянным объектом. И вообще, коты в коробках живут недолго.
    

----------

Кажется, в целом компилятор отлично справляется и без дополнительных усилий программиста.

-   **(-)**  Вот именно, где ссылка на следующий спринт?

> Не спешите. Есть многое на свете, друг Горацио, что и не снилось нашим мудрецам.

-   **(+)**  Кажется, вы что-то не договариваете.

> Компилятор старается, но не может избавиться от всех копирований. Чаще ему всё-таки нужна наша помощь.

</details>
