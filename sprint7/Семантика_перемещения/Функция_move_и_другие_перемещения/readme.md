<details>
<summary>Теория + тестирование:</summary>

# Функция move и другие перемещения

В этом уроке вы познакомитесь:

-   с огромным слоном, который хочет вернуться к своим родственникам;
-   с побочными эффектами, подстерегающими его на пути;
-   с тем, как с этими побочными эффектами бороться;
-   а также с группой смелых воинов, которых ожидает неминуемая гибель.

Перед дальнейшим чтением можете придумать слону имя, чтобы мысленно к нему обращаться во время урока.

### Слон большой, серый, одна штука

Вы уже знаете, как компилятор справляется с лишними копированиями и ускоряет код даже без ведома программиста. Но компилятор не панацея от всех бесполезных действий.

Посмотрите на пример:

```cpp
using WhiteElephant = string;

// функция, которая умеет делать очень больших слонов 
WhiteElephant BuyElephant() {
    return WhiteElephant(100000000, 'a');
}

int main() {
    vector<WhiteElephant> crowd_of_elephants;
    WhiteElephant heavy_elephant = BuyElephant();
    crowd_of_elephants.push_back(heavy_elephant);
}

```

Здесь создаётся  `crowd_of_elephants`  — толпа слонов. Но в начале она пустая. Пользователь покупает слона и сохраняет его в переменную  `heavy_elephant`. После этого слон добавляется в толпу. Всё просто, и не такое видели. Но в момент копирования  `heavy_elephant`  в толпу слонов станет двое. Один теперь в толпе с другими слонами, а второй остался в переменной  `heavy_elephant`. Вряд ли покупатель слонов хотел копировать животных.

# Осторожно! Спойлеры к фильму «Престиж»

В фильме «Престиж» весь сюжет построен как раз на этой проблеме. Герой Хью Джекмана хотел бы переместиться, а вместо этого машина Теслы его копирует. После этого сразу же тот фокусник, которого копировали, должен погибнуть, чтобы в мире не оказалось двух копий одного Хью Джекмана.В языке С++ есть способ, позволяющий не размножать слонов и другие объекты там, где не нужно. Этот метод использует move-семантику. Вместо семантики копирования — один слон в толпе, второй у хозяина — можно использовать семантику перемещения: забрать слона у хозяина и поместить в толпу.

Если изменим код так, чтобы купленный слон не сохранялся в переменную  `heavy_elephant`, а напрямую передавался в метод  `push_back`, временный слон, вернувшийся после  `BuyElephant`  будет напрямую перемещён в толпу.

```cpp
crowd_of_elephants.push_back(BuyElephant());

```

Компилятор видит, что имеет дело с временным объектом, и понимает, что объект будет уничтожен сразу после переноса в вектор. Поэтому компилятор не копирует объект, а переносит его.

Рассмотрим эту идею чуть глубже. Внутри объекта  `WhiteElephant`  лежит указатель на место в памяти, где последовательно расположены элементы. Чтобы скопировать элемент, нужно пройти по всем элементам и создать их копии. Но если компилятор знает, что объект временный, он может просто забрать указатель на элементы и перенести его в объект внутри вектора.

Передавая в функции временные объекты, программисты делают код не только более лаконичным, но и более быстрым.

### Нет ничего более постоянного, чем временное

Посмотрим на ситуацию с точки зрения владельца слона. Я, гордый обладатель редкого вида слонов, собираюсь отпустить своё приобретение в саванну к сородичам. Но сначала хочу совершить с ним прогулку. То есть мне нужно сохранить своего слона в переменную:

```cpp
int main() {
    vector<WhiteElephant> crowd_of_elephants;
    // купил слона
    WhiteElephant heavy_elephant = BuyElephant();
    // гуляю и общаюсь с новым большим другом
    SmallWalk(heavy_elephant);
    // о нет! опять слонов стало два! один у меня, один в толпе
    crowd_of_elephants.push_back(heavy_elephant);
}

```

Не может быть, чтобы не было способа в этом случае избежать раздвоения слонов при копировании.

----------

-   Вариант есть. Пусть  `SmallWalk`  возвращает моего слона обратно.
    
-   Вариантов нет. Но ведь лишний слон всегда может пригодиться в хозяйстве.
    
-   Вариант есть, но я пока его не знаю.
    

Чтобы сказать компилятору, что объект в будущем не понадобится, и его можно не копировать, а перенести, используют специальную функцию  `move`. Находится она в библиотеке  `<utility>`:

```cpp
#include <utility>
...
int main() {
    vector<WhiteElephant> crowd_of_elephants;
    WhiteElephant heavy_elephant = BuyElephant();
    SmallWalk(heavy_elephant);
    // я отпускаю слона на волю
    crowd_of_elephants.push_back(move(heavy_elephant));
}

```

Функция  `move`  позволит хозяину слона сообщить компилятору, что слон больше не нужен, и можно его просто перенести. При этом объект  `heavy_elephant`  остался у хозяина, но никто не гарантирует, что находится внутри объекта. Скорее всего, он просто пуст, а все данные перенесены в вектор. Теперь отвлекитесь от перемещений слона и решите жестокую историческую задачу о смелых воинах.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

-   **(-)**  Вариант есть. Пусть  `SmallWalk`  возвращает моего слона обратно.

> Вернуть моего же слона из  `SmallWalk`  можно по значению. Но это значит, что придётся внутри функции создать нового слона и копировать туда моего. Опять лишний слон.

-   **(-)**  Вариантов нет. Но ведь лишний слон всегда может пригодиться в хозяйстве.

> Только если вы с ними не живешь в однушке в Медведкове.

-   **(+)**  Вариант есть, но я пока его не знаю.

> Вы правы. Такой способ существует.

</details>

<details>
<summary>Задание:</summary>

## Задание

Дан диапазон объектов некоторого типа. Напишите функцию, которая переставляет его элементы в соответствии с порядком, определённым считалкой Иосифа Флавия с заданным размером шага. Вы можете почитать о задаче  [здесь](https://habr.com/ru/company/goto/blog/351092/)  или разобраться с примером в заготовке кода.

```cpp
template <typename RandomIt>
void MakeJosephusPermutation(RandomIt range_begin, RandomIt range_end, uint32_t step_size);

```

Предлагаемое решение задачи о считалке копирует элементы и не укладывается в ограничения по времени, но в остальном оно корректное. Исправьте его или напишите своё. Если найдёте, что в решении можно улучшить кроме замены копирования на перемещение, не стесняйтесь. Главное, чтобы оно продолжало корректно работать. Сохраните себе решение этого задания, оно вам ещё пригодится.

### Формат входных данных

Гарантируется, что итераторы `range_begin` и `range_end` являются итераторами произвольного доступа, то есть допускают вычитание одного из другого и сложение с числом. Кроме того, вы можете полагаться на то, что `step_size > 0`. Тип переупорядочиваемых объектов можно получить с помощью выражения `typename RandomIt::value_type`.

Максимальный размер диапазона — 10^5, максимальный размер шага — 10^2. Время выполнения одного вызова функции ограничено одной секундой.

### Ограничения

Объекты такого типа копировать запрещено. При их копировании вы получите ошибку компиляции.

### **Тесты**

Достаточно нескольких небольших ручных тестов и одного большого с максимальными ограничениями.

### Подсказка

Функция  `move`  поможет вам избежать копирования объектов и при создании  `pool`, и при переносе выживших обратно в контейнер.

</details>
