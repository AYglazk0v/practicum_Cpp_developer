<details>
<summary>Теория:</summary>

# Тайные техники передачи аргументов

Продолжим исследовать методы, позволяющие минимизировать количество копирований в коде. Вы уже знаете о возможности конструировать объекты без копирования, но с перемещением. В этом уроке увидите, как организована передача объектов в библиотечных функциях, и разберётесь, какой тип должен быть у аргумента, чтобы избежать лишних копирований.

### Тайные техники стандартных библиотек

При добавлении слона в толпу слонов использовался метод вектора  `push_back`. Причём он корректно работал и для временного объекта, в том числе для объекта, получаемого из функции  `move`, и для постоянного:

```cpp
// копируем постоянного слона в толпу
crowd_of_elephants.push_back(heavy_elephant);
// перемещаем временного слона в толпу
crowd_of_elephants.push_back(BuyElephant());
// перемещаем постоянного слона в толпу при помощи move
crowd_of_elephants.push_back(move(heavy_elephant));


```

В С++ функции с одинаковыми названиями компилятор различает благодаря списку аргументов. При вызове с аргументом компилятор ищет функцию с нужным именем и максимально близким типом аргумента. Идеальный вариант — когда типы совпадают. Пользователь передал объект типа  `int`, а функция принимает объект типа  `int`. Если стопроцентного попадания в тип аргумента не произошло, компилятор будет искать разрешённый вариант приведения одного типа в другой, чтобы хоть какая-нибудь функция с заданным именем могла быть вызвана для переданного объекта.

----------

Подождите, кажется, мы это уже видели…

-   Конечно! Когда пишем метод Get для члена класса или для объекта контейнера, делаем два метода: один константный, другой нет. Это то же самое, ведь константность метода значит, что один из аргументов — указатель  `this`  — будет передан как  `const`. Список аргументов отличается, и компилятор знает, какой из методов в каком случае вызывать.
    
-   Точно! Так же работает вызов конструкторов. Компилятор понимает, какой конструктор вызвать, в зависимости от переданных в него аргументов.
    
-   Не было такого. Всё как в тумане.
    

Если открыть описание метода  `push_back`, обнаружим, что это не один метод, а два:

```cpp
void push_back( const T& value );
void push_back( T&& value );

```

Первый метод принимает константную ссылку на постоянный объект. Значит, в этом методе объект будет копироваться. Второй метод принимает rvalue-ссылку — значит, объект будет перемещён, если это возможно.

----------

Отдельно нужно сказать о контейнере  `array`, который хранит свои данные в стеке. Этот контейнер поддерживает перемещение, но оно не такое эффективное, как у вектора. В векторе достаточно переместить указатель на данные. Никаких дополнительных действий с элементами не произойдёт. Вектор неперемещаемых элементов переместить можно. Но  `array`  работает иначе. Он не хранит указатель на данные, и для реализации перемещения нужно переместить каждый из элементов. Отсюда следуют два вывода:

-   Для перемещения  `array`его элементы должны быть перемещаемыми;
-   Сложность перемещения  `array`  — линейная от количества элементов, что значительно хуже константной сложности перемещения вектора.

### Тайные техники в жизни программистов

Немного изменим код примера со слоном:

```cpp
int main() {
    WhiteElephant heavy_elephant = BuyElephant();
    vector<WhiteElephant> crowd_of_elephants;
    AddToCrowd(crowd_of_elephants, heavy_elephant);
    AddToCrowd(crowd_of_elephants, BuyElephant());
}

```

Чтобы добавить слона в толпу, нужно передать объект в функцию  `AddToCrowd`. У программиста есть несколько вариантов, как это сделать:

-   по значению

```cpp
void AddToCrowd(vector<WhiteElephant>& crowd, WhiteElephant elephant);

```

-   по константной ссылке

```cpp
void AddToCrowd(vector<WhiteElephant>& crowd, const WhiteElephant& elephant);

```

-   по rvalue-ссылке

```cpp
void AddToCrowd(vector<WhiteElephant>& crowd, WhiteElephant&& elephant)

```

Варианты с передачей по указателю тоже существуют, но рассматривать их не станем. В этом контексте они аналогичны передаче по ссылке.

Вариант с неконстантной ссылкой тоже отложим. Если ссылка будет неконстантной, то в толпу можно будет переместить только неконстантных животных, а это ограничение слишком сильное и ненужное.

Выбирая между оставшимися тремя способами — по значению, по константной ссылке и по rvalue-ссылке — программист будет руководствоваться двумя принципами:

-   эффективностью кода или, в данном случае, минимальным количеством копирований;
-   удобством для того, кто будет этот метод вызывать.

Посчитаем копирования в каждом из случаев:

```cpp
// для постоянных объектов - одно копирование
// для временных объектов - одно копирование
void AddToCrowd(vector<WhiteElephant>& crowd, const WhiteElephant& elephant) {
    crowd.push_back(elephant);
}

// постоянные объекты не поддерживаются
// для временных объектов - одно перемещение
// если объект неперемещаемый, то перемещение станет копированием
void AddToCrowd(vector<WhiteElephant>& crowd, WhiteElephant&& elephant) {
    crowd.push_back(move(elephant));
}

// постоянные объекты - одно копирование и одно перемещение
// временные объекты - два перемещения
// если объект неперемещаемый, то перемещение станет вторым копированием
void AddToCrowd(vector<WhiteElephant>& crowd, WhiteElephant elephant) {
    crowd.push_back(move(elephant));
}


```

Неожиданным лидером по количеству перемещений вместо копирования становится передача аргумента по значению.

-   Временные объекты копироваться не будут. Они будут перемещены дважды: первый раз в сам объект аргумента, во второй раз — в контейнер.
-   Постоянные объекты, которые можно переносить, скопируются один раз, в аргумент, а в контейнер они будут перемещены.

Но нужно учитывать два недостатка:

-   Эта функция будет работать и для перемещаемых, и для неперемещаемых объектов. Только для неперемещаемых объектов она становится неэффективной — функция  `move`  не поможет переместить неперемещаемое. В этом случае перемещение превращается в тыкву и заменяется на второе копирование, что неприятно и малоэффективно.
-   Если перемещение по сложности не уступает копированию — например, как у контейнера  `array`, — два перемещения становятся менее эффективными, чем одно копирование, и лучше выбрать вариант с константной ссылкой.

### Техники стандартных библиотек против техники обычных программистов

Но ведь создатели стандартных библиотек использовали две разные функции! Надо разобраться, почему в их случае это было верно, а в нашем подойдёт вариант с одной функцией, принимающей аргумент по значению.

Стандартные классы и алгоритмы — шаблоны, и они должны поддерживать все возможные шаблонные параметры. Это накладывает строгие требования на дизайн методов класса. Методы и функции должны быть максимально эффективны и для перемещаемых, и для неперемещаемых объектов.

Кроме того стандартные библиотеки обязаны поддерживать и старые стандарты языков. Раньше, до появления возможности перемещать, многие объекты были неперемещаемыми, а библиотеки принимали аргументы по константной ссылке. Если бы создатели библиотек резко перешли на передачу аргументов по значению, код старых стандартов заметно замедлился бы, так как в этом случае количество копирований бы выросло. Но когда программист пишет своё приложение, он знает, с какими объектами собирается работать. Если объекты перемещаемые, стоит выбрать передачу аргумента по значению. Если неперемещаемые — по константной ссылке. Такой механизм позволяет сохранить эффективность кода и избежать дублирования.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Подождите, кажется, мы это уже видели…

-   **(+)**  Конечно! Когда пишем метод Get для члена класса или для объекта контейнера, делаем два метода: один константный, другой нет. Это то же самое, ведь константность метода значит, что один из аргументов — указатель  `this`  — будет передан как  `const`. Список аргументов отличается, и компилятор знает, какой из методов в каком случае вызывать.
    
-   **(+)**  Точно! Так же работает вызов конструкторов. Компилятор понимает, какой конструктор вызвать, в зависимости от переданных в него аргументов.
    
-   **(-)**  Не было такого. Всё как в тумане.

</details>

<details>
<summary>Задание:</summary>

## Задание

Дан вектор лексем. Напишите функцию, разбивающую лексемы на предложения:

```cpp
template <typename Token>
vector<Sentence<Token>> SplitIntoSentences(vector<Token> tokens);

```

`Token` — шаблонный тип. О нём известно лишь, что он имеет константный метод `IsEndSentencePunctuation`. Этот метод возвращает `true`, если лексема — знак пунктуации, заканчивающий предложение. В противном случае он возвращает `false`. Объекты такого типа могут быть копируемыми, а могут и не быть. Реализуйте функцию так, чтобы при передаче некопируемых объектов не возникало ошибок компиляции.

`Sentence` — синоним для типа `vector`, объявленный следующим образом:

```cpp
// Объявляем Sentence<Token> для произвольного типа Token
// синонимом vector<Token>.
// Благодаря этому в качестве возвращаемого значения
// функции можно указать не малопонятный вектор векторов,
// а вектор предложений — vector<Sentence<Token>>.
template <typename Token>
using Sentence = vector<Token>;

```

Предложением считается последовательность лексем, которая заканчивается одной или несколькими идущими подряд лексемами — знаками пунктуации в конце предложения. Иными словами, любое предложение должно состоять из двух частей:

-   лексемы, для которых `IsEndSentencePunctuation` возвращает `false`. Такие лексемы должны быть в каждом предложении кроме, возможно, первого;
-   лексемы, для которых `IsEndSentencePunctuation` возвращает `true`. Такие лексемы должны быть в каждом предложении кроме, возможно, последнего.

Сохраните себе решение этой задачи, оно вам ещё понадобится.

### **Ограничения**

Максимальное количество лексем — 10^6. Время выполнения одного вызова функции ограничено одной секундой.

### Пример использования

Допустим, вектор лексем задан так:

```
{Красиво}{ты}{вошла}{в}{мою}{грешную}{жизнь}{!}{Красиво}{ты}{ушла}{из}{неё}{.}

```

При этом  `!`  и  `.`  — символы конца предложения, и функция  `IsEndSentencePunctuation` возвращает  `true`. Значит, результирующий вектор предложений будет состоять из двух элементов:

```
{{Красиво}{ты}{вошла}{в}{мою}{грешную}{жизнь}{!}}
{{Красиво}{ты}{ушла}{из}{неё}{.}}

```

В прекоде уже есть тест, где используется копируемый тип  `TestToken`. Напишите тест для класса, объекты которого нельзя копировать, и проверьте, что ваша функция работает корректно.

### Подсказка

Среди стандартных алгоритмов есть удобная функция  `adjacent_find`. Она позволяет искать последовательность из двух элементов, удовлетворяющих условию, которое задано пользователем. Вы можете применить эту функцию, чтобы определить конец предложения.

Найдите конец предложения, потом пройдите по лексемам от начала до конца и переместите значения лексем в предложение. Само предложение после этого можно переместить в вектор результатов.

</details>
