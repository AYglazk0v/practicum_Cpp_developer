<details>
<summary>Введение:</summary>

# Введение

В этой теме вы разберётесь, что спрятано под капотом у стандартных контейнеров. Используя эти знания, научитесь разумно выбирать контейнер для реализации своих задач. А ещё пойдёте дальше и разработаете собственный вектор.

</details>

<details>
<summary>Теория + тестирование:</summary>

# Эффективный вектор

О векторе сказано уже много. Резюмируем ваши знания. Его главное свойство, объясняющее все сильные и слабые стороны, — это последовательное расположение всех элементов в памяти. Создадим вектор из трёх элементов и добавим один элемент в конец:

```cpp
vector<int> v = {1, 2, 3};
v.push_back(4);

```

При создании вектора на стеке появится объект под именем  `v`, который будет содержать информацию о векторе:

-   `int* data`  — указатель на выделенный на куче отрезок памяти для трёх элементов типа  `int`;
-   `size`  — количество элементов, которые в данный момент находятся в векторе;
-   `capacity`  — количество элементов, для которых потенциально есть место в выделенной памяти, тоже три.

Данные всех трёх параметров можно получить через одноимённые методы вектора.

----------

Что будет выведено в результате работы этой программы?

```cpp
vector<int> v = {1, 2, 3};
v.push_back(4);
const int* data = v.data();
for (int i = 0; i < v.size(); ++i) {
    cout << *(data + i) << ' ';
}
cout << endl;
for (int i = 0; i < v.capacity(); ++i) {
    cout << *(data + i) << ' ';
}

```

```cpp
1 2 3 4
1 2 3 4

```

-   ```cpp
    1 2 3 4
    1 2 3 4 (и дальше два неожиданных числа)
    
    ```
    
-   Ничего выведено не будет, возникнет исключение.
    

Два неизвестных числа у каждого пользователя могут быть разными. Это не цифры из лотереи, а некий мусор, лежавший в памяти, которую сейчас использует вектор для хранения элементов.  `Capacity`  вектора выросла вдвое: была 3, стала 6. Но  `size`  вектора увеличился на единицу: был 3, стал 4. Когда появятся новые элементы, вектор просто перезапишет их на место мусора. С дальнейшим добавлением элементов  `size`  станет равен  `capacity`, и вектору снова придётся её удвоить.

Для освобождения от мусора есть специальный метод. Он нечасто используется и называется  `shrink_to_fit`. Метод переаллоцирует память так, чтобы  `capacity`  стала равна  `size`. Интересно, что этот запрос необязательно будет выполнен. Реализация контейнера такова, что запрос можно оставить без внимания. Да, и такое бывает.

Вернёмся к добавлению элементов в вектор.

----------

В каком порядке будут выполнены эти шаги при работе метода  `push_back`?

1.  Выделение нового блока памяти в два раза больше предыдущего
2.  Добавление нового элемента
3.  Копирование старых элементов из предыдущего блока памяти в новый
4.  Освобождение предыдущего блока памяти, увеличение  `capacity`  и  `size`
5.  Проверка, достаточно ли capacity, чтобы добавить новый элемент

-   5, 1, 3, 2, 4
    
-   5, 4, 1, 3, 2,
    
-   5, 1, 3, 4, 2
    

Как только добавим в вектор ещё два элемента, место кончится опять. Снова придётся перевыделять память, увеличивая  `capacity`  в два раза, и копировать туда элементы старого блока. Согласитесь, это неэффективно, если мы заранее знаем, сколько элементов должно быть в векторе. Именно для таких случаев есть метод  `reserve`, который вы уже встречали в пятом спринте.

----------

Какой ещё важный сторонний эффект у того, что при добавлении элемента в вектор память может перевыделяться?

-   Известны ошибки, которые возникают при копировании элементов вектора в новый участок памяти. Нужно их опасаться.
    
-   Указатель, полученный методом  `data`, будет инвалидироваться. После любых операций, которые потенциально могут перевыделять память, лучше этот указатель переопределить, вызвав метод  `data`  заново.
    
-   Метод  `size`  не всегда возвращает верное значение. Лучше вычислить разницу между  `capacity`  и  `end`.
    

Не забудьте ответ на этот вопрос. Указатель вектора имеет свойство инвалидироваться или, иначе говоря, становиться неверным, недействительным.

Реализация  `SimpleVector`  похожа на реализацию стандартного вектора. Внутри вектора есть указатель на участок памяти, где располагаются элементы, и по ним можно итерировать. В конце этой темы вернёмся к  `SimpleVector`  и улучшим его реализацию, добавив метод  `Reserve`.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания


Что будет выведено в результате работы этой программы?

```cpp
vector<int> v = {1, 2, 3};
v.push_back(4);
const int* data = v.data();
for (int i = 0; i < v.size(); ++i) {
    cout << *(data + i) << ' ';
}
cout << endl;
for (int i = 0; i < v.capacity(); ++i) {
    cout << *(data + i) << ' ';
}

```

-   **(-)**

```cpp
1 2 3 4
1 2 3 4

```

-   **(+)**  `cpp 1 2 3 4 1 2 3 4 (и дальше два неожиданных числа)`
    
-   **(-)**  Ничего выведено не будет, возникнет исключение.
    

----------

В каком порядке будут выполнены эти шаги при работе метода  `push_back`?

1.  Выделение нового блока памяти в два раза больше предыдущего
2.  Добавление нового элемента
3.  Копирование старых элементов из предыдущего блока памяти в новый
4.  Освобождение предыдущего блока памяти, увеличение  `capacity`  и  `size`
5.  Проверка, достаточно ли capacity, чтобы добавить новый элемент

-   **(+)**  5, 1, 3, 2, 4
    
-   **(-)**  5, 4, 1, 3, 2,
    
-   **(-)**  5, 1, 3, 4, 2
    

----------

Какой ещё важный сторонний эффект у того, что при добавлении элемента в вектор память может перевыделяться?

-   **(-)**  Известны ошибки, которые возникают при копировании элементов вектора в новый участок памяти. Нужно их опасаться.
    
-   **(+)**  Указатель, полученный методом  `data`, будет инвалидироваться. После любых операций, которые потенциально могут перевыделять память, лучше этот указатель переопределить, вызвав метод  `data`  заново.
    
-   **(-)**  Метод  `size`  не всегда возвращает верное значение. Лучше вычислить разницу между  `capacity`  и  `end`.

</details>
