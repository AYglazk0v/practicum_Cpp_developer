<details>
<summary>Теория + тестирование:</summary>

# Эффективный дек

Вы уже много знаете о векторе, но ещё не изучали, как работает дек, в чём его сила и слабость. С деком — двунаправленной очередью — вы познакомились в четвёртом спринте. В этом уроке рассмотрим его реализацию и выясним, в каких случаях стоит выбрать вектор, а в каких — дек.

Принципиальная разница дека и вектора: дек не обещает хранить элементы в памяти подряд. Сразу, не думая и не вникая в реализацию, можно сказать, что итерироваться по вектору должно быть проще, чем по деку. Проверим интуицию — разберёмся, как организована итерация по деку. Создадим дек, добавим в него три элемента при инициализации, потом ещё один в конец и один в начало:

```cpp
deque<int> d = {1, 2, 3};
deque.push_back(4);
deque.push_front(0);

```

Будь это вектор, перевыделение памяти и копирование элементов произошли бы уже дважды — при добавлении каждого из новых элементов. Но дек работает иначе:

1.  В стеке будет создан объект  `d`, где сохранится количество элементов, расположенных в памяти. Кроме этого, внутри дека есть вектор, хранящий указатели на участки памяти, где находятся элементы. Иначе эти участки называются чанками. Изначально у дека будет один чанк размера три, где будут лежать элементы 1, 2 и 3.
    
2.  Теперь вызовем  `push_back`. Места в памяти для нового элемента нет. Дек выделит новый чанк — например, тоже размера три. Положим туда новый элемент на первое место. Не забудем добавить в вектор чанков новый указатель.
    
3.  Пока всё идет неплохо. Вызываем  `push_front`, и начинается самое интересное. Положить элемент нужно так, чтобы потом найти его по порядковому номеру. Мы же хотим удобный доступ к элементам. Секрет в том, что дек в очередной раз выделит новый чанк и положит туда 0, но не в начало, а в конец. Первые два элемента этого чанка пока останутся пустыми. Точнее там будет лежать некий мусор. Но внутри своей структуры дек держит специальный параметр “shift”. Этот параметр говорит, насколько первый элемент дека отстоит от начала чанка. В нашем случае  `shift = 2`.
    

Подберите подходящие формулы для поиска элемента по его номеру в деке, если:

`n`  — номер искомого элемента в деке,

`chunk_size`  — размер чанка,

`shift`  — сдвиг первого элемента относительно начала первого чанка,

`found_chunk`  — номер чанка, в котором находится искомый элемент,

`found_position`  — номер позиции искомого элемента внутри чанка.

----------

Формула для  `found_chunk`  :

-   `n / chunk_size`
    
-   `(n + shift) / chunk_size`
    
-   `n % chunk_size`
    
-   `(n + shift) % chunk_size`
    

----------

Формула для  `found_position`  :

-   `n / chunk_size`
    
-   `(n + shift) / chunk_size`
    
-   `n % chunk_size`
    
-   `(n + shift) % chunk_size`
    

Очевидно, дек легко найдёт элемент по номеру его позиции. А значит, этот контейнер отлично поддерживает итераторы произвольного доступа.

Как дек устроен изнутри, стало ясно. Теперь разберёмся, что эффективнее — дек или вектор.

----------

Используйте свои знания о внутреннем устройстве вектора и дека и разделите утверждения в соответствии с тем, к какому контейнеру они относятся.

-   Эффективен в случае частых вставок в начало
    
-   Указатели инвалидируются после вставки или удаления объектов
    
-   Указатели остаются рабочими после вставки или удаления объектов
    
-   Вставка в начало вызывает копирование всех элементов, которые до этого были в контейнере
    
-   Чтобы найти объект по его индексу, достаточно прибавить индекс к указателю на начало элементов
    
-   Поиск объекта по индексу требует вычислений с использованием операций деления и взятия остатка от деления
    
-   Все элементы находятся в памяти последовательно, поэтому итерация не составляет труда
    
-   Итерация через элементы затруднена тем, что элементы могут находиться в разных частях памяти
    

Как видите, получив эффективность вставки в начало, а также рабочие указатели, мы потеряли в лёгкости итерации и поиска.

Откройте свою IDE, выполните задания и ответьте на вопросы.

----------

### Задание

Напишите программу, которая:

-   Использует  `push_back`  и вставляет в вектор 1000000 случайных элементов. Не применяйте  `Reserve`  в этом случае. Представьте, что не знаете, сколько элементов будет вставлено;
-   Использует  `push_back`  и вставляет столько же элементов в дек;
-   Делает то же самое, но для 5000000 элементов.

Попробуйте увеличивать и уменьшать количество элементов. Примените профилировщик, чтобы сравнить результаты.

----------

Какой контейнер оказался эффективнее?

-   Дек
    
-   Вектор
    
-   Сложно ответить, данные разнятся
    

----------

### Задание

Сделайте другой тест. Вы знаете, что итерировать по вектору должно быть проще, чем по деку. Чтобы проверить это, используйте сортировку. Напишите программу, которая бы сортировала 1000000 случайных элементов в векторе и в деке. Измените количество элементов. Сравните результаты.

----------

Какой контейнер оказался эффективнее?

-   Дек
    
-   Вектор
    
-   Сложно ответить, данные разнятся
    

Возникает вопрос: что делать, если программист не может однозначно предсказать происходящее с контейнером. Например, это некий буфер, куда мы будем записывать данные, а потом должны по запросу пользователя их отсортировать? Здесь однозначного ответа нет, и не верьте тем, кто говорит, что знает его. Когда невозможно предсказать, как контейнер будет использоваться, подобрать подходящий можно, проведя измерения. Используйте профилировщик. Точные данные о времени выполнения операций помогут принять верное решение о выборе контейнера.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Формула для  `found_chunk`  :

-   **(-)**  `n / chunk_size`
    
-   **(+)**  `(n + shift) / chunk_size`
    
-   **(-)**  `n % chunk_size`
    
-   **(-)**  `(n + shift) % chunk_size`
    

----------

Формула для  `found_position`  :

-   **(-)**  `n / chunk_size`
    
-   **(-)**  `(n + shift) / chunk_size`
    
-   **(-)**  `n % chunk_size`
    
-   **(+)**  `(n + shift) % chunk_size`
    

----------

Используйте свои знания о внутреннем устройстве вектора и дека и разделите утверждения в соответствии с тем, к какому контейнеру они относятся.

-   Эффективен в случае частых вставок в начало

-   Указатели инвалидируются после вставки или удаления объектов

-   Указатели остаются рабочими после вставки или удаления объектов

-   Вставка в начало вызывает копирование всех элементов, которые до этого были в контейнере

-   Чтобы найти объект по его индексу, достаточно прибавить индекс к указателю на начало элементов

-   Поиск объекта по индексу требует вычислений с использованием операций деления и взятия остатка от деления

-   Все элементы находятся в памяти последовательно, поэтому итерация не составляет труда

-   Итерация через элементы затруднена тем, что элементы могут находиться в разных частях памяти

----------

Какой контейнер оказался эффективнее?

-   **(+)**  Дек
    
-   **(-)**  Вектор
    
-   **(-)**  Сложно ответить, данные разнятся
    

----------

Какой контейнер оказался эффективнее?

-   **(-)**  Дек
    
-   **(+)**  Вектор
    
-   **(-)**  Сложно ответить, данные разнятся

</details>
