<details>
<summary>Теория + тестирование:</summary>

# Эффективный список

В предыдущем спринте вы написали свой односвязный список. В стандартной библиотеке есть похожий контейнер, но двусвязный. Разница лишь в том, что перемещаться по нему можно не только вперёд, но и назад.

В векторе все элементы расположены последовательно в одном участке памяти. В деке элементы находятся в памяти в небольших чанках. Продолжая идею уменьшения количества последовательно расположенных элементов, приходим к выделению отдельного участка памяти для каждого элемента. При этом каждый элемент будет знать, где лежит предыдущий и следующий.

Рассмотрим удаление элемента из списка:

```cpp
list<int> numbers = {1, 2, 3, 4};
auto it = find(numbers.begin(), numbers.end(), 3);
numbers.erase(it);

```

Чтобы найти элемент в списке, используем функцию  `find`. Как и у других линейных контейнеров, собственного метода  `find`  у списка нет. Это значит, что поиск будет осуществляться за линейное время и потребует прохода по всем элементам один за другим.

Найдя тройку, вызываем метод  `erase`, который правильно перенаправляет указатели предыдущего и следующего элемента. Время удаления константное.

----------

Вспомните, какова сложность удаления элемента из вектора и дека.

-   Линейная
    
-   Константная
    
-   Логарифмическая
    

Со вставкой элемента то же самое. Выделяется память под элемент, верно расставляются связи. Таким образом, и вставка, и удаление из середины работают для списка быстрее, чем для вектора и дека.

Функциональность списков ограничена, в том числе потому, что быстро получить доступ к элементу по его индексу невозможно. У списка двунаправленный итератор, а не итератор произвольного доступа. Это усложняет — а иногда делает невозможным — работу некоторых алгоритмов. Например, функцию бинарного поиска для списка использовать нельзя, так как эта функция требует итераторы произвольного доступа.

С другой стороны, алгоритм  `reverse`  существует в виде метода списка, и в реализации этого метода нет переставления элементов местами, что может быть достаточно затратно. Метод  `reverse`  просто переставляет указатели на соседние элементы.

Преимущество списка в том, что его устройство позволяет оставлять итераторы рабочими. Ни один из других изученных контейнеров такой возможности не предоставлял. Ни вставка, ни удаление, ни какое-либо другое изменение не инвалидируют итераторы списка — если, конечно, вы не удалили тот элемент, на который итератор указывал. В этом случае чуда не произойдёт, и итератор будет инвалидирован.

Ещё менее популярный контейнер, основанный на том же принципе, —  [`forward_list`](https://ru.cppreference.com/w/cpp/container/forward_list), однонаправленный список. Он может подойти, если нужно итерировать по элементам только в одну сторону, так как в этом случае экономится память. Каждый элемент помнит указатель только на следующий элемент, но не на предыдущий.

Перед тем как приступить к заданию, изучите документацию по следующим методам:

-   [insert](https://ru.cppreference.com/w/cpp/container/list/insert)
-   [assign](https://ru.cppreference.com/w/cpp/container/list/assign)
-   [erase](https://ru.cppreference.com/w/cpp/container/list/erase)
-   [unique](https://ru.cppreference.com/w/cpp/container/list/unique)
-   [remove](https://ru.cppreference.com/w/cpp/container/list/remove)
-   [sort](https://ru.cppreference.com/w/cpp/container/list/sort)

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Вспомните, какова сложность удаления элемента из вектора и дека.

-   **(+)**  Линейная
    
-   **(-)**  Константная
    
-   **(-)**  Логарифмическая

</details>

<details>
<summary>Задание:</summary>

## Задание

Рассмотрим упрощённый текстовый редактор, который поддерживает следующий набор команд:

-   Перемещение курсора влево (**Left**) и вправо (**Right**) на одну позицию;
-   Ввод символа в текущую позицию курсора (**Insert**);
-   Копирование фрагмента текста, начинающегося в текущей позиции курсора, в буфер обмена (**Copy**);
-   Вырезание фрагмента текста — аналогично копированию с последующим удалением скопированных символов из текста (**Cut**);
-   Вставка содержимого буфера обмена в текущую позицию курсора (**Paste**).

Эти команды поддерживаются почти любым текстовым редактором. Для команд действуют стандартные правила, определяющие их эффект:

-   Если редактор содержит текст длиной `n` символов, курсор может находиться в одной из `(n + 1)` возможных позиций. Обозначим курсор вертикальной чертой `|` и будем использовать это обозначение дальше. В тексте `abc` курсор может быть в позициях: `|abc`, `a|bc`, `ab|c`, `abc|`. Поэтому команда **Left** не имеет эффекта, когда курсор расположен в начале текста, а **Right** не имеет эффекта, когда курсор находится в конце. Ни **Left**, ни **Right** не имеют эффекта, когда редактор не содержит текста.
-   Введённый символ располагается в позиции курсора, сдвигая курсор и весь текст справа от него на одну позицию вправо. Аналогично при вставке фрагмента длиной `n` курсор и текст справа от него смещаются на `n` позиций вправо. В таблице приведены примеры, демонстрирующие это правило.

|До вставки|Вводимый символ/вставляемый фрагмент|После вставки|
|--|--|--|
|I|a|aI|
|abI|c|abcI|
|Ibc|a|aIbc|
|Iworld|hello_|hello_Iworld|
|hello_I|world|hello_worldI|
|123I78|456|123456I78|

-   Буфер обмена изначально пуст. Вставка пустого фрагмента не имеет эффекта. Содержимое буфера не сбрасывается после вставки, а остаётся неизменным до следующей команды **Copy** или **Cut**. Копирование или вырезание фрагмента нулевой длины не оказывает влияния на текст, но опустошает буфер обмена. Курсор не смещается ни при копировании, ни при вырезании текста. Например, после вырезания из текста `ab|cdef` фрагмента из трёх символов получим текст `ab|f`.

Вам предстоит реализовать «ядро» текстового редактора, который поддерживает все описанные операции, в виде класса `Editor`  с таким интерфейсом:

```cpp
class Editor {
public:
    Editor();
    // сдвинуть курсор влево
    void Left();
    // сдвинуть курсор вправо 
    void Right();
    // вставить символ token
    void Insert(char token);
    // вырезать не более tokens символов, начиная с текущей позиции курсора
    void Cut(size_t tokens = 1);
    // cкопировать не более tokens символов, начиная с текущей позиции курсора
    void Copy(size_t tokens = 1);
    // вставить содержимое буфера в текущую позицию курсора
    void Paste();
    // получить текущее содержимое текстового редактора
    string GetText() const;
};

```

Каждой описанной команде сопоставлен метод класса `Editor`. Также введён метод `GetText()`, позволяющий получить текущее содержимое редактора в виде строки. В комментариях к методам `Cut(size_t tokens)` и `Copy(size_t tokens)` указано, что в буфер обмена попадает фрагмент длиной не более `tokens` символов. Это значит, что если справа от курсора располагается менее чем `tokens` символов, методы `Cut()` и `Copy()` должны вырезать или скопировать все символы справа.

### Ограничения

Реализация класса `Editor` должна обрабатывать 10^6 запросов не более чем за одну секунду. При этом гарантируется, что:

-   Длина текста никогда не превышает 10^6 символов;
-   Методы `Copy()` и `Cut()` суммарно копируют/вырезают не более 10^6 символов;
-   Метод `GetText()` вызывается один раз в каждом из тестов.

### Пример использования

```cpp
int main() {
    Editor editor;
    const string text = "hello, world"s;
    for (char c : text) {
        editor.Insert(c);
    }
    // Текущее состояние редактора: `hello, world|`
    for (size_t i = 0; i < text.size(); ++i) {
        editor.Left();
    }
    // Текущее состояние редактора: `|hello, world`
    editor.Cut(7);
    // Текущее состояние редактора: `|world`
    // в буфере обмена находится текст `hello, `
    for (size_t i = 0; i < 5; ++i) {
        editor.Right();
    }
    // Текущее состояние редактора: `world|`
    editor.Insert(',');
    editor.Insert(' ');
    // Текущее состояние редактора: `world, |`
    editor.Paste();
    // Текущее состояние редактора: `world, hello, |`
    editor.Left();
    editor.Left();
    //Текущее состояние редактора: `world, hello|, `
    editor.Cut(3);  // Будут вырезаны 2 символа
    // Текущее состояние редактора: `world, hello|`
    cout << editor.GetText();
    return 0;
}

```

### Пример вывода

```
world, hello

```

### Подсказка

Вам понадобятся два списка: один для хранения текста, а другой — для буфера вставки. Итератор — удобное решение для хранения текущей позиции курсора.

</details>
