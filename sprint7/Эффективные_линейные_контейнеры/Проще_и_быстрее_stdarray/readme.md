<details>
<summary>Теория:</summary>

# Проще и быстрее: std::array

Подумайте, в каких случаях использовать динамическую память для хранения элементов контейнера действительно нужно. Данные в куче сохраняются даже после окончания работы функции, где была выделена память. Это полезно не всегда — до сих пор мы создавали контейнер в функции, и после её работы этот контейнер был нам больше не нужен. Динамическое выделение памяти удобно, когда не знаем, сколько точно будет элементов в контейнере. Потенциально их может оказаться как очень много, так и очень мало. Поэтому желательно выделять память «‎по запросу»‎, а не резервировать лишнюю.

Но иногда мы заранее знаем, что элементов будет определённое небольшое количество. Тогда накладные расходы, связанные с выделением памяти в куче, нам не нужны — это достаточно ресурсозатратная операция. На такие случаи есть контейнер  `std::array`  — массив, который вообще не выделяет память в куче, а хранит всё на стеке функции.

Сначала проверим, что элементы массива действительно лежат на стеке функции. Используем простой приём:

```cpp
#include <array>
#include <iostream>

using namespace std;

int main() {
    // создадим на стеке переменные x и y,
    // положим между ними массив, заполненный восьмёрками
    int x = 111111;
    array<int, 10> numbers;
    numbers.fill(8);
    int y = 222222;
    // пройдёмся по адресам между y и x
    // и выведем то, что лежит в памяти
    for (int* p = &y; p <= &x; ++p) {
        cout << *p << " "s;
    }
    cout << endl;

    return 0;
}

```

Результат работы программы:

```cpp
222222 8 8 8 8 8 8 8 8 8 8 6 0 111111

```

Вывод на экран в вашей IDE может немного отличаться, но это не меняет результата — все десять восьмёрок хранятся последовательно в стеке.

Массивы в языке С устроены так же, но всё-таки  `std::array`  удобнее. У него есть методы, итераторы, и его можно, например, скопировать:

```cpp
#include <array>
#include <iostream>

using namespace std;

int main() {
    array<int, 10> numbers;
    numbers.fill(8);
    // копируем массив
    const auto numbers_copy = numbers;
    // итерируем по массиву
    for (int x : numbers_copy) {
        cout << x << " ";
    }
    cout << endl;

    return 0;
}

```

Результат работы:

```cpp
8 8 8 8 8 8 8 8 8 8

```

Разберёмся, в каких ситуациях массив эффективнее. Представим, что у нас есть функция, которая всегда возвращает пять разных элементов. Напишем два варианта этой функции — один вариант с вектором, другой с массивом:

```cpp
#include "profile.h"

#include <array>
#include <vector>

using namespace std;

vector<int> BuildVector(int i) {
    return {i, i + 1, i + 2, i + 3, i + 4};
}

array<int, 5> BuildArray(int i) {
    return {i, i + 1, i + 2, i + 3, i + 4};
}

const int COUNT = 1000000;

int main() {
    {
        LOG_DURATION("vector");
        for (int i = 0; i < COUNT; ++i) {
            auto numbers = BuildVector(i);
        }
    }
    {
        LOG_DURATION("array");
        for (int i = 0; i < COUNT; ++i) {
            auto numbers = BuildArray(i);
        }
    }

    return 0;
}

```

В  `array<int, 5>`  число пять означает максимальное количество элементов, которое может быть сохранено в объекте такого типа. Элементов всегда будет пять, не больше и не меньше. При этом типы  `array<int, 5>`  и  `array<int, 4>`  не будут совместимы друг с другом — они абсолютно разные. Запустим программу без оптимизации. Получим:

```cpp
vector: 147 ms
array: 4 ms

```

А с оптимизацией результат ещё интереснее:

```cpp
vector: 55 ms
array: 0 ms

```

Несмотря на то, что алгоритмическая сложность у этих двух функций одна и та же, массив работает в разы быстрее вектора.

----------

Какая алгоритмическая сложность у измеряемых макросом  `LOG_DURATION`  секций?

-   C\cdot N, где C — количество вызовов функции, а N — количество элементов в контейнере.
    
-   N, где N — количество элементов в контейнере.
    
-   C \cdot N\cdot K, где C — количество вызовов функции, N — количество элементов в контейнере, K — некая переменная константа.
    

Проведём ещё один эксперимент. Добавим сортировку для массива, но не будем трогать функцию с вектором. Это увеличит алгоритмическую сложность, и она станет равна C\cdot N\cdot\log N:

```cpp
#include "profile.h"

#include <algorithm>
#include <array>
#include <vector>

using namespace std;

vector<int> BuildVector(int i) {
    return {i, i + 1, i + 2, i + 3, i + 4};
}

array<int, 5> BuildArray(int i) {
    return {i, i + 1, i + 2, i + 3, i + 4};
}

const int COUNT = 1000000;

int main() {
    {
        LOG_DURATION("vector");
        for (int i = 0; i < COUNT; ++i) {  // C * N
            auto numbers = BuildVector(i);
        }
    }
    {
        LOG_DURATION("array");
        for (int i = 0; i < COUNT; ++i) {  // C * N * logN
            auto numbers = BuildArray(i);
            sort(begin(numbers), end(numbers));
        }
    }

    return 0;
}

```

Посмотрим на результаты:

```cpp
vector: 55 ms
array: 6 ms

```

Важное наблюдение: функция с массивом всё ещё работает быстрее, хотя её алгоритмическая сложность больше. В данном случае расходы на выделение памяти для вектора оказались выше, чем добавление сортировки для массива.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Какая алгоритмическая сложность у измеряемых макросом  `LOG_DURATION`  секций?

-   **(+)**  C\cdot N, где C — количество вызовов функции, а N — количество элементов в контейнере.
    
-   **(-)**  N, где N — количество элементов в контейнере.
    
-   **(-)**  C \cdot N\cdot K, где C — количество вызовов функции, N — количество элементов в контейнере, K — некая переменная константа.

</details>

<details>
<summary>Задание:</summary>

## Задание

Создайте вектор, который не использует память из кучи, а хранит все свои объекты в стеке.

Вы знакомы с контейнером  `array`, который поможет решить эту задачу. Реализуйте интерфейс вектора поверх него: разработайте шаблон класса  `template <typename T, size_t N> StackVector<T, N>`, где  `T`  — тип элемента вектора, а  `N`  — его максимальная вместимость. Класс  `StackVector`  должен иметь следующий интерфейс:

```cpp
template <typename T, size_t N>
class StackVector {
public:
    explicit StackVector(size_t a_size = 0);

    T& operator[](size_t index);
    const T& operator[](size_t index) const;

    ??? begin();
    ??? end();
    ??? begin() const;
    ??? end() const;

    size_t Size() const;
    size_t Capacity() const;

    void PushBack(const T& value);
    T PopBack();
};

```

-   Метод `Capacity` должен возвращать вместимость вектора — то есть количество объектов, которое в него может поместиться.
-   Метод `Size` должен возвращать текущее количество объектов в векторе.
-   Конструктор принимает размер вектора — по аналогии со стандартным вектором. Если аргумент конструктора больше вместимости вектора, конструктор должен выбрасывать исключение [`invalid_argument`](https://en.cppreference.com/w/cpp/error/invalid_argument).
-   Методы `begin/end` должны возвращать итераторы на начало и текущий конец вектора. Их тип не указан, выберите его самостоятельно.
-   Метод `PushBack` добавляет новый элемент в конец вектора. Если текущий размер вектора равен его вместимости, метод `PushBack` должен выбрасывать стандартное исключение [`overflow_error`](https://en.cppreference.com/w/cpp/error/overflow_error).
-   Метод `PopBack` уменьшает размер вектора на один и возвращает элемент вектора, который был последним. Если вектор пуст, метод `PopBack` должен выбрасывать стандартное исключение [`underflow_error`](https://en.cppreference.com/w/cpp/error/underflow_error).

Интерфейс класса `StackVector` описан в файле stack_vector.h. Часть требований к нему сформулирована в виде юнит-тестов в файле main.cpp.

Файл main.cpp содержит бенчмарк, который демонстрирует преимущество `StackVector` перед обычным вектором. Этот бенчмарк моделирует ситуацию, когда мы считываем из потока количество объектов `N`, а затем добавляем в вектор `N` объектов. Для этого используем метод `push_back`. Тестовые данные разложены в `vector<vector<int>>`, чтобы исключить из бенчмарка время, нужное на парсинг. Когда реализуете шаблон `StackVector`, сравните его производительность с вектором.

### Подсказка

Обратите внимание, как отличается поведение метода `PushBack` в классе `StackVector` от метода `PushBack` в классе `SimpleVector`, который вы реализовывали в предыдущем спринте. `SimpleVector::PushBack` выделял дополнительную память в куче, если размер вектора оказывался равен ёмкости. В случае с классом `StackVector` нужно на этапе компиляции задать максимальную ёмкость вектора. Если она исчерпается, взять память будет неоткуда, и выбросится исключение. В этом недостаток реализации вектора в стеке по сравнению с обычным вектором.

</details>
