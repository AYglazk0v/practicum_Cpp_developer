<details>
<summary>Теория:</summary>

# Можем лучше: совершенствуем парсинг строки

В этом уроке будут две задачи. В первой вы самостоятельно улучшите парсинг строки и познакомитесь с новыми методами класса  `string_view`. Во второй — реализуете простой переводчик.

</details>

<details>
<summary>Задание 1:</summary>

## Задание 1

В прошлом уроке для парсинга строки вы использовали переменную  `pos`, которая указывала на позицию начала слова. Избавьтесь от этой переменной и начните перемещать начало самого  `string_view`.

Алгоритм будет выглядеть следующим образом:

-   Установите начало переменной  `str`  типа  `string_view`  на начало строки.
-   Используйте метод  `find`, чтобы найти номер позиции ближайшего пробела.
-   Добавьте в результирующий вектор элемент  `string_view`, полученный вызовом метода  `substr`, где начальная позиция будет 0, а конечная — найденная позиция пробела.
-   Сдвиньте начало  `str`  так, чтобы оно указывало на позицию за пробелом. Для этого есть метод  `remove_prefix`, который передвинет начало  `str`  на указанное в аргументе количество позиций.
-   Теперь все эти действия можно повторить в цикле, пока найденная позиция пробела не станет равна уже известной константе  `npos`.

Реализуйте функцию  `SplitIntoWordsView`  по описанному алгоритму.

### Как будет тестироваться ваш код

Тесты на правильность разбиения. Тесты, проверяющие, что код использует  `remove_prefix`.

### Подсказка

Вернитесь к описанию алгоритма или откройте документацию для метода  [find](https://en.cppreference.com/w/cpp/string/basic_string_view/find)  и  [substr](https://en.cppreference.com/w/cpp/string/basic_string_view/substr). Пока эти страницы есть только на английском.

</details>

<details>
<summary>Задание 2:</summary>

## Задание 2

Разработайте класс  `Translator`, позволяющий сохранять двуязычные пары слов, а затем переводить слова с одного языка на другой с использованием уже добавленных пар.

Более конкретно объект `t` типа `Translator` должен допускать следующие действия:

1.  Создание с использованием конструктора по умолчанию. В этом случае база переводов пуста.
2.  Добавление двуязычной пары: `t.Add(source, target)`. После такого вызова считается, что слово `source` на языке 1 соответствует слову `target` на языке 2. Переданные в метод `Add` строки могут быть уничтожены раньше объекта `t`.
3.  Перевод с языка 1 на язык 2: `t.TranslateForward(source)`. Если ранее уже был вызов `t.Add(source_copy, target)` для некоторой строки `target` и строки `source_copy`, равной `source` или являющейся ей, нужно вернуть `target`. Если такого вызова не было — вернуть пустую строку. Если таких вызовов было несколько — вернуть `target` для последнего из них.
4.  Перевод с языка 2 на язык 1: `t.TranslateBackward(target)`. Если ранее уже был вызов `t.Add(source, target_copy)` для некоторой строки `source` и строки `target_copy`, равной `target` или являющейся ей, нужно вернуть `source`. Если такого вызова не было — вернуть пустую строку. Если таких вызовов было несколько — вернуть `source` для последнего из них.

### Ограничения

Каждая строка должна храниться в экземпляре класса `Translator` не более одного раза. При нарушении этого ограничения вы получите ошибку “Memory limit exceeded”.

### Пример использования

```cpp
void TestSimple() {
	  Translator translator;
    translator.Add(string("okno"s), string("window"s));
    translator.Add(string("stol"s), string("table"s));

    assert(translator.TranslateForward("okno"s) == "window"s);
    assert(translator.TranslateBackward("table"s) == "stol"s);
    assert(translator.TranslateForward("table"s) == ""s);
}

int main() {
    TestSimple();
    return 0;
}

```

### Как будет тестироваться ваш код

Проверим, что всё переводится верно, а также то, что после разрушения объектов-строк, которые были добавлены в  `Translator`, перевод всё еще работает корректно.

### Подсказка

Самый простой способ реализации словаря — это, конечно, контейнер-словарь. В данном случае удобно держать два контейнера, чтобы обеспечить поиск слов и для прямого перевода, и для обратного. Хранить в этих словарях строки — расточительство. Но строки вам всё равно нужны, так как строки могут быть уничтожены до уничтожения объекта  `Translator`. Сохраните их себе в удобном контейнере.

</details>
