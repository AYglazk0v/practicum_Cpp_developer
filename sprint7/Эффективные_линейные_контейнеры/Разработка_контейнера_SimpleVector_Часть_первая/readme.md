<details>
<summary>Теория:</summary>

# Разработка контейнера SimpleVector. Часть вторая

В предыдущем уроке вы познакомились с устройством SimpleVector и создали в нём операции для управления размером контейнера и доступа к его элементам. В этом уроке вы реализуете:

-   возможность сравнивать содержимое векторов, вставлять и удалять элементы;
-   пользовательский конструктор копирования;
-   пользовательский оператор присваивания.

### Сравнение содержимого векторов

Вы уже реализовали операцию сравнения содержимого односвязных списков. Аналогично можно реализовать операции сравнения векторов, применив известные вам стандартные алгоритмы.

При сравнении векторов их вместимость нужно игнорировать. Например, два вектора одного размера, содержащие одни и те же элементы, равны, даже если имеют разную вместимость.

----------

Какой стандартный алгоритм позволит реализовать операторы  `<`,  `<=`,  `>`,  `>=`  в классе  `SimpleVector`? Выберите один ответ.

-   `std::equal`
    
-   `std::lexicographical_compare`
    
-   `std::all_of`
    
-   `std::any_of`
    
-   `std::none_of`
    

### Удаление последнего элемента вектора

Для «удаления» последнего элемента служит метод  `PopBack`:

```cpp
template <typename Type>
class SimpleVector {
public:
    void PopBack() noexcept { ... };
};

```

Чтобы удалить последний элемент непустого контейнера SimpleVector нужно уменьшить значение поля  `size_`. Элемент продолжит находиться в векторе, но будет недоступен для использования.

Не допускается вызывать  `PopBack`, когда вектор пуст. Такая же особенность есть и у метода  `pop_back`  стандартного вектора.

### Добавление элемента в конец вектора

Для вставки элемента в конец вектора служит метод  `PushBack`:

```cpp
template <typename Type>
class SimpleVector {
public:
    void PushBack(const Type& value) { ... };
};

```

При добавлении элемента в конец вектора возможны две ситуации, зависящие от того, заполнен вектор полностью или нет.

Когда вектор заполнен частично, запишем вставляемый элемент следом за последним элементом вектора и увеличим его размер.

Чуть сложнее обстоит ситуация, когда вектор заполнен полностью. В этом случае выделите новый массив с удвоенной вместимостью, скопируйте в него элементы исходного массива, а в конец поместите вставляемый элемент. После этого можно обновить размер и вместимость вектора, переключиться на новый массив, а старый массив — удалить.

При выполнении метода  `PushBack`  в куче выделяется память и вызывается оператор присваивания у элементов массива. Эти операции могут выбросить исключение. Чтобы сделать метод устойчивым к возникновению исключений, примените умный указатель  `ArrayPtr`, а поля  `size_`  и  `capacity_`  измените после того, как скопируете элементы в новый массив.

Так как при вставке значения в конец заполненного вектора происходит пересоздание массива элементов, операция  `PushBack`  делает невалидными существующие ссылки и итераторы. То же самое происходит и в случае  `std::vector`.

----------

Какую асимптотическую сложность имеет операция  `PushBack`  в классе  `SimpleVector`? Выберите один ответ. В вариантах ответа буквой N обозначается размер вектора.

-   O(1)
    
-   O(Log(N))
    
-   O(N)
    
-   O(N*Log(N))
    
-   O(N^2)
    

### Удаление элемента из произвольного места вектора

Для удаления произвольного элемента вектора служит метод  `Erase`. Он принимает итератор, указывающий на удаляемый элемент вектора, и возвращает итератор, который ссылается на элемент, следующий за удалённым:

```cpp
template <typename Type>
class SimpleVector {
public:
    Iterator Erase(ConstIterator pos) { ... }
    ...
};

```

При работе этого метода элементы, следующие за удаляемым, должны быть скопированы на его место один за другим. После того, как все элементы будут скопированы, нужно уменьшить размер массива и вернуть указатель на элемент, следующий за удалённым.

При копировании элементов на место удалённого ранее хранившиеся в массиве значения перезаписываются. Если в середине такого процесса будет выброшено исключение, восстановить прежнее значение перезаписанных элементов массива будет невозможно. В этом случае вектор останется в согласованном, пусть и не первоначальном состоянии. В таком случае говорят, что метод предоставляет базовую гарантию безопасности исключений.

Обеспечить строгую гарантию безопасности исключений можно, создав новую копию массива в методе  `Erase`, что негативно повлияло бы на производительность. По этой же причине метод  `vector::erase`  также даёт базовый уровень гарантий безопасности исключений.

### Вставка элемента в произвольное место вектора

Для вставки элемента в произвольное место вектора служит метод  `Insert`. Он принимает итератор, ссылающийся на место вставки, и само вставляемое значение. Метод возвращает итератор, который ссылается на вставленный элемент:

```cpp
template <typename Type>
class SimpleVector {
public:
    Iterator Insert(ConstIterator pos, const Type& value) { ... }
    ...
};

```

Как и в случае с  `PushBack`, при вставке возможны две ситуации:

-   вектор заполнен частично,
-   вектор заполнен полностью.

При частичной заполненности вектора элементы, начиная с позиции вставки, сперва копируются на одну позицию «вправо».

После этого в освободившееся место записывается вставляемый элемент и увеличивается размер вектора.

----------

Какой алгоритм подойдёт для копирования диапазона элементов массива «вправо» на одну позицию?

-   `std::copy`
    
-   `std::reverse`
    
-   `std::reverse_copy`
    
-   `std::copy_backward`
    

Когда элемент вставляется в заполненный вектор, в куче выделяется массив с удвоенной вместимостью. В этот массив копируются элементы, которые предшествуют вставляемому, сам вставляемый элемент и элементы, следующие за ним. В конце вектор обновляет свой размер и вместимость, начинает ссылаться на новый массив, а старый массив удаляет:

Как и в случае с  `Erase`, базовая гарантия безопасности исключений естественна для метода  `Insert`. Аналогичное решение принято и для метода  `insert`  класса  `std::vector`.

Строгой гарантии безопасности исключений можно добиться так: сделать копию вектора, модифицировать её, а в конце обменять содержимое оригинала и копии.

### Обмен содержимого векторов

Для обмена содержимого текущего вектора с другим предназначен метод  `swap`:

```cpp
template <typename Type>
class SimpleVector {
public:
    void swap(SimpleVector& other) noexcept { ... }
};

```

Чтобы обменять содержимое векторов, достаточно обменять значения их полей. Эта операция выполняется за константное время, не требует выделения памяти и не бросает исключений.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

----------

Какой стандартный алгоритм позволит реализовать операторы  `<`,  `<=`,  `>`,  `>=`  в классе  `SimpleVector`? Выберите один ответ.

-   **(-)**  `std::equal`

> Этот алгоритм проверяет, содержат ли два диапазона одной длины одинаковые элементы. И хотя он позволит реализовать операции  `==`  и  `!=`, требуемый набор операций реализовать не получится.

-   **(+)**  `std::lexicographical_compare`

> Этот алгоритм выполняет лексикографическое сравнение элементов двух диапазонов. Он позволит реализовать оператор  `<`, а остальные операции можно выразить на основе оператора  `<`.

-   **(-)**  `std::all_of`

> Этот алгоритм проверяет, удовлетворяют ли все элементы диапазона некоторому условию.

-   **(-)**  `std::any_of`

> Этот алгоритм проверяет, удовлетворяет ли хотя бы один элемент диапазона некоторому условию.

-   **(-)**  `std::none_of`

> Этот алгоритм проверяет, что ни один из элементов диапазона не удовлетворяет некоторому условию.

----------

Какую асимптотическую сложность имеет операция  `PushBack`  в классе  `SimpleVector`? Выберите один ответ. В вариантах ответа буквой N обозначается размер вектора.

-   **(+)**  O(1)

> Операция вставки в конец SimpleVector имеет константную амортизированную сложность за счёт того, что при заполнении массива его вместимость увеличивается вдвое. Для N вызовов  `PushBack`  суммарное количество операций над элементами массива будет зависеть от N линейно.

-   **(-)**  O(Log(N))
    
-   **(-)**  O(N)
    
-   **(-)**  O(N*Log(N))
    
-   **(-)**  O(N^2)
    

----------

Какой алгоритм подойдёт для копирования диапазона элементов массива «вправо» на одну позицию?

-   **(-)**  `std::copy`

> Данный алгоритм копирует элементы «слева направо» и требует, чтобы начало диапазона назначения находилось за пределами исходного диапазона. При копировании «вправо» на одну позицию это условие не выполняется, если длина диапазона превышает 1. Это приведёт к неопределённому поведению.

-   **(-)**  `std::reverse`

> Этот алгоритм изменяет порядок элементов диапазона на противоположный.

-   **(-)**  `std::reverse_copy`

> Этот алгоритм создаёт реверсированную копию исходного диапазона.

-   **(+)**  `std::copy_backward`

> Этот алгоритм скопирует элементы диапазона, начиная с самого последнего. Такой порядок подходит для копирования элементов контейнера «вправо».

</details>

<details>
<summary>Задание:</summary>

## Задание

Реализуйте в классе SimpleVector следующие операции:

-   Конструктор копирования. Копия вектора должна иметь вместимость, достаточную для хранения копии элементов исходного вектора.
-   Оператор присваивания. Должен обеспечивать строгую гарантию безопасности исключений.
-   Метод  `PushBack`, добавляющий элемент в конец вектора. Должен обеспечивать строгую гарантию безопасности исключений.
-   Метод  `PopBack`, удаляющий последний элемент вектора. Не выбрасывает исключений.
-   Метод  `Insert`, вставляющий элемент в произвольное место контейнера. Обеспечивает базовую гарантию безопасности исключений.
-   Метод  `Erase`, удаляющий элемент в произвольной позиции вектора. Обеспечивает базовую гарантию безопасности исключений.
-   Метод  `swap`, обменивающий содержимое вектора с другим вектором. Не выбрасывает исключений, имеет время выполнения O(1).
-   Операторы  `==`  и  `!=`. Два вектора равны, если их размеры равны и содержат равные элементы. Равенство вместимости не требуется.
-   Операторы  `<`,  `>`,  `<=`,  `>=`, выполняющие лексикографическое сравнение содержимого двух векторов.

Сигнатура новых методов:

```cpp
template <typename Type>
class SimpleVector {
public:
    ...
    SimpleVector(const SimpleVector& other) {
        // Напишите тело конструктора самостоятельно
    }

    SimpleVector& operator=(const SimpleVector& rhs) {
        // Напишите тело конструктора самостоятельно
        return *this;
    }

    // Добавляет элемент в конец вектора
    // При нехватке места увеличивает вдвое вместимость вектора
    void PushBack(const Type& item) {
        // Напишите тело самостоятельно
    }

    // Вставляет значение value в позицию pos.
    // Возвращает итератор на вставленное значение
    // Если перед вставкой значения вектор был заполнен полностью,
    // вместимость вектора должна увеличиться вдвое, а для вектора вместимостью 0 стать равной 1
    Iterator Insert(ConstIterator pos, const Type& value) {
        // Напишите тело самостоятельно
    }

    // "Удаляет" последний элемент вектора. Вектор не должен быть пустым
    void PopBack() noexcept {
        // Напишите тело самостоятельно
    }

    // Удаляет элемент вектора в указанной позиции
    Iterator Erase(ConstIterator pos) {
        // Напишите тело самостоятельно
    }

    // Обменивает значение с другим вектором
    void swap(SimpleVector& other) noexcept {
        // Напишите тело самостоятельно
    }
    ...
};

template <typename Type>
inline bool operator==(const SimpleVector<Type>& lhs, const SimpleVector<Type>& rhs) {
    // Заглушка. Напишите тело самостоятельно
    return true;
}

template <typename Type>
inline bool operator!=(const SimpleVector<Type>& lhs, const SimpleVector<Type>& rhs) {
    // Заглушка. Напишите тело самостоятельно
    return true;
}

template <typename Type>
inline bool operator<(const SimpleVector<Type>& lhs, const SimpleVector<Type>& rhs) {
    // Заглушка. Напишите тело самостоятельно
    return true;
}

template <typename Type>
inline bool operator<=(const SimpleVector<Type>& lhs, const SimpleVector<Type>& rhs) {
    // Заглушка. Напишите тело самостоятельно
    return true;
}

template <typename Type>
inline bool operator>(const SimpleVector<Type>& lhs, const SimpleVector<Type>& rhs) {
    // Заглушка. Напишите тело самостоятельно
    return true;
}

template <typename Type>
inline bool operator>=(const SimpleVector<Type>& lhs, const SimpleVector<Type>& rhs) {
    // Заглушка. Напишите тело самостоятельно
    return true;
}

```

Тесты, которые помогут проверить решение:

`tests.h`

```cpp
#pragma once
#include <cassert>
#include <stdexcept>

inline void Test1() {
    // Инициализация конструктором по умолчанию
    {
        SimpleVector<int> v;
        assert(v.GetSize() == 0u);
        assert(v.IsEmpty());
        assert(v.GetCapacity() == 0u);
    }

    // Инициализация вектора указанного размера
    {
        SimpleVector<int> v(5);
        assert(v.GetSize() == 5u);
        assert(v.GetCapacity() == 5u);
        assert(!v.IsEmpty());
        for (size_t i = 0; i < v.GetSize(); ++i) {
            assert(v[i] == 0);
        }
    }

    // Инициализация вектора, заполненного заданным значением
    {
        SimpleVector<int> v(3, 42);
        assert(v.GetSize() == 3);
        assert(v.GetCapacity() == 3);
        for (size_t i = 0; i < v.GetSize(); ++i) {
            assert(v[i] == 42);
        }
    }

    // Инициализация вектора при помощи initializer_list
    {
        SimpleVector<int> v{1, 2, 3};
        assert(v.GetSize() == 3);
        assert(v.GetCapacity() == 3);
        assert(v[2] == 3);
    }

    // Доступ к элементам при помощи At
    {
        SimpleVector<int> v(3);
        assert(&v.At(2) == &v[2]);
        try {
            v.At(3);
            assert(false);  // Ожидается выбрасывание исключения
        } catch (const std::out_of_range&) {
        } catch (...) {
            assert(false);  // Не ожидается исключение, отличное от out_of_range
        }
    }

    // Очистка вектора
    {
        SimpleVector<int> v(10);
        const size_t old_capacity = v.GetCapacity();
        v.Clear();
        assert(v.GetSize() == 0);
        assert(v.GetCapacity() == old_capacity);
    }

    // Изменение размера
    {
        SimpleVector<int> v(3);
        v[2] = 17;
        v.Resize(7);
        assert(v.GetSize() == 7);
        assert(v.GetCapacity() >= v.GetSize());
        assert(v[2] == 17);
        assert(v[3] == 0);
    }
    {
        SimpleVector<int> v(3);
        v[0] = 42;
        v[1] = 55;
        const size_t old_capacity = v.GetCapacity();
        v.Resize(2);
        assert(v.GetSize() == 2);
        assert(v.GetCapacity() == old_capacity);
        assert(v[0] == 42);
        assert(v[1] == 55);
    }
    {
        const size_t old_size = 3;
        SimpleVector<int> v(3);
        v.Resize(old_size + 5);
        v[3] = 42;
        v.Resize(old_size);
        v.Resize(old_size + 2);
        assert(v[3] == 0);
    }

    // Итерирование по SimpleVector
    {
        // Пустой вектор
        {
            SimpleVector<int> v;
            assert(v.begin() == nullptr);
            assert(v.end() == nullptr);
        }

        // Непустой вектор
        {
            SimpleVector<int> v(10, 42);
            assert(v.begin());
            assert(*v.begin() == 42);
            assert(v.end() == v.begin() + v.GetSize());
        }
    }
}

inline void Test2() {
    // PushBack
    {
        SimpleVector<int> v(1);
        v.PushBack(42);
        assert(v.GetSize() == 2);
        assert(v.GetCapacity() >= v.GetSize());
        assert(v[0] == 0);
        assert(v[1] == 42);
    }

    // Если хватает места, PushBack не увеличивает Capacity
    {
        SimpleVector<int> v(2);
        v.Resize(1);
        const size_t old_capacity = v.GetCapacity();
        v.PushBack(123);
        assert(v.GetSize() == 2);
        assert(v.GetCapacity() == old_capacity);
    }

    // PopBack
    {
        SimpleVector<int> v{0, 1, 2, 3};
        const size_t old_capacity = v.GetCapacity();
        const auto old_begin = v.begin();
        v.PopBack();
        assert(v.GetCapacity() == old_capacity);
        assert(v.begin() == old_begin);
        assert((v == SimpleVector<int>{0, 1, 2}));
    }

    // Конструктор копирования
    {
        SimpleVector<int> numbers{1, 2};
        auto numbers_copy(numbers);
        assert(&numbers_copy[0] != &numbers[0]);
        assert(numbers_copy.GetSize() == numbers.GetSize());
        for (size_t i = 0; i < numbers.GetSize(); ++i) {
            assert(numbers_copy[i] == numbers[i]);
            assert(&numbers_copy[i] != &numbers[i]);
        }
    }

    // Сравнение
    {
        assert((SimpleVector{1, 2, 3} == SimpleVector{1, 2, 3}));
        assert((SimpleVector{1, 2, 3} != SimpleVector{1, 2, 2}));

        assert((SimpleVector{1, 2, 3} < SimpleVector{1, 2, 3, 1}));
        assert((SimpleVector{1, 2, 3} > SimpleVector{1, 2, 2, 1}));

        assert((SimpleVector{1, 2, 3} >= SimpleVector{1, 2, 3}));
        assert((SimpleVector{1, 2, 4} >= SimpleVector{1, 2, 3}));
        assert((SimpleVector{1, 2, 3} <= SimpleVector{1, 2, 3}));
        assert((SimpleVector{1, 2, 3} <= SimpleVector{1, 2, 4}));
    }

    // Обмен значений векторов
    {
        SimpleVector<int> v1{42, 666};
        SimpleVector<int> v2;
        v2.PushBack(0);
        v2.PushBack(1);
        v2.PushBack(2);
        const int* const begin1 = &v1[0];
        const int* const begin2 = &v2[0];

        const size_t capacity1 = v1.GetCapacity();
        const size_t capacity2 = v2.GetCapacity();

        const size_t size1 = v1.GetSize();
        const size_t size2 = v2.GetSize();

        static_assert(noexcept(v1.swap(v2)));
        v1.swap(v2);
        assert(&v2[0] == begin1);
        assert(&v1[0] == begin2);
        assert(v1.GetSize() == size2);
        assert(v2.GetSize() == size1);
        assert(v1.GetCapacity() == capacity2);
        assert(v2.GetCapacity() == capacity1);
    }

    // Присваивание
    {
        SimpleVector<int> src_vector{1, 2, 3, 4};
        SimpleVector<int> dst_vector{1, 2, 3, 4, 5, 6};
        dst_vector = src_vector;
        assert(dst_vector == src_vector);
    }

    // Вставка элементов
    {
        SimpleVector<int> v{1, 2, 3, 4};
        v.Insert(v.begin() + 2, 42);
        assert((v == SimpleVector<int>{1, 2, 42, 3, 4}));
    }

    // Удаление элементов
    {
        SimpleVector<int> v{1, 2, 3, 4};
        v.Erase(v.cbegin() + 2);
        assert((v == SimpleVector<int>{1, 2, 4}));
    }
}

```

### Ограничения

Недопустимо передавать в методы  `Insert`  и  `Erase`  невалидные итераторы и итераторы, полученные у другого вектора. Нельзя передавать в метод  `Erase`  и end-итератор текущего вектора. Вызывать  `PopBack`  у пустого вектора тоже нельзя.

Гарантируется, что тренажёр не будет передавать недопустимые значения итераторов в методы  `Insert`  и  `Erase`  и вызывать  `PopBack`  у пустого вектора. Поэтому не усложняйте реализацию этих методов.

### Что отправлять на проверку

Файл  `simple_vector.h`  с исходным кодом класса SimpleVector. Если нужно включить дополнительные заголовочные файлы, например, с кодом  `ArrayPtr`, отправьте их тоже. Если загрузите функцию  `main`, она будет заменена на версию из тренажёра.

### Как будет тестироваться ваш код

Сохраните сигнатуру методов класса  `SimpleVector`  неизменной, чтобы код скомпилировался без ошибок.

### Подсказка

-   В операторе  `=`  обработайте случай с самоприсваиванием.
-   Чтобы сделать оператор присваивания устойчивым к исключениям, примените идиому copy-and-swap.
-   При копировании элементов в пределах одного массива выберите между  `std::copy`  и  `std::copy_backward`  в зависимости от направления копирования элементов.

</details>
