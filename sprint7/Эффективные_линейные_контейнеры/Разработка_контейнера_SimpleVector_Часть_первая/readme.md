
<details>
<summary>Теория:</summary>

# Разработка контейнера SimpleVector. Часть первая

В этом и следующем уроках вы разработаете шаблонный класс  `SimpleVector`. Это сильно упрощённый аналог стандартного контейнера  `vector`, со сходной структурой и функционалом. Работа над SimpleVector поможет вам лучше понять устройство и особенности стандартного  `vector`.

### Устройство контейнера SimpleVector

В основе SimpleVector — массив в динамической памяти. Сам контейнер хранит лишь адрес начала массива, а также информацию о его текущем размере и вместимости:

-   Размер — количество элементов, содержащееся в массиве;
-   Вместимость — максимальное количество элементов, которые могут поместиться в массив.

```cpp
template <typename Type>
class SimpleVector {
public:
    ...
private:
    // Вместо сырого указателя лучше использовать умный указатель, такой как ArrayPtr
    Type* items_;

    size_t size_;
    size_t capacity_;
};

```

Можно провести аналогию с ведром воды —  `capacity_`  определяет максимальный объём воды, которая помещается в ведро, а  `size_`  — текущее количество воды в ведре.

Сконструированный по умолчанию вектор имеет нулевой размер и вместимость, а указатель на массив равен  `nullptr`.

----------

Размер контейнера SimpleVector равен 5, а его вместимость равна 8. На какой элемент массива в динамической памяти ссылается итератор  `end`? Введите ответ в виде числа.

### Изменение размера вектора

Как и  `std::vector`, класс SimpleVector может изменять свой размер в сторону увеличения и уменьшения. Для этого служит метод  `Resize`:

```cpp
template <typename T>
class SimpleVector {
public:
    void Resize(size_t new_size) { ... }
    ...
};

```

Самый простой случай — уменьшение размера массива. Для этого SimpleVector достаточно изменить значение поля  `size_`.

Таким образом, SimpleVector при уменьшении своего размера не удаляет элементы из массива. «Лишние» элементы продолжают существовать вплоть до удаления массива по адресу  `items_`. Например, до разрушения SimpleVector.

Чуть сложнее выглядит увеличение размера в пределах текущей вместимости контейнера. Помимо увеличения значения поля  `size_`  происходит заполнение новых элементов значением по умолчанию для типа  `Type`.

Чтобы заполнить элементы контейнера или массива одним и тем же значением, можно использовать алгоритм  [`std::fill`](https://en.cppreference.com/w/cpp/algorithm/fill). Он присваивает элементам диапазона заданное значение.

Так как SimpleVector — шаблонный класс, операция присваивания для некоторых типов  `Type`  может выбрасывать исключения. Например, при нехватке памяти. Чтобы обеспечить строгую гарантию безопасности исключений, меняйте размер массива лишь после успешного заполнения новых элементов значением по умолчанию.

Самое интересное происходит, когда новый размер превышает текущую вместимость SimpleVector. В этом случае SimpleVector создаёт новый массив большего размера в динамической памяти, куда копирует элементы исходного массива и инициализирует остальные элементы значением по умолчанию. Для копирования элементов подходит алгоритм  [`std::copy`](https://en.cppreference.com/w/cpp/algorithm/copy).

Подобно  `std::vector`  во многих реализациях стандартной библиотеки, новую вместимость SimpleVector можно выбрать как максимум из  `new_capacity`  и  `capacity_ * 2`. Удваивание вместимости минимизирует частоту копирований элементов из одного массива в другой.

После копирования и заполнения элементов нулевым значением можно обновить  `size_`  и  `capacity_`, а старый массив — удалить. Так вы обеспечите строгую гарантию безопасности исключений. Умный указатель  `ArrayPtr`  позволит сделать код не только надёжнее, но и проще.

----------

Какую асимптотическую сложность имеет операция  `Resize`  в классе SimpleVector? Выберите один ответ.

-   O(1)
    
-   O(Log(N))
    
-   O(N)
    
-   O(N*Log(N))
    
-   O(N^2)
    

### Очистка контейнера SimpleVector

Очистку SimpleVector выполняет метод  `Clear`. Он не изменяет его вместимость и семантически эквивалентен вызову  `Resize`  с аргументом, равным нулю. Метод  `Clear`  не выбрасывает исключений.

```cpp
template <typename T>
class SimpleVector {
public:
    void Clear(size_t new_size) noexcept { ... }
    ...
};

```

----------

Какую асимптотическую сложность имеет операция  `Clear`  в классе SimpleVector? Выберите один ответ.

-   O(1)
    
-   O(Log(N))
    
-   O(N)
    
-   O(N*Log(N))
    
-   O(N^2)


# Разработка контейнера SimpleVector. Часть вторая

В предыдущем уроке вы познакомились с устройством SimpleVector и создали в нём операции для управления размером контейнера и доступа к его элементам. В этом уроке вы реализуете:

-   возможность сравнивать содержимое векторов, вставлять и удалять элементы;
-   пользовательский конструктор копирования;
-   пользовательский оператор присваивания.

### Сравнение содержимого векторов

Вы уже реализовали операцию сравнения содержимого односвязных списков. Аналогично можно реализовать операции сравнения векторов, применив известные вам стандартные алгоритмы.

При сравнении векторов их вместимость нужно игнорировать. Например, два вектора одного размера, содержащие одни и те же элементы, равны, даже если имеют разную вместимость.

----------

Какой стандартный алгоритм позволит реализовать операторы  `<`,  `<=`,  `>`,  `>=`  в классе  `SimpleVector`? Выберите один ответ.

-   `std::equal`
    
-   `std::lexicographical_compare`
    
-   `std::all_of`
    
-   `std::any_of`
    
-   `std::none_of`
    

### Удаление последнего элемента вектора

Для «удаления» последнего элемента служит метод  `PopBack`:

```cpp
template <typename Type>
class SimpleVector {
public:
    void PopBack() noexcept { ... };
};

```

Чтобы удалить последний элемент непустого контейнера SimpleVector нужно уменьшить значение поля  `size_`. Элемент продолжит находиться в векторе, но будет недоступен для использования.

Не допускается вызывать  `PopBack`, когда вектор пуст. Такая же особенность есть и у метода  `pop_back`  стандартного вектора.

### Добавление элемента в конец вектора

Для вставки элемента в конец вектора служит метод  `PushBack`:

```cpp
template <typename Type>
class SimpleVector {
public:
    void PushBack(const Type& value) { ... };
};

```

При добавлении элемента в конец вектора возможны две ситуации, зависящие от того, заполнен вектор полностью или нет.

Когда вектор заполнен частично, запишем вставляемый элемент следом за последним элементом вектора и увеличим его размер.

Чуть сложнее обстоит ситуация, когда вектор заполнен полностью. В этом случае выделите новый массив с удвоенной вместимостью, скопируйте в него элементы исходного массива, а в конец поместите вставляемый элемент. После этого можно обновить размер и вместимость вектора, переключиться на новый массив, а старый массив — удалить.

При выполнении метода  `PushBack`  в куче выделяется память и вызывается оператор присваивания у элементов массива. Эти операции могут выбросить исключение. Чтобы сделать метод устойчивым к возникновению исключений, примените умный указатель  `ArrayPtr`, а поля  `size_`  и  `capacity_`  измените после того, как скопируете элементы в новый массив.

Так как при вставке значения в конец заполненного вектора происходит пересоздание массива элементов, операция  `PushBack`  делает невалидными существующие ссылки и итераторы. То же самое происходит и в случае  `std::vector`.

----------

Какую асимптотическую сложность имеет операция  `PushBack`  в классе  `SimpleVector`? Выберите один ответ. В вариантах ответа буквой N обозначается размер вектора.

-   O(1)
    
-   O(Log(N))
    
-   O(N)
    
-   O(N*Log(N))
    
-   O(N^2)
    

### Удаление элемента из произвольного места вектора

Для удаления произвольного элемента вектора служит метод  `Erase`. Он принимает итератор, указывающий на удаляемый элемент вектора, и возвращает итератор, который ссылается на элемент, следующий за удалённым:

```cpp
template <typename Type>
class SimpleVector {
public:
    Iterator Erase(ConstIterator pos) { ... }
    ...
};

```

При работе этого метода элементы, следующие за удаляемым, должны быть скопированы на его место один за другим. После того, как все элементы будут скопированы, нужно уменьшить размер массива и вернуть указатель на элемент, следующий за удалённым.

При копировании элементов на место удалённого ранее хранившиеся в массиве значения перезаписываются. Если в середине такого процесса будет выброшено исключение, восстановить прежнее значение перезаписанных элементов массива будет невозможно. В этом случае вектор останется в согласованном, пусть и не первоначальном состоянии. В таком случае говорят, что метод предоставляет базовую гарантию безопасности исключений.

Обеспечить строгую гарантию безопасности исключений можно, создав новую копию массива в методе  `Erase`, что негативно повлияло бы на производительность. По этой же причине метод  `vector::erase`  также даёт базовый уровень гарантий безопасности исключений.

### Вставка элемента в произвольное место вектора

Для вставки элемента в произвольное место вектора служит метод  `Insert`. Он принимает итератор, ссылающийся на место вставки, и само вставляемое значение. Метод возвращает итератор, который ссылается на вставленный элемент:

```cpp
template <typename Type>
class SimpleVector {
public:
    Iterator Insert(ConstIterator pos, const Type& value) { ... }
    ...
};

```

Как и в случае с  `PushBack`, при вставке возможны две ситуации:

-   вектор заполнен частично,
-   вектор заполнен полностью.

При частичной заполненности вектора элементы, начиная с позиции вставки, сперва копируются на одну позицию «вправо».

После этого в освободившееся место записывается вставляемый элемент и увеличивается размер вектора.

----------

Какой алгоритм подойдёт для копирования диапазона элементов массива «вправо» на одну позицию?

-   `std::copy`
    
-   `std::reverse`
    
-   `std::reverse_copy`
    
-   `std::copy_backward`
    

Когда элемент вставляется в заполненный вектор, в куче выделяется массив с удвоенной вместимостью. В этот массив копируются элементы, которые предшествуют вставляемому, сам вставляемый элемент и элементы, следующие за ним. В конце вектор обновляет свой размер и вместимость, начинает ссылаться на новый массив, а старый массив удаляет:

Как и в случае с  `Erase`, базовая гарантия безопасности исключений естественна для метода  `Insert`. Аналогичное решение принято и для метода  `insert`  класса  `std::vector`.

Строгой гарантии безопасности исключений можно добиться так: сделать копию вектора, модифицировать её, а в конце обменять содержимое оригинала и копии.

### Обмен содержимого векторов

Для обмена содержимого текущего вектора с другим предназначен метод  `swap`:

```cpp
template <typename Type>
class SimpleVector {
public:
    void swap(SimpleVector& other) noexcept { ... }
};

```

Чтобы обменять содержимое векторов, достаточно обменять значения их полей. Эта операция выполняется за константное время, не требует выделения памяти и не бросает исключений.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

----------

Размер контейнера SimpleVector равен 5, а его вместимость равна 8. На какой элемент массива в динамической памяти ссылается итератор  `end`? Введите ответ в виде числа.

-   Итератор end ссылается на элемент, следующий за последним элементом контейнера. Последний элемент контейнера имеет индекс 4, следовательно, итератор end ссылается на элемент с индексом 5.

----------

Какую асимптотическую сложность имеет операция  `Resize`  в классе SimpleVector? Выберите один ответ.

-   **(-)**  O(1)
    
-   **(-)**  O(Log(N))
    
-   **(+)**  O(N)
    

> Худший случай работы метода  `Resize(N)`  происходит при увеличении размера с изменением вместимости контейнера. В этом случае надо скопировать в новый массив  `k`  существующих элементов и присвоить  `N-k`  элементам значение по умолчанию. Всего  `k + (N-k) = N`  операций.

-   **(-)**  O(N*Log(N))
    
-   **(-)**  O(N^2)
    

----------

Какую асимптотическую сложность имеет операция  `Clear`  в классе SimpleVector? Выберите один ответ.

-   **(+)**  O(1)

> Обнуление поля  `size_`  не зависит от количества элементов массива. Поэтому операция  `Clear`  выполняется за константное время.

-   **(-)**  O(Log(N))
    
-   **(-)**  O(N)
    
-   **(-)**  O(N*Log(N))
    
-   **(-)**  O(N^2)

# Ответы на задания

----------

Какой стандартный алгоритм позволит реализовать операторы  `<`,  `<=`,  `>`,  `>=`  в классе  `SimpleVector`? Выберите один ответ.

-   **(-)**  `std::equal`

> Этот алгоритм проверяет, содержат ли два диапазона одной длины одинаковые элементы. И хотя он позволит реализовать операции  `==`  и  `!=`, требуемый набор операций реализовать не получится.

-   **(+)**  `std::lexicographical_compare`

> Этот алгоритм выполняет лексикографическое сравнение элементов двух диапазонов. Он позволит реализовать оператор  `<`, а остальные операции можно выразить на основе оператора  `<`.

-   **(-)**  `std::all_of`

> Этот алгоритм проверяет, удовлетворяют ли все элементы диапазона некоторому условию.

-   **(-)**  `std::any_of`

> Этот алгоритм проверяет, удовлетворяет ли хотя бы один элемент диапазона некоторому условию.

-   **(-)**  `std::none_of`

> Этот алгоритм проверяет, что ни один из элементов диапазона не удовлетворяет некоторому условию.

----------

Какую асимптотическую сложность имеет операция  `PushBack`  в классе  `SimpleVector`? Выберите один ответ. В вариантах ответа буквой N обозначается размер вектора.

-   **(+)**  O(1)

> Операция вставки в конец SimpleVector имеет константную амортизированную сложность за счёт того, что при заполнении массива его вместимость увеличивается вдвое. Для N вызовов  `PushBack`  суммарное количество операций над элементами массива будет зависеть от N линейно.

-   **(-)**  O(Log(N))
    
-   **(-)**  O(N)
    
-   **(-)**  O(N*Log(N))
    
-   **(-)**  O(N^2)
    

----------

Какой алгоритм подойдёт для копирования диапазона элементов массива «вправо» на одну позицию?

-   **(-)**  `std::copy`

> Данный алгоритм копирует элементы «слева направо» и требует, чтобы начало диапазона назначения находилось за пределами исходного диапазона. При копировании «вправо» на одну позицию это условие не выполняется, если длина диапазона превышает 1. Это приведёт к неопределённому поведению.

-   **(-)**  `std::reverse`

> Этот алгоритм изменяет порядок элементов диапазона на противоположный.

-   **(-)**  `std::reverse_copy`

> Этот алгоритм создаёт реверсированную копию исходного диапазона.

-   **(+)**  `std::copy_backward`

> Этот алгоритм скопирует элементы диапазона, начиная с самого последнего. Такой порядок подходит для копирования элементов контейнера «вправо».

</details>

<details>
<summary>Задание:</summary>

## Задание

Разработайте шаблонный класс  `SimpleVector<Type>`, который будет упрощённым аналогом контейнера  `vector`, со следующим функционалом:

-   Конструкторы.
    -   По умолчанию. Создаёт пустой вектор с нулевой вместимостью. Не выделяет динамическую память и не выбрасывает исключений.
    -   Параметризованный конструктор, создающий вектор заданного размера. Элементы вектора инициализированы значением по умолчанию для типа  `Type`. Вектор должен иметь одинаковые размер и вместимость. Если размер нулевой, динамическая память для его элементов выделяться не должна.
    -   Конструктор из  `std::initializer_list`. Элементы вектора должны содержать копию элементов  `initializer_list`. Имеет размер и вместимость, совпадающую с размерами и вместимостью переданного  `initializer_list`.
-   Метод  `GetSize`  для получения количества элементов в векторе. Не выбрасывает исключений.
-   Метод  `GetCapacity`  для получения вместимости вектора. Не выбрасывает исключений.
-   Метод  `IsEmpty`, сообщающий, пуст ли вектор. Не выбрасывает исключений.
-   Оператор  `[]`  для доступа к элементу вектора по его индексу. Имеет две версии — константную и неконстантную. Не выбрасывает исключений. Для корректной работы оператора индекс элемента массива не должен выходить за пределы массива.
-   Метод  `At`  для доступа к элементу вектора по его индексу, аналог метода  `at`  класса vector. В случае выхода индекса за пределы массива должен выбросить исключение  `std::out_of_range`.
-   Метод  `Clear`  для очистки массива без изменения его вместимости. Не выбрасывает исключений.
-   Метод  `Resize`  для изменения количества элементов в массиве. Метод должен предоставлять строгую гарантию безопасности исключений.
-   Методы  `begin`,  `end`,  `cbegin`  и  `cend`, возвращающие итераторы на начало и конец массива. В качестве итераторов используйте указатели. Эти методы должны быть объявлены со спецификатором  `noexcept`. В противном случае тренажёр отклонит ваше решение.
-   При разрушении вектора должна освобождаться память, занимаемая его элементами.

### Ограничения

Гарантируется, что тренажёр при проверке решения не будет передавать в оператор  `[]`  индексы, выходящие за границы массива. При написании SimpleVector реализуйте самостоятельно работу с массивом в динамической памяти. Чтобы упростить управление массивом, пригодится разработанный в предыдущем спринте шаблонный класс  `ArrayPtr`. Не используйте класс  `std::vector`.

### Что отправлять на проверку

Файл  `simple_vector.h`  с исходным кодом класса SimpleVector. Если нужно включить дополнительные заголовочные файлы, например, с кодом  `ArrayPtr`, отправьте их тоже. Если загрузите функцию  `main`, она будет заменена на версию из тренажёра.

### Как будет тестироваться ваш код

Сохраните сигнатуру методов класса  `SimpleVector`  неизменной, чтобы код скомпилировался без ошибок, а тренажёр не отклонил ваше решение. Это особенно касается спецификатора  `noexcept`.

### Подсказка

-   В методе  `Resize`  отдельно обработайте три ситуации: новый размер меньше или равен текущему, новый размер не превышает его вместимости, новый размер превышает текущую вместимость вектора.
    -   Если при изменении размера массива новый размер вектора превышает его текущую вместимость, создайте новый массив с нужной вместимостью, скопируйте в него прежнее содержимое и заполните остальные элементы значением по умолчанию. Затем старый массив можно удалить и использовать копию. После этого не забудьте обновить размер и вместимость вектора.
    -   Если при увеличении размера массива новый размер вектора не превышает его вместимость, заполните добавленные элементы значением по умолчанию для типа  `Type`.
    -   При уменьшении размера вектора просто уменьшите его размер.
-   Примените алгоритмы  [std::copy](https://en.cppreference.com/w/cpp/algorithm/copy)  и  [std::fill](https://en.cppreference.com/w/cpp/algorithm/fill)  для копирования элементов массива и заполнения их некоторым значением.
-   В методе  `Clear`  достаточно обнулить размер массива.

## Задание

Реализуйте в классе SimpleVector следующие операции:

-   Конструктор копирования. Копия вектора должна иметь вместимость, достаточную для хранения копии элементов исходного вектора.
-   Оператор присваивания. Должен обеспечивать строгую гарантию безопасности исключений.
-   Метод  `PushBack`, добавляющий элемент в конец вектора. Должен обеспечивать строгую гарантию безопасности исключений.
-   Метод  `PopBack`, удаляющий последний элемент вектора. Не выбрасывает исключений.
-   Метод  `Insert`, вставляющий элемент в произвольное место контейнера. Обеспечивает базовую гарантию безопасности исключений.
-   Метод  `Erase`, удаляющий элемент в произвольной позиции вектора. Обеспечивает базовую гарантию безопасности исключений.
-   Метод  `swap`, обменивающий содержимое вектора с другим вектором. Не выбрасывает исключений, имеет время выполнения O(1).
-   Операторы  `==`  и  `!=`. Два вектора равны, если их размеры равны и содержат равные элементы. Равенство вместимости не требуется.
-   Операторы  `<`,  `>`,  `<=`,  `>=`, выполняющие лексикографическое сравнение содержимого двух векторов.

Сигнатура новых методов:

```cpp
template <typename Type>
class SimpleVector {
public:
    ...
    SimpleVector(const SimpleVector& other) {
        // Напишите тело конструктора самостоятельно
    }

    SimpleVector& operator=(const SimpleVector& rhs) {
        // Напишите тело конструктора самостоятельно
        return *this;
    }

    // Добавляет элемент в конец вектора
    // При нехватке места увеличивает вдвое вместимость вектора
    void PushBack(const Type& item) {
        // Напишите тело самостоятельно
    }

    // Вставляет значение value в позицию pos.
    // Возвращает итератор на вставленное значение
    // Если перед вставкой значения вектор был заполнен полностью,
    // вместимость вектора должна увеличиться вдвое, а для вектора вместимостью 0 стать равной 1
    Iterator Insert(ConstIterator pos, const Type& value) {
        // Напишите тело самостоятельно
    }

    // "Удаляет" последний элемент вектора. Вектор не должен быть пустым
    void PopBack() noexcept {
        // Напишите тело самостоятельно
    }

    // Удаляет элемент вектора в указанной позиции
    Iterator Erase(ConstIterator pos) {
        // Напишите тело самостоятельно
    }

    // Обменивает значение с другим вектором
    void swap(SimpleVector& other) noexcept {
        // Напишите тело самостоятельно
    }
    ...
};

template <typename Type>
inline bool operator==(const SimpleVector<Type>& lhs, const SimpleVector<Type>& rhs) {
    // Заглушка. Напишите тело самостоятельно
    return true;
}

template <typename Type>
inline bool operator!=(const SimpleVector<Type>& lhs, const SimpleVector<Type>& rhs) {
    // Заглушка. Напишите тело самостоятельно
    return true;
}

template <typename Type>
inline bool operator<(const SimpleVector<Type>& lhs, const SimpleVector<Type>& rhs) {
    // Заглушка. Напишите тело самостоятельно
    return true;
}

template <typename Type>
inline bool operator<=(const SimpleVector<Type>& lhs, const SimpleVector<Type>& rhs) {
    // Заглушка. Напишите тело самостоятельно
    return true;
}

template <typename Type>
inline bool operator>(const SimpleVector<Type>& lhs, const SimpleVector<Type>& rhs) {
    // Заглушка. Напишите тело самостоятельно
    return true;
}

template <typename Type>
inline bool operator>=(const SimpleVector<Type>& lhs, const SimpleVector<Type>& rhs) {
    // Заглушка. Напишите тело самостоятельно
    return true;
}

```

Тесты, которые помогут проверить решение:

`tests.h`

```cpp
#pragma once
#include <cassert>
#include <stdexcept>

inline void Test1() {
    // Инициализация конструктором по умолчанию
    {
        SimpleVector<int> v;
        assert(v.GetSize() == 0u);
        assert(v.IsEmpty());
        assert(v.GetCapacity() == 0u);
    }

    // Инициализация вектора указанного размера
    {
        SimpleVector<int> v(5);
        assert(v.GetSize() == 5u);
        assert(v.GetCapacity() == 5u);
        assert(!v.IsEmpty());
        for (size_t i = 0; i < v.GetSize(); ++i) {
            assert(v[i] == 0);
        }
    }

    // Инициализация вектора, заполненного заданным значением
    {
        SimpleVector<int> v(3, 42);
        assert(v.GetSize() == 3);
        assert(v.GetCapacity() == 3);
        for (size_t i = 0; i < v.GetSize(); ++i) {
            assert(v[i] == 42);
        }
    }

    // Инициализация вектора при помощи initializer_list
    {
        SimpleVector<int> v{1, 2, 3};
        assert(v.GetSize() == 3);
        assert(v.GetCapacity() == 3);
        assert(v[2] == 3);
    }

    // Доступ к элементам при помощи At
    {
        SimpleVector<int> v(3);
        assert(&v.At(2) == &v[2]);
        try {
            v.At(3);
            assert(false);  // Ожидается выбрасывание исключения
        } catch (const std::out_of_range&) {
        } catch (...) {
            assert(false);  // Не ожидается исключение, отличное от out_of_range
        }
    }

    // Очистка вектора
    {
        SimpleVector<int> v(10);
        const size_t old_capacity = v.GetCapacity();
        v.Clear();
        assert(v.GetSize() == 0);
        assert(v.GetCapacity() == old_capacity);
    }

    // Изменение размера
    {
        SimpleVector<int> v(3);
        v[2] = 17;
        v.Resize(7);
        assert(v.GetSize() == 7);
        assert(v.GetCapacity() >= v.GetSize());
        assert(v[2] == 17);
        assert(v[3] == 0);
    }
    {
        SimpleVector<int> v(3);
        v[0] = 42;
        v[1] = 55;
        const size_t old_capacity = v.GetCapacity();
        v.Resize(2);
        assert(v.GetSize() == 2);
        assert(v.GetCapacity() == old_capacity);
        assert(v[0] == 42);
        assert(v[1] == 55);
    }
    {
        const size_t old_size = 3;
        SimpleVector<int> v(3);
        v.Resize(old_size + 5);
        v[3] = 42;
        v.Resize(old_size);
        v.Resize(old_size + 2);
        assert(v[3] == 0);
    }

    // Итерирование по SimpleVector
    {
        // Пустой вектор
        {
            SimpleVector<int> v;
            assert(v.begin() == nullptr);
            assert(v.end() == nullptr);
        }

        // Непустой вектор
        {
            SimpleVector<int> v(10, 42);
            assert(v.begin());
            assert(*v.begin() == 42);
            assert(v.end() == v.begin() + v.GetSize());
        }
    }
}

inline void Test2() {
    // PushBack
    {
        SimpleVector<int> v(1);
        v.PushBack(42);
        assert(v.GetSize() == 2);
        assert(v.GetCapacity() >= v.GetSize());
        assert(v[0] == 0);
        assert(v[1] == 42);
    }

    // Если хватает места, PushBack не увеличивает Capacity
    {
        SimpleVector<int> v(2);
        v.Resize(1);
        const size_t old_capacity = v.GetCapacity();
        v.PushBack(123);
        assert(v.GetSize() == 2);
        assert(v.GetCapacity() == old_capacity);
    }

    // PopBack
    {
        SimpleVector<int> v{0, 1, 2, 3};
        const size_t old_capacity = v.GetCapacity();
        const auto old_begin = v.begin();
        v.PopBack();
        assert(v.GetCapacity() == old_capacity);
        assert(v.begin() == old_begin);
        assert((v == SimpleVector<int>{0, 1, 2}));
    }

    // Конструктор копирования
    {
        SimpleVector<int> numbers{1, 2};
        auto numbers_copy(numbers);
        assert(&numbers_copy[0] != &numbers[0]);
        assert(numbers_copy.GetSize() == numbers.GetSize());
        for (size_t i = 0; i < numbers.GetSize(); ++i) {
            assert(numbers_copy[i] == numbers[i]);
            assert(&numbers_copy[i] != &numbers[i]);
        }
    }

    // Сравнение
    {
        assert((SimpleVector{1, 2, 3} == SimpleVector{1, 2, 3}));
        assert((SimpleVector{1, 2, 3} != SimpleVector{1, 2, 2}));

        assert((SimpleVector{1, 2, 3} < SimpleVector{1, 2, 3, 1}));
        assert((SimpleVector{1, 2, 3} > SimpleVector{1, 2, 2, 1}));

        assert((SimpleVector{1, 2, 3} >= SimpleVector{1, 2, 3}));
        assert((SimpleVector{1, 2, 4} >= SimpleVector{1, 2, 3}));
        assert((SimpleVector{1, 2, 3} <= SimpleVector{1, 2, 3}));
        assert((SimpleVector{1, 2, 3} <= SimpleVector{1, 2, 4}));
    }

    // Обмен значений векторов
    {
        SimpleVector<int> v1{42, 666};
        SimpleVector<int> v2;
        v2.PushBack(0);
        v2.PushBack(1);
        v2.PushBack(2);
        const int* const begin1 = &v1[0];
        const int* const begin2 = &v2[0];

        const size_t capacity1 = v1.GetCapacity();
        const size_t capacity2 = v2.GetCapacity();

        const size_t size1 = v1.GetSize();
        const size_t size2 = v2.GetSize();

        static_assert(noexcept(v1.swap(v2)));
        v1.swap(v2);
        assert(&v2[0] == begin1);
        assert(&v1[0] == begin2);
        assert(v1.GetSize() == size2);
        assert(v2.GetSize() == size1);
        assert(v1.GetCapacity() == capacity2);
        assert(v2.GetCapacity() == capacity1);
    }

    // Присваивание
    {
        SimpleVector<int> src_vector{1, 2, 3, 4};
        SimpleVector<int> dst_vector{1, 2, 3, 4, 5, 6};
        dst_vector = src_vector;
        assert(dst_vector == src_vector);
    }

    // Вставка элементов
    {
        SimpleVector<int> v{1, 2, 3, 4};
        v.Insert(v.begin() + 2, 42);
        assert((v == SimpleVector<int>{1, 2, 42, 3, 4}));
    }

    // Удаление элементов
    {
        SimpleVector<int> v{1, 2, 3, 4};
        v.Erase(v.cbegin() + 2);
        assert((v == SimpleVector<int>{1, 2, 4}));
    }
}

```

### Ограничения

Недопустимо передавать в методы  `Insert`  и  `Erase`  невалидные итераторы и итераторы, полученные у другого вектора. Нельзя передавать в метод  `Erase`  и end-итератор текущего вектора. Вызывать  `PopBack`  у пустого вектора тоже нельзя.

Гарантируется, что тренажёр не будет передавать недопустимые значения итераторов в методы  `Insert`  и  `Erase`  и вызывать  `PopBack`  у пустого вектора. Поэтому не усложняйте реализацию этих методов.

### Что отправлять на проверку

Файл  `simple_vector.h`  с исходным кодом класса SimpleVector. Если нужно включить дополнительные заголовочные файлы, например, с кодом  `ArrayPtr`, отправьте их тоже. Если загрузите функцию  `main`, она будет заменена на версию из тренажёра.

### Как будет тестироваться ваш код

Сохраните сигнатуру методов класса  `SimpleVector`  неизменной, чтобы код скомпилировался без ошибок.

### Подсказка

-   В операторе  `=`  обработайте случай с самоприсваиванием.
-   Чтобы сделать оператор присваивания устойчивым к исключениям, примените идиому copy-and-swap.
-   При копировании элементов в пределах одного массива выберите между  `std::copy`  и  `std::copy_backward`  в зависимости от направления копирования элементов.

</details>
