<details>
<summary>Теория:</summary>

# Для чего нужны инструменты поиска ошибок

Больша́я часть времени работы разработчика — поиск и исправление ошибок. Эта работа сравнима с работой сыщика — ведь к неправильному поведению программы часто приводит череда запутанных событий. И ваша задача распутать их, найти «преступника» — баг, а затем обезвредить его. Вы уже занимались этим в теме о юнит-тестировании. В данной теме разберём, какие автоматические инструменты помогут вам собрать улики и стать настоящим Шерлоком Холмсом в мире программирования.

C++ отлично умеет находить ошибки во время компиляции. Это свойство строго типизированных языков — то есть таких, где, объявляя переменную типа  `string`, вы затем не можете записать в неё число. Строгая типизация положительно влияет не только на производительность программы, но и на способность выявлять ошибки при компиляции.

Чем раньше выявлена ошибка, тем проще будет найти её причину и исправить. А главное, ошибка не успеет наделать пакостей. Выявить её на таком раннем этапе как компиляция — прекрасно.

К сожалению, компилятор не оракул, и найдёт далеко не все ошибки. Для остальных багов существуют юнит-тесты. Но юнит-тесты пишут люди, а человек может забыть что-нибудь проверить. Даже опытный разработчик не в состоянии сделать совершенное покрытие юнит-тестами, гарантирующее правильную работу программы.

Если ошибка прошла сито компилятора и сито юнит тестов, то выявить её можно будет только в процессе работы программы. Причём сделать это нужно как можно раньше, после того, как она произошла, потому что баг, как и преступника, проще всего ловить по горячим следам. Ошибка, выявленная в процессе работы программы называется ошибкой времени выполнения.

C++ считают сложным языком, и одна из причин — слабый контроль ошибок времени выполнения. Но этому есть оправдание — принцип нулевого оверхэда:

> **Принцип нулевого оверхеда**
> 
> Код не должен совершать никаких действий, которые не являются необходимыми для выполнения его основной задачи.

Этот принцип применяется в стандартной библиотеке C++ и в целом при генерации кода. Контроль ошибок не нужен, если в программе нет ошибок. А если они есть, это вина разработчика, но не компилятора. Поэтому во многих алгоритмах, методах и операциях C++ контроль ошибок времени выполнения отсутствует полностью.

----------

Может показаться, что инструменты обнаружения ошибок не нужны — если ошибка сама себя не обнаружила, значит, она и не важна. Ведь нет смысла тратить время на баг, если он никак не проявляется. Как вы думаете, в чём недостатки такого подхода?

-   Баг может не проявляться на одном компиляторе, операционной системе, процессоре, но присутствовать на других конфигурациях, на которых тестирование не производилось.
    
-   Баг может проявляться только на определённых данных, которые при тестировании не проверяли. Например, на очень больших, возникших только в ходе длительной эксплуатации программы.
    
-   На баги особенно не нужно тратить время, исправлять их просто и быстро.
    
-   Баг может быть плавающим — в 99 случаях из 100 никак не вредить, но в одном всё портить. При тестировании очень просто не заметить такой баг.
    
-   Баг может не проявляться сейчас, но вылезти в будущем, когда другой код программы будет изменён.
    
-   Баг может испортить что-нибудь внутри программы, но последствия этого обнаружатся только спустя некоторое время, когда уже будет сложно определить, что именно привело к этому.
    
-   Ни в чём, рассуждение безупречно.
    

Как видите, инструменты всё же нужны. Помимо перечисленного они показывают точное место в коде, в котором допущена ошибка. Это упрощает её исправление.

</details>

<details>
<summary>Задание:</summary>

# Ответы на задания

Может показаться, что инструменты обнаружения ошибок не нужны — если ошибка сама себя не обнаружила, значит, она и не важна. Ведь нет смысла тратить время на баг, если он никак не проявляется. Как вы думаете, в чём недостатки такого подхода?

-   **(+)**  Баг может не проявляться на одном компиляторе, операционной системе, процессоре, но присутствовать на других конфигурациях, на которых тестирование не производилось.
    
-   **(+)**  Баг может проявляться только на определённых данных, которые при тестировании не проверяли. Например, на очень больших, возникших только в ходе длительной эксплуатации программы.
    
-   **(-)**  На баги особенно не нужно тратить время, исправлять их просто и быстро.
    
-   **(+)**  Баг может быть плавающим — в 99 случаях из 100 никак не вредить, но в одном всё портить. При тестировании очень просто не заметить такой баг.
    
-   **(+)**  Баг может не проявляться сейчас, но вылезти в будущем, когда другой код программы будет изменён.
    
-   **(+)**  Баг может испортить что-нибудь внутри программы, но последствия этого обнаружатся только спустя некоторое время, когда уже будет сложно определить, что именно привело к этому.
    
-   **(-)**  Ни в чём, рассуждение безупречно.

</details>
