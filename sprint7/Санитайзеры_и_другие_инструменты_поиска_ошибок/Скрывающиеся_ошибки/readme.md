
<details>
<summary>Теория:</summary>

# Скрывающиеся ошибки

Ошибки бывают очень коварны. Вначале они прячутся, а потом выскакивают в самый неудобный момент. В этом уроке попробуем найти и обезвредить ошибку традиционными способами.

Рассмотрим такой код для вычисления среднего арифметического числового вектора:

```cpp
#include <iostream>
#include <vector>

using namespace std;

template <class T>
double mean(const std::vector<T>& v) {
    T acc;

    for (size_t i = 0; i <= v.size(); ++i) {
        acc += v[i];
    }

    return static_cast<double>(acc) / v.size();
}

int main() {
    vector<double> u = {1, 2, 3, 4, 5};
    cout << "Mean: "s << mean(u) << endl;
}

```

Сохраним этот код в файл  `mean.cpp`. Будем использовать командную строку, поскольку в этой теме вам предстоит много работать с ней. Скомпилируем и запустим программу:

```
> g++ mean.cpp -o mean
> ./mean
Mean: 3

```

Так мы компилируем на UNIX-системах, под Windows мы запускали бы немного проще:

```
> g++ mean.cpp -o mean
> mean
Mean: 3

```

Программа выдала правильный ответ. Посмотрим, означает ли это, что в ней нет ошибок. Попробуем другой компилятор — Clang. Инструкции по его установке будут в одном из следующих уроков.

```cpp
> clang++ mean.cpp -o mean
> ./mean
Mean: -nan

```

Под Windows был бы такой код:

```cpp
> clang++ mean.cpp -o mean.exe
> mean
Mean: -nan

```

Как видим, результат уже другой — получилось особое значение, даже не число. Значит, в программе есть ошибки, и выявить их простым тестированием с g++ не получилось..

В этом уроке мы не пользуемся специальными средствами, поэтому остаётся одно «‎народное средство»‎ — добавить отладочные выводы в код программы. Они должны выводить информацию о состоянии программы. Так мы поймём, в какой момент что-то пошло не так.

```cpp
template <class T>
double mean(const std::vector<T>& v) {
    T acc;

    for (size_t i = 0; i <= v.size(); ++i) {
        acc += v[i];
        cout << "v["s << i << "] = "s << v[i] << endl;
        cout << "acc: "s << acc << endl;
    }

    return static_cast<double>(acc) / v.size();
}

```

Запустим программу и посмотрим на вывод:

```
Mean: v[0] = 1
acc: 1
v[1] = 2
acc: 3
v[2] = 3
acc: 6
v[3] = 4
acc: 10
v[4] = 5
acc: 15
v[5] = -1.08671e-311
acc: 15
3

```

Удивительно, но ответ внезапно стал правильным! Однако ошибка всё равно обнаружена: мы прибавляем лишнее слагаемое  `v[5]`, которое вообще отсутствует в векторе и имеет странное значение.

Мы обратились к несуществующему элементу вектора и не только не получили сообщения об ошибке, но даже в ряде случаев увидели правильный ответ. Значит,  `operator []`  для вектора не имеет никакого контроля ошибок. Сделано это из принципа нулевого оверхеда: проверка значения на соответствие диапазону создавала бы условный переход. Такая операция, как вы знаете из темы о профилировке, довольно затратна для процессора.

Чтобы избежать ошибок, можно перед каждым обращением к вектору вставить  `assert`, проверяющий корректность индекса. Либо использовать метод  `at`, который сгенерирует исключение при попытке обратиться к неверному индексу:

```cpp
template <class T>
double mean(const std::vector<T>& v) {
    T acc;

    for (size_t i = 0; i <= v.size(); ++i) {
        acc += v.at(i);
    }

    return static_cast<double>(acc) / v.size();
}

```

Поскольку исключение мы не ловим, при попытке запуска программа будет падать, сообщая о том, что в ней есть баг:

_________________________________________________
_________________________________________________
_________________________________________________
_________________________________________________
_________________________________________________
_________________________________________________
_________________________________________________
_________________________________________________

В консоли можно увидеть такое сообщение:

```cpp
> g++ mean.cpp -o mean
> ./mean
Mean: terminate called after throwing an instance of 'std::out_of_range'
  what():  vector::_M_range_check: __n (which is 5) >= this->size() (which is 5)

This application has requested the Runtime to terminate it in an unusual way.
Please contact the application's support team for more information.

```

Оно говорит, что проблема в обращении к несуществующему элементу вектора, и даже приводит некоторую конкретику: индекс элемента, размер вектора. Но из сообщения ничего не понятно о том, где именно баг в коде.

Чтобы найти проблемное место, соберём программу с отладочной информацией и без оптимизации. Затем запустим gdb и добавим команду  `break abort`, чтобы отладчик остановил выполнение при возникновении исключения. После остановки воспользуемся командой  `bt`  для нахождения места ошибки.

```cpp
> g++ mean.cpp -o mean -g -O0
> gdb mean
(gdb) break abort
Breakpoint 1 at 0x6144d595
(gdb) r
Mean:
Thread 1 hit Breakpoint 1, 0x000000006144d595 in msvcrt!abort ()
(gdb) bt
...
#8  0x0000000000402e38 in mean<double> (v=std::vector of length 5, capacity 5 = {...}) at mean.cpp:16
#9  0x0000000000401605 in main () at mean.cpp:25

```

Восьмой фрейм показывает точное место ошибки — файл и номер строки.

Как видите, выявлять ошибки вручную довольно сложно. Нам повезло, что мы догадались использовать  `at`  в нужном месте.

----------

Теперь представьте, что перед вами большая программа: сотни файлов и везде используются векторы. Но что-то в ней идёт не так, ответ выдаётся неверный. Вы подозреваете, что где-нибудь есть выход за пределы диапазона вектора. Подумайте, как можно обнаружить эту проблему?

-   Это делать не нужно, компилятор скомпилировал программу
    
-   Компилятор должен найти выход за границы вектора и сообщить об ошибке
    
-   Достаточно лишь заменить все операторы индексации на вызовы метода  `at`
    
-   Вы шутите? Нужен какой-то нормальный выход
    

Об этом выходе вы узнаете в следующем уроке.

</details>

<details>
<summary>Задание:</summary>

# Ответы на задания

Теперь представьте, что перед вами большая программа: сотни файлов и везде используются векторы. Но что-то в ней идёт не так, ответ выдаётся неверный. Вы подозреваете, что где-нибудь есть выход за пределы диапазона вектора. Подумайте, как можно обнаружить эту проблему?

-   **(-)**  Это делать не нужно, компилятор скомпилировал программу

> Но ответ-то неправильный!

-   **(-)**  Компилятор должен найти выход за границы вектора и сообщить об ошибке

> Компилятор такое не находит

-   **(-)**  Достаточно лишь заменить все операторы индексации на вызовы метода  `at`

> Такое себе удовольствие, а если где-то забудете?

-   **(+)**  Вы шутите? Нужен какой-то нормальный выход

</details>
