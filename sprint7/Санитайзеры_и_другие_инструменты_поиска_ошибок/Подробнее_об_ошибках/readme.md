<details>
<summary>Теория:</summary>

# Подробнее об ошибках

Санитайзер — прекрасный инструмент, который выявляет ошибки при работе программы. Делает он это не за просто так. Санитайзер может замедлять программу, но обычно не более, чем в два раза.

В прошлом уроке вы рассматривали один вид ошибок — использование памяти после её освобождения. Но Address sanitizer позволяет найти и другие проблемы.

### Выход за границы диапазона

Такую ошибку мы уже искали, используя отладочные макроопределения. Однако они сработают только в одном случае — применение  `operator []`  у вектора или  `string`. Если обращаетесь по индексу указателя, стандартная библиотека не контролирует этот процесс, а значит, не может сделать никаких проверок:

```cpp
#include <iostream>
#include <vector>

using namespace std;

template <class T>
double mean(const std::vector<T>& v) {
    T acc;
    const T* v_ptr = v.data();

    for (size_t i = 0; i <= v.size(); ++i) {
        acc += v_ptr[i];
    }

    return static_cast<double>(acc) / v.size();
}

int main() {
    vector<int> v = {1, 2, 3, 4, 5};
    cout << "Mean: "s << mean(v) << endl;
}

```

Запустим с отладочными макроопределениями:

```bash
> g++ mean.cpp -o median -D_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC
> ./mean
Mean: 3

```

Ошибка не выводится, хотя вы уже знаете, что она есть. Запустим теперь с санитайзером.

```bash
> clang++ mean.cpp -o mean -fsanitize=address -g
> ./mean
Mean: =================================================================
==12504==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x12580b1a0384 at pc 0x7ff704ce39d2 bp 0x00a1ac38f530 sp 0x00a1ac38f578
READ of size 4 at 0x12580b1a0384 thread T0
==12504==WARNING: Failed to use and restart external symbolizer!
    #0 0x7ff704ce39d1 in mean<int> .../mean.cpp:17
    #1 0x7ff704ce1288 in main .../mean.cpp:29
    #2 0x7ff704d46b3f in __scrt_common_main_seh ...\exe_common.inl:288
    #3 0x7ff941a484d3 in BaseThreadInitThunk+0x13 (C:\Windows\System32\KERNEL32.DLL+0x1800084d3)
    #4 0x7ff942dd1790 in RtlUserThreadStart+0x20 (C:\Windows\SYSTEM32\ntdll.dll+0x180051790)

```

Видим ошибку: heap-buffer-overflow. Она говорит, что мы вышли за пределы допустимого диапазона в куче.

Но учтите, иногда санитайзер может «пропустить» ошибку такого рода: например, если вы зарезервировали место в векторе методом  `reserve`:

```cpp
int main() {
    vector<int> v = {1, 2, 3, 4, 5};
    v.reserve(10);
    cout << "Mean: "s << mean(v) << endl;
}

```

Несмотря на то, что в функции  `mean`  по-прежнему есть выход за пределы границ вектора, санитайзер молчит: обращения производятся только к корректной, выделенной памяти. Такую ошибку могли бы выявить отладочные макроопределения.

Другой пример похожей ошибки — выход за пределы стека. Это может произойти при использовании обычных массивов или  `std::array`, которые размещаются в автоматической памяти. Вердикт санитайзера в этом случае будет: stack-buffer-overflow.

### Некорректное или двойное удаление

Удаление некорректного указателя — это всегда ошибка. Чаще всего она происходит, когда вы пытаетесь вызвать  `delete`  для указателя на память, которая уже была освобождена ранее.

Подобное может случиться, например, при некорректном использовании удаления в деструкторе:

```cpp
class IntArray {
public:
    IntArray(int n)
        : ptr(new int[n]) {
    }
    ~IntArray() {
        delete[] ptr;
    }

private:
    int* ptr;
};

int main() {
    IntArray a1(5);
    IntArray a2(a1);
}

```

----------

Как вы думаете, в чём проблема этой программы?

-   Удаления в деструкторе — некорректная операция, нужно убрать  `delete`.
    
-   В типе  `ptr`. Нужно использовать  `const int*`.
    
-   Два объекта  `IntArray`  будут содержать одинаковый указатель  `ptr`  и оба попытаются его удалить.
    

При запуске программа, конечно, упадёт, но не выдаст никакого сообщения. Однако если запускать с Address Sanitizer, сообщение будет вполне информативным:

```bash
> clang++ array.cpp -fsanitize=address -g -o array -std=c++17
> ./array
=================================================================
==9480==ERROR: AddressSanitizer: attempting double-free on 0x11f2529a0370 in thread T0:
==9480==WARNING: Failed to use and restart external symbolizer!
    #0 0x7ff793c7381d in operator delete[] ...\asan\asan_new_delete.cpp:163
    #1 0x7ff793c312ca in IntArray::~IntArray ...\array.cpp:5
    #2 0x7ff793c31151 in main ...\array.cpp:15
    #3 0x7ff793c748d7 in __scrt_common_main_seh ...\exe_common.inl:288
....

```

Сообщение attempting double-free явно указывает на проблему.

Ещё один пример похожей ошибки происходит, когда пытаетесь удалить память, которая вообще не была выделена.

Пример:

```cpp
#include <iostream>

using namespace std;

struct Point {
    int x;
    int y;
};

class PointHolder {
public:
    PointHolder(Point* pt)
        : pt_(pt) {
    }
    ~PointHolder() {
        delete pt_;
    }
    void Print() const {
        cout << "("s << pt_->x << ", "s << pt_->y << ")"s << endl;
    }

private:
    Point* pt_;
};

int main() {
    {
        PointHolder holder(new Point{10, 15});
        holder.Print();
    }  // OK
    {
        Point pt{10, 15};
        PointHolder holder(&pt);
        holder.Print();
    }  // ошибка: попытка удалить адрес в стеке
}

```

Вердикт санитайзера: bad-free. То же самое длинно: attempting free on address which was not malloc()-ed.

### Использование стека после удаления

В прошлом уроке вы видели, как возврат временного объекта из функции приводит к ошибке use-after-free. В том примере временный объект находился в куче. Возможен и другой вариант:

```cpp
#include <iostream>
#include <tuple>

using namespace std;

auto GetTuple(int x, int y) {
    return tie(x, y);
}

int main() {
    auto [x, y] = GetTuple(10, 15);
    cout << x << ' ' << y << endl;
    return 0;
}

```

Компилировать эту программу нужно с параметром  `-std=c++17`, поскольку в ней используются особенности стандарта C++17.

----------

В чём состоит ошибка?

-   `tie`  нельзя использовать для переменных типа  `int`.
    
-   Функция возвращает ссылку на временные объекты, размещённые в аргументах функции  `x`  и  `y`, нужно заменить  `tie`  на  `tuple`.
    
-   Функция возвращает ссылку на временные объекты, размещённые в аргументах функции. Нужно заменить тип аргументов на  `const int&`.
    

`x`  и  `y`  из  `main`  будут иметь выведенный тип  `int&`. Функция возвращает ссылку на свои аргументы:  `x`  и  `y`, но после её завершения аргументы удалятся, как и другие автоматические переменные функции, и ссылка будет указывать вникуда. Вердикт санитайзера stack-use-after-return. На некоторых операционных системах для выявления этой ошибки требуется определить переменную окружения  `ASAN_OPTIONS=detect_stack_use_after_return=1`. Определить переменную для текущего сеанса и собрать программу под Windows можно так:

```bash
> SET ASAN_OPTIONS=detect_stack_use_after_return=1
> clang++ tuple.cpp -o tuple.exe -std=c++17 -fsanitize=address -g -O1 -fno-omit-frame-pointer -fno-optimize-sibling-calls
> tuple

```

Под Linux и MacOS:

```bash
> export ASAN_OPTIONS=detect_stack_use_after_return=1
> clang++ tuple.cpp -o tuple -std=c++17 -fsanitize=address -g -O1 -fno-omit-frame-pointer -fno-optimize-sibling-calls
> ./tuple

```

Ошибкой также будет использование памяти, занимаемой переменной, после того, как программа вышла из области видимости этой переменной. Вердикт санитайзера в этом случае: stack-use-after-scope.

Пример программы:

```cpp
#include <functional>
#include <iostream>
using namespace std;

bool IsPrime(int x) {
    // чтобы проверить x на простоту
    // перебираем все числа до корня из x
    for (int i = 2; i * i <= x; ++i) {
        if (x % i == 0) {
            return false;
        }
    }

    return true;
}

int main() {
    // function из <functional> позволяет сохранить объект, 
    // ведущий себя подобно функции, и вызывать его. Например, лямбда-функцию.
    // В качестве шаблонного параметра указывается сигнатура нужной функции
    function<int(int)> mult_prime;
    static const int N = 100'000;

    // Между числами N и 2N всегда есть простое число.
    // Найдём самое большое из них в цикле.
    for (int i = N; i < 2 * N; ++i) {
        if (IsPrime(i)) {
            mult_prime = [&](int x) {
                return x * i;
            };
        }
    }

    // mult_prime должна умножать аргумент на найденное простое число
    cout << mult_prime(100) << endl;
}

```

Поскольку переменная  `i`, сохранённая в лямбда-функции по ссылке, не существует после завершения цикла, программа, вызывающая эту лямбда функцию, ошибочна. Если собирать без санитайзера, программа, скорее всего, будет завершаться, но умножать не на то число, на которое мы хотели. С санитайзером ошибка с правильной формулировкой: stack-use-after-scope.

### Обращение по некорректному указателю

Указатели приятны тем, что уже включают в себя функциональность, которая достигается использованием  `optional`  — имеют отдельное значение  `nullptr`, означающее отсутствие данных по адресу. Однако если программист в какой-то момент не подумал, что указатель может быть нулевым, и попытался обратиться по нему, возникнет ошибка. Похожая ошибка произойдёт, если адрес вообще некорректный: например, когда вы забыли инициализировать указатель.

Рассмотрим пример:

```cpp
#include <algorithm>
#include <iostream>

using namespace std;

int MyMin(const int* l, const int* r) {
    if (l == nullptr) {
        return *r;
    }

    return min(*l, *r);
}

int main() {
    int x = 5, y = 10;
    cout << MyMin(&x, &y) << endl;
    cout << MyMin(nullptr, &y) << endl;
    cout << MyMin(&x, nullptr) << endl;
}

```

Вывод санитайзера сообщает об ошибке access-violation on unknown address:

```bash
=================================================================
==16200==ERROR: AddressSanitizer: access-violation on unknown address 0x000000000000 (pc 0x7ff76228141c bp 0x00c78c6ffc80 sp 0x00c78c6ffae0 T0)
==16200==The signal is caused by a READ memory access.
==16200==Hint: address points to the zero page.
    #0 0x7ff76228141b in std::min<int> ...\include\algorithm:5393
    #1 0x7ff762281096 in MyMin ...\badptr.cpp:11
    #2 0x7ff76228130b in main ...\badptr.cpp:18
...

```

### Утечка памяти

Утечка памяти возникает, когда память была выделена конструкцией  `new`, но затем не удалена вызовом  `delete`. Это распространённая ошибка, которую довольно трудно выявить. Такие ошибки может найти Address sanitizer, но к сожалению, эта функция доступна пока что только под Linux или MacOS. Чтобы включить эту опцию, нужно определить системную переменную окружения  `ASAN_OPTIONS=detect_leaks=1`, либо использовать  `-fsanitize=leak`  при компиляции.

Рассмотрим такой пример:

```cpp
class IntArray {
public:
    IntArray()
        : ptr(nullptr) {
    }
    IntArray(int n)
        : ptr(new int[n]) {
    }
    ~IntArray() {
        delete[] ptr;
    }

private:
    int* ptr;
};

int main() {
    IntArray a1(5);
    IntArray a2;
    a1 = a2;
}

```

----------

В чём проблема этого примера?

-   В переменных  `a1`  и  `a2`  будет удаляться нулевой указатель, это некорректная операция.
    
-   Как и в прошлом случае  `a1`  и  `a2`  указывают на одну и ту же память — будет двойное удаление.
    
-   При присваивании  `a1 = a2`  происходит стирание указателя из  `a1`, в итоге, он не будет удалён
    

Запустим под санитайзером:

```bash
> clang++ leak.cpp -fsanitize=leak -g
> ./a.out 

=================================================================
==24449==ERROR: LeakSanitizer: detected memory leaks

Direct leak of 20 byte(s) in 1 object(s) allocated from:
    #0 0x40d978 in operator new[](unsigned long) (.../a.out+0x40d978)
    #1 0x43262a in IntArray::IntArray(int) .../leak.cpp:4:27
    #2 0x432585 in main .../leak.cpp:14:14
    #3 0x7fd73ffeebf6 in __libc_start_main /build/glibc-S7xCS9/glibc-2.27/csu/../csu/libc-start.c:310

SUMMARY: LeakSanitizer: 20 byte(s) leaked in 1 allocation(s).

```

Вывод информативен. Он содержит как точное место, где была выделена память, так и размер выделенного участка. Мы выделяли пять объектов  `int`  по четыре байта, всего 20 байт, как и сообщил санитайзер.

### Использование неинициализированной памяти

Для выявления этой ошибки используется Memory Sanitizer, который доступен только под Linux. В прошлых уроках мы рассматривали пример для вычисления среднего арифметического. Вернёмся к нему.

Исправим ошибку, которую мы выявили в предыдущих уроках, но на этот раз будем использовать для тестов целочисленный вектор:

```cpp
#include <iostream>
#include <vector>

using namespace std;

template <class T>
double mean(const std::vector<T>& v) {
    T acc;
    const T* v_ptr = v.data();

    for (size_t i = 0; i < v.size(); ++i) {
        acc += v_ptr[i];
    }

    return static_cast<double>(acc) / v.size();
}

int main() {
    vector<int> v = {1, 2, 3, 4, 5};
    cout << "Mean: "s << mean(v) << endl;
}

```

Компилируем и запускаем:

```bash
> g++ mean.cpp -o mean
> ./mean
Mean: 6555.2

```

Неправдоподобный ответ. Значит, в нашей программе есть ещё как минимум одна ошибка.

----------

В чём, по вашему мнению, она состоит?

-   При выводе ответа используется деление  `double`  на целое число, это некорректная операция.
    
-   Мы изменили  `i <= v.size()`, исключив некорректный случай  `i == v.size()`, также нужно исключить  `i == 0`, установив начальное значение в 1.
    
-   Значение переменной  `acc`  неинициализировано. В ней изначально может находиться какой-то мусор, который влияет на ответ.
    
-   Программа правильно работает, у этих чисел такое среднее арифметическое
    

К изначальному значению  `acc`, которое было неопределено, мы прибавляем элементы вектора, получая непредсказуемый результат.

Если включить предупреждения ключом  `-Wall`, компилятор сможет найти эту ошибку уже при компиляции. Однако это возможно не всегда. Посмотрим, как обнаружить её санитайзером.

Запустим эту программу, собрав её с  `-fsanitize=memory`:

```bash
> clang++ mean.cpp -o mean -fsanitize=memory -g
> ./mean
Uninitialized bytes in __interceptor_memcmp at offset 168 inside [0x7fff5bd922a0, 256)
==24619==WARNING: MemorySanitizer: use-of-uninitialized-value
    #0 0x7f45ff7b9f6b in std::ctype<char>::_M_widen_init() const (/usr/lib/x86_64-linux-gnu/libstdc++.so.6+0xb8f6b)
    #1 0x7f45ff815ae7 in std::ostream& std::ostream::_M_insert<double>(double) (/usr/lib/x86_64-linux-gnu/libstdc++.so.6+0x114ae7)
    #2 0x49734d in main .../mean.cpp:20:22
    #3 0x7f45fe750bf6 in __libc_start_main /build/glibc-S7xCS9/glibc-2.27/csu/../csu/libc-start.c:310
    #4 0x41b229 in _start (.../mean+0x41b229)

SUMMARY: MemorySanitizer: use-of-uninitialized-value (/usr/lib/x86_64-linux-gnu/libstdc++.so.6+0xb8f6b) in std::ctype<char>::_M_widen_init() const
Exiting

```

Санитайзер не показал точное место возникновения ошибки — операцию  `+=`, в которой впервые использовалось неинициализированное значение, но правильно указал суть.

Пример в очередной раз показал, что санитайзер несовершенен, но очень полезен. Как и отладочные макроопределения, он замедлит программу: использовать его при сборке версии для пользователя не рекомендуется. Аналог санитайзера под Windows реализован в пакете Visual Studio, который автоматически выявляет многие ошибки во время запуска отладочной конфигурации. При специальной настройке Visual Studio будет также выявлять утечки памяти, но этот инструмент выходит за рамки нашего курса.

Мы рассмотрели основные проблемы, которые способен выявить Address sanitizer. Впереди вас ждёт небольшой тест, и итоговое задание по этой теме.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

----------

Как вы думаете, в чём проблема этой программы?

-   **(-)**  Удаления в деструкторе — некорректная операция, нужно убрать  `delete`.

> `tie`  годится для постоянных значений любого типа.

-   **(-)**  В типе  `ptr`. Нужно использовать  `const int*`.

> Это не решит проблему. Кроме того, ничего не получится в такой массив записать.

-   **(+)**  Два объекта  `IntArray`  будут содержать одинаковый указатель  `ptr`  и оба попытаются его удалить.

> Совершенно верно!

----------

В чём состоит ошибка?

-   **(-)**  `tie`  нельзя использовать для переменных типа  `int`.

> Всё равно в функцию будут переданы временные объекты, которые уничтожатся уже в следующей строке, а ссылка останется.

-   **(+)**  Функция возвращает ссылку на временные объекты, размещённые в аргументах функции  `x`  и  `y`, нужно заменить  `tie`  на  `tuple`.

> Верно!

-   **(-)**  Функция возвращает ссылку на временные объекты, размещённые в аргументах функции. Нужно заменить тип аргументов на  `const int&`.

> Всё равно в функцию будут переданы временные объекты, которые уничтожатся уже в следующей строке, а ссылка останется.

----------

В чём проблема этого примера?

-   **(-)**  В переменных  `a1`  и  `a2`  будет удаляться нулевой указатель, это некорректная операция.

> Удалять нулевой указатель можно, это не ошибка.

-   **(-)**  Как и в прошлом случае  `a1`  и  `a2`  указывают на одну и ту же память — будет двойное удаление.

> Они обе указывают на  `nullptr`, его можно удалять сколько угодно раз, удаление  `nullptr`  не делает ничего.

-   **(+)**  При присваивании  `a1 = a2`  происходит стирание указателя из  `a1`, в итоге, он не будет удалён

> Да, возникает утечка памяти.

----------

В чём, по вашему мнению, она состоит?

-   **(-)**  При выводе ответа используется деление  `double`  на целое число, это некорректная операция.

> Арифметические операции с целыми и  `double`  допустимы, при этом целое число неявно будет преобразовано в  `double`

-   **(-)**  Мы изменили  `i <= v.size()`, исключив некорректный случай  `i == v.size()`, также нужно исключить  `i == 0`, установив начальное значение в 1.

> Элементы векторов и массивов нумеруются в C++ с нуля, нулевой элемент абсолютно корректен.

-   **(+)**  Значение переменной  `acc`  неинициализировано. В ней изначально может находиться какой-то мусор, который влияет на ответ.

> Правильно!

-   **(-)**  Программа правильно работает, у этих чисел такое среднее арифметическое

> Увы, среднее арифметическое не может превышать наибольшее из чисел.

</details>
