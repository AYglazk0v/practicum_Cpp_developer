<details>
<summary>Теория:</summary>

# Отладочные макроопределения

Заменять все вызовы  `operator []`  на  `at`  или добавлять  `assert`  перед каждый проблемным местом — утомительная работа, а главное, можно что-нибудь пропустить или не учесть. Кроме того, обращение по несуществующему индексу — только одна из множества возможных проблем.

Оказывается, разработчики стандартной библиотеки уже подумали о нас и добавили проверки для обнаружения самых разных ошибок. Эти проверки отключены по умолчанию. Чтобы их включить, нужно определить ряд макросов, зависящих от того, какую стандартную библиотеку вы используете.

-   **libstdc++.**  Эта библиотека обычно присутствует на Linux и Windows для gcc, clang. Для отладки нужно определить макросы  `_GLIBCXX_DEBUG`  и  `_GLIBCXX_DEBUG_PEDANTIC`.
-   **libc++**. По умолчанию на MacOS. Для включения проверок нужно определить  `_LIBCPP_DEBUG=1`.
-   **Microsoft/STL**. Используется в Visual Studio. Проверки включаются макросом  `_DEBUG`, который автоматически добавляется компилятором при выборе отладочной библиотеки времени выполнения.

Добавлять макроопределения проще всего через командную строку компилятора. Если вы не уверены, какая библиотека используется — libstdc++ или libc++ — можно включить оба набора. Поступим так и попробуем запустить код среднего арифметического с ошибкой:

```bash
> g++ mean.cpp -D_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC -D_LIBCPP_DEBUG=1
> ./mean
Mean: .../c++/debug/vector:424:error: attempt to subscript container with out-of-bounds index 5, but container only holds 5 elements.

Objects involved in the operation:
sequence "this" @ 0x0000000000406850 {
  type =

```

Программа падает, сообщая подробности: индекс элемента и размер массива. Под Linux также может быть выведен полный стек вызовов. Чтобы найти точное место ошибки можно опять же воспользоваться gdb с командой  `break abort`.

```bash
> g++ mean.cpp -D_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC -D_LIBCPP_DEBUG=1 -g -o mean
> gdb mean
...
(gdb) break abort
(gdb) r
...
Thread 1 received signal SIGSEGV, Segmentation fault.
0x000000006fc650d9 in ?? () from ...\bin\libstdc++-6.dll
(gdb) bt
...
#4  0x0000000000402e6f in mean<double> (v=std::__debug::vector of length 5, capacity 5 = {...})
    at mean.cpp:16
#5  0x0000000000401608 in main () at mean.cpp:25

```

Как и в прошлый раз, отладчик показал точное место ошибки: файл mean.cpp строка 16.

Преимущества этого подхода в том, что для выявления ошибки не пришлось никак менять код программы. В реальных программах обращения к вектору могут встречаться в сотнях и тысячах строк кода, и заменять их все на  `at`  было бы крайне утомительно. Уж точно сложнее, чем добавить пару флагов при компиляции.

Отладочные определения добавляют оверхед — проверки, замедляющие программу. Поэтому не рекомендуется использовать их для сборки финальной версии, идущей пользователю. Но пример выше не единственный случай, когда они полезны. Отладочные определения также могут выявить ошибки в использовании:

-   итераторов: увеличение  `end`  или уменьшение  `begin`, разыменование невалидного итератора, некорректные арифметические операции;
-   контейнеров: получение элемента за пределами  `vector`  или  `string`, использование итератора другого контейнера, создание  `string`  из нулевого указателя.
-   алгоритмов: некорректный диапазон итераторов, неупорядоченные элементы, где это требуется, неправильный компаратор.

Рассмотрим в качестве примера алгоритм  `upper_bound`. Он может работать, только если контейнер разделён искомым элементом на меньшие и большие. Это условие автоматически выполнено, если контейнер отсортирован. Попробуем использовать  `upper_bound`, нарушив условие разделения:

```cpp
#include <algorithm>
#include <iostream>
#include <random>
#include <vector>

using namespace std;

int main() {
    vector v = {1, 81, 100, 50, 70, 30, 90, 200};
    auto iter = upper_bound(v.begin(), v.end(), 80);
    if (iter != v.end()) {
        cout << "Found element "s << *iter << endl;
    }
}

```

Скомпилируем этот файл  `find.cpp`  и запустим его:

```bash
> g++ find.cpp -o find -std=c++17
> ./find
Found element 90

```

----------

Как вы думаете, какой ответ правильный?

-   1
    
-   50
    
-   70
    
-   81
    
-   90
    
-   200
    

Программа выдала неправильный ответ, при этом не сообщив ни о какой ошибке. В реальной программе такой баг искать было бы крайне сложно. Но попробуем собрать с упомянутыми макроопределениями:

```bash
> g++ find.cpp -o find -std=c++17 -D_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC -D_LIBCPP_DEBUG=1
> find
.../stl_algo.h:2084:error: elements in iterator range [__first, __last) are not partitioned by the value __val.

```

Получаем информативное сообщение о том, что элементы контейнера не разделены должным образом.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Как вы думаете, какой ответ правильный?

-   **(-)**  1
    
-   **(-)**  50
    
-   **(-)**  70
    
-   **(+)**  81
    
-   **(-)**  90
    
-   **(-)**  200

</details>

<details>
<summary>Задание:</summary>

## Задание

Перед вами решение задачи о сортировке слиянием. В нём несколько модификаций и ошибок. Попробуйте найти все ошибки и исправить их.

Все ошибки можно выявить отладочными макроопределениями. Используйте их при решении задачи на своём компьютере, поскольку в тренажёре они не включены. Если у вас компилятор Visual Studio, проверки включены всегда в отладочной конфигурации.

### Формат выходных данных

Функция  `PrintRangeComma`  выводит элементы контейнера между заданными итераторами через запятую и начинает новую строку. Для пустого контейнера она не выводит ничего. Запятая после последнего элемента не допускается.

### Ограничения

Не меняйте суть алгоритма, ваша задача только исправить ошибки.

### Пример

Пример дан в функции  `main`  в заготовке.

### Как и что отправлять на проверку

Исправьте ошибки в функциях  `PrintRangeComma`  и  `MergeSort`  и пришлите исправленный код. Код  `main`  значения не имеет, он дан для вашего удобства.

### Как будет тестироваться ваш код

Будет проверено, что функции  `PrintRangeComma`  и  `MergeSort`  работают корректно, и что их реализации похожи на то, что дано в заготовке.

### Подсказка

Ищите три ошибки: одну в  `PrintRangeComma`  и две в  `MergeSort`.

</details>
