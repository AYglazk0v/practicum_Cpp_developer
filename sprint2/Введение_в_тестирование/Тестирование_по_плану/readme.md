<details>  
<summary>Теория + тестирование:</summary>

# Тестируем по плану

В прошлом уроке вы изучили принципы тестирования, помогающие отладить решение задач. Применим их на практике.

Допустим, у вас есть задача: написать программу, которая считывает со стандартного входа три строки, разделённые пробелами и состоящие из строчных латинских букв. Программа должна вывести в стандартный вывод лексикографически минимальную из этих трёх строк. Например:

-   для строк  `milk`,  `milkshake`,  `month`  должна быть выведена строка  `milk`;
-   для строк  `c`,  `a`,  `b`  должна быть выведена строка  `a`;
-   для строк  `fire`,  `fog`,  `wood`  должна быть выведена строка  `fire`.

Программа успешно компилируется. Проверим её работу на примерах, которые даны в условии:

```
milk milkshake month
milk

```

```
c a b
a

```

```
fire fog wood
fire
```

Программа отработала правильно. Казалось бы, можно отправлять решение на проверку.

Сделаем это и увидим, что программа не прошла один из тестов. Значит, в ней есть ошибки, которые не проявили себя на примерах из условия задачи. Чтобы исправить ошибки, составим план тестирования.

По условию задачи, пользователь вводит три строки, а программа проверяет, находится ли минимальная строка на первой, второй или третьей позиции. Возможны следующие варианты:

-   Все три строки разные. Среди них минимальная строка может быть на первом, втором или третьем месте. При этом относительное местоположение двух других строк значения не имеет. Например:
    
    `alpha beta gamma`
    
    `beta alpha gamma`
    
    `gamma beta alpha`
    
-   Две из трёх строк одинаковые. Пусть одинаковые строки будут являться минимальными. В противном случае входные данные подпадали бы под предыдущий класс эквивалентности. Примеры входных данных:
    
    `alpha beta alpha`
    
    `beta alpha alpha`
    
    `alpha alpha beta`
    
-   Все три строки одинаковые. Например:
    
    `alpha alpha alpha`
    

Таким образом, для этой программы у нас семь классов эквивалентности — то есть семь наборов входных данных. План тестирования готов.

Теперь проверим работу программы на каждом варианте входных данных. Когда все строки разные, она работает правильно:

```
alpha beta gamma
alpha

```

```
beta alpha gamma
alpha

```

```
gamma beta alpha
alpha

```

Проверим вариант, где две одинаковые строки минимальны:

```
alpha beta alpha

```

Странно, программа не вывела ничего, хотя из трёх строк одна точно должна быть ответом. Взглянем на проверяемые условия:

```cpp
  if (a < b && a < c) {  // Первая строка минимальная?
      cout << a << endl;
  } else if (b < a && b < c) {  // Вторая строка минимальная?
      cout << b << endl;
  } else if (c < a && c < b) {  // Третья строка минимальная?
      cout << c << endl;
  }

```

Первое, что бросается в глаза, — избыточность условия вывода третьей строки. Ведь если ни первая, ни вторая строка не будут ответами, значит, ответ — третья. Уберём последнюю проверку:

```cpp
#include <iostream>
#include <string>

using namespace std;

int main() {
    string a, b, c;

    cin >> a >> b >> c;

    if (a < b && a < c) {  // Первая строка минимальная?
        cout << a << endl;
    } else if (b < a && b < c) {  // Вторая строка минимальная?
        cout << b << endl;
    } else {  // Третья строка точно минимальная
        cout << c << endl;
    }
}

```

Проверим, как программа ведёт себя на входных данных, с которыми тест падал:

```
alpha beta alpha
alpha

```

Отлично, она стала работать правильно там, где не работала. Но считать программу готовой нельзя, ведь мы проверили её не на всех запланированных тестах. Исправляя одну ошибку, мы могли внести новую или пропустить другие. Поэтому важно выполнить все тесты.

Проверим работу программы на предыдущих тестах, чтобы убедиться: то, что работало, мы правками не сломали. Затем продолжим тестирование по плану.

Тесты с тремя разными строками:

```
alpha beta gamma
alpha

```

```
beta alpha gamma
alpha

```

```
gamma beta alpha
alpha

```

Тесты с двумя одинаковыми строками:

```
alpha beta alpha
alpha

```

```
beta alpha alpha
alpha

```

```
alpha alpha beta
beta

```

И снова неожиданность. Программа вывела строку  `beta`, хотя в лексикографическом порядке строка  `alpha`  идёт до  `beta`. Проанализируем, как выполняется код на данных  `alpha alpha beta`:

```cpp
  if (a < b && a < c) {  // Первая строка минимальная?
      cout << a << endl;
  } else if (b < a && b < c) {  // Вторая строка минимальная?
      cout << b << endl;
  } else {  // Третья строка точно минимальная
      cout << c << endl;
  }

```

На таком входном наборе в переменной  `a`  хранится значение “alpha”, в переменной  `b`  — “alpha”, а в переменной  `c`  — “beta”, и ожидается, что будет выведено значение переменной  `a`  либо переменной  `b`. Но  `a`  и  `b`  содержат одно и то же значение. Поэтому из-за строгих сравнений  `a < b`  и  `b < a`  ни одно из первых двух условий не выполняется, а выполняется третья ветка, выводящая значение переменной  `c`. Чтобы исправить ошибку, используем нестрогие сравнения — при равенстве строк неважно, какую из них выводить:

```cpp
#include <iostream>
#include <string>

using namespace std;

int main() {
    string a, b, c;

    cin >> a >> b >> c;

    if (a <= b && a <= c) {  // Первая строка минимальная?
        cout << a << endl;
    } else if (b <= a && b <= c) {  // Вторая строка минимальная?
        cout << b << endl;
    } else {
        cout << c << endl;
    }
}

```

Повторим провалившийся тест и убедимся, что новая версия кода решает выявленную проблему:

```
alpha alpha beta
alpha

```

Ура! Исправили уже две ошибки. Теперь посмотрим, как программа ведёт себя на последнем тесте с тремя одинаковыми строками:

```
alpha alpha alpha
alpha

```

Исправляя последнюю ошибку, мы могли внести в программу дефект. Перепроверим её работу на всех тестах плана тестирования:

```
alpha beta gamma
alpha

```

```
beta alpha gamma
alpha

```

```
gamma beta alpha
alpha

```

```
alpha beta alpha
alpha

```

```
beta alpha alpha
alpha
```

Всё в порядке. Теперь программу можно считать завершённой и смело отправлять её на проверку. Так происходит ручное тестирование.

</details>  

<details>  
<summary>Ответы:</summary>

# Ответы на задания

Вы проверили работу программы на строках  `alpha beta gamma`  и убедились, что она работает корректно. Будете ли вы тестировать её на других наборах входных данных из того же класса эквивалентности? Например, на  `apple cat dog`?

-   **(-)**  Да, это имеет смысл
    
    -   Так вы будете дольше тестировать программу и создадите иллюзию хорошего покрытия тестами. Но это будет лишь иллюзия. Тесты на  `apple cat dog`  дублируют функционал уже проведённых. Лучше проверьте сценарии, которые ещё не проверяли.
-   **(+)**  Нет, как правило, это бессмысленно
    
    -   Верное решение. Тесты на  `apple cat dog`  дублируют функционал уже проведённых. Добавляя их в план тестирования, вы потратите лишнее время на проверку. А ещё создадите иллюзию, что логика программы хорошо покрыта тестами. Более ценными будут тесты, которые проверяют ещё не проверенные сценарии.
    
</details>  

<details>  
<summary>Задание:</summary>

Напишите программу. Она должна определять, будет ли палиндромом текст, введённый пользователем в первой строке стандартного ввода. Гарантируется, что текст содержит только строчные символы английского алфавита и пробелы. Пробелы в любом количестве могут стоять в начале и в конце строки, а также между словами. Пусть программа их игнорирует. Если строка пустая или состоит только из пробелов, она не считается палиндромом.

Если текст окажется палиндромом, программа должна вывести строку  `palindrome`. Если нет —  `not a palindrome`.

Примеры палиндромов:  `radar`,  `never odd or even`.

Примеры строк, которые не будут палиндромами:  `apple`,  `kick`.

Перед отправкой кода на проверку проведите ручное тестирование, как мы делали в уроке.

### Подсказка

Составьте план тестирования до написания кода. Не пытайтесь сразу создать программу, решающую задачу полностью. Следуйте плану тестирования и двигайтесь маленькими итерациями:

-   напишите код для прохождения теста в самой простой ситуации,
-   доработайте программу так, чтобы она проходила два теста, затем три.

При тестировании не забывайте обработать граничные условия — пустые строки и строки из одних пробелов.
</details>  
