<details>  
<summary>Теория + тестирование:</summary>

<h1>Принципы тестирования и отладки кода</h1>

<p>Выполняя задания курса, вы могли столкнуться с тем, что ваше решение не принимается тестирующей системой. Хотя вы на своём компьютере убедились: код компилируется без ошибок и даже проходит тесты. Но если тестирующая система не принимает решение, вероятно, в нём правда есть ошибка.</p>

<p>Не отчаивайтесь. Когда изучаете новый язык программирования или технологию, ошибки — это нормально. Даже опытные программисты ошибаются. Более того, чем опытнее программист, тем с большим недоверием он относится к собственному коду — ищет и устраняет в нём ошибки. В этом уроке вы узнаете, как ошибки предупреждать и исправлять.</p>

<h3>Внимательно читайте условие задачи</h3>

<p>Убедитесь, что не упустили ни одной детали в условии и правильно поняли, как должна работать ваша программа.</p>

<h3>Проверьте, как программа работает на примерах из условия</h3>

<p>Часто в задании есть примеры ввода и вывода. Они демонстрируют ожидаемые результаты работы программы на некотором наборе входных данных. Если ваше решение даёт не тот результат, который ожидается, в нём точно ошибка.</p>

<p>Но примеры покрывают лишь малую часть входных данных, с которыми может столкнуться программа. То, что ваше решение работает на примерах, тоже не гарантирует его правильность. Как говорил Эдгер Дейкстра, тестирование показывает наличие ошибок, но не доказывает, что их нет.</p>

<h3>Вносите изменения в программу небольшими порциями и регулярно тестируйте её работу</h3>

<p>Чем меньше изменений вы внесли, тем меньше различий в коде придётся изучить, чтобы найти причину ошибки. Не забывайте после каждого изменения проверять работу программы. Так вы раньше обнаружите и исправите ошибку.</p>

<h3>Составьте план тестирования</h3>

<p>Часто в рабочих ситуациях непонятно, почему программа ведёт себя неправильно. Ведь вы не знаете, при каких входных данных возникла ошибка.</p>

<p>Чтобы разобраться в чём дело, воспроизведите ошибку — найдите набор входных данных, при котором она проявит себя.</p>

<p>Возможна обратная ситуация. Вы написали программу и хотите перед выпуском убедиться, что она  работает корректно. Подходить к этому хаотично и запускать программу на паре-тройке примеров входных данных не стоит. Так вы рискуете пропустить серьёзные ошибки. А вот пользователи программы их не пропустят.</p>

<p>Переходя к тестированию своей программы, — реальной или учебной — разработайте план тестирования. Для этого проанализируйте условия задачи и выделите классы эквивалентности. Класс эквивалентности — это одно или несколько значений входных данных, к которым программа применяет одинаковую логику.</p>

<p>Например, у вас есть задача определить, високосный год или нет. В ней можно выделить следующие классы эквивалентности:</p>

<ul>
<li>Год, номер которого кратен 400, — високосный;</li>
<li>Остальные годы, номер которых кратен 100, — невисокосные (1700, 1800, 1900, 2100);</li>
<li>Остальные годы, номер которых кратен четырём, — високосные;</li>
<li>Прочие годы, не кратные четырём, — невисокосные.</li>
</ul>

<p>При тестировании программы достаточно будет проверить её работу на небольшом наборе входных данных, выбрав один или два года из каждого класса эквивалентности.</p>

<p>Когда составляете план тестирования, учитывайте крайние (граничные) случаи. Например, если значение целочисленного параметра должно быть в диапазоне от 0 до 100 включительно, следует проверить работу программы при значениях параметра вблизи границ: 0, 1, 99, 100. Если параметр строковый, проверьте работу программы на пустых строках и строках с одним символом. Если имеете дело с контейнером типа <code>vector</code>, <code>set</code> и <code>map</code>, протестируйте, как программа себя ведёт с пустыми контейнерами.</p>

<p>Граничные условия нужно обрабатывать, так как ошибки часто возникают вблизи границ, отделяющих корректные данные от некорректных.</p>

<p>Определившись с набором входных данных, проверьте работу программы на этом наборе. Выходные данные должны соответствовать ожидаемым.</p>

<p>Выходные данные, полученные от этой же программы, в качестве ожидаемого результата использовать не следует. Иначе выдаваемый результат будет совпадать с ожидаемым, даже если в коде есть ошибки. Вычислите ожидаемые данные вручную или получите их из внешнего доверенного источника.</p>

<p>Внимательно читайте условие задачи, вносите изменения в программу маленькими порциями и сразу тестируйте, проверяйте решение на примерах ввода и вывода и на граничных условиях. Выделите классы эквивалентности и составьте план тестирования. Так вы быстрее отловите и исправите ошибки.</p>

<hr>

Вы проверяете, как работает ваше решение на входных данных из условия задачи?</p>

<ul>
<li><p>Да</p></li>
<li><p>Нет</p></li>
</ul>

<hr>

Вы проверили и убедились, что ваша программа работает на входных данных из условия задачи. Получается, ошибок в коде нет?</p>

<ul>
<li><p>Раз работает, ошибок нет</p></li>
<li><p>Как бы не так</p></li>
</ul>
>
</details>  

<details>  
<summary>Ответы:</summary>

<h1>Ответы на задания</h1>

<p>Вы проверяете, как работает ваше решение на входных данных из условия задачи?</p>

<ul>
<li><p><strong>(+)</strong> Да</p>

<ul>
<li>И правильно делаете! Примеры входных данных из условия задачи явно описывают поведение, ожидаемое от вашей программы. Если программа работает не так, как должна, в ней есть ошибка. Конечно, если требования непротиворечивы.</li>
</ul></li>

<li><p><strong>(-)</strong> Нет</p>

<ul>
<li>А зря. Примеры показывают, как программа должна работать. Если ваше решение приводит не к тому результату, который ожидается, значит в решении ошибка.</li>
</ul></li>
</ul>

<hr>

<p>Вы проверили и убедились, что ваша программа работает на входных данных из условия задачи. Получается, ошибок в коде нет?</p>

<ul>
<li><p><strong>(-)</strong> Раз работает, ошибок нет</p>

<ul>
<li>Такой проверки недостаточно. Входные данные в условиях задачи относятся лишь к некоторым классам эквивалентности. Программу нужно проверять и на других классах эквивалентности тоже. Иначе пропустите ошибки. Чтобы составить набор тестовых данных, наиболее плотно покрывающий возможные сценарии работы программы, сделайте план тестирования.</li>
</ul></li>

<li><p><strong>(+)</strong> Как бы не так</p>

<ul>
<li>Верно! Если решение работает на указанных входных данных, это не значит, что ошибок в нём нет. Проверять работу программы на одних только примерах из условия недостаточно.</li>
</ul></li>
</ul>

<h1>Ответы на задания</h1>

<p>Вы проверяете, как работает ваше решение на входных данных из условия задачи?</p>

<ul>
<li><p><strong>(+)</strong> Да</p>

<ul>
<li>И правильно делаете! Примеры входных данных из условия задачи явно описывают поведение, ожидаемое от вашей программы. Если программа работает не так, как должна, в ней есть ошибка. Конечно, если требования непротиворечивы.</li>
</ul></li>

<li><p><strong>(-)</strong> Нет</p>

<ul>
<li>А зря. Примеры показывают, как программа должна работать. Если ваше решение приводит не к тому результату, который ожидается, значит в решении ошибка.</li>
</ul></li>
</ul>

<hr>

<p>Вы проверили и убедились, что ваша программа работает на входных данных из условия задачи. Получается, ошибок в коде нет?</p>

<ul>
<li><p><strong>(-)</strong> Раз работает, ошибок нет</p>

<ul>
<li>Такой проверки недостаточно. Входные данные в условиях задачи относятся лишь к некоторым классам эквивалентности. Программу нужно проверять и на других классах эквивалентности тоже. Иначе пропустите ошибки. Чтобы составить набор тестовых данных, наиболее плотно покрывающий возможные сценарии работы программы, сделайте план тестирования.</li>
</ul></li>

<li><p><strong>(+)</strong> Как бы не так</p>

<ul>
<li>Верно! Если решение работает на указанных входных данных, это не значит, что ошибок в нём нет. Проверять работу программы на одних только примерах из условия недостаточно.</li>
</ul></li>
</ul>

</details>  
