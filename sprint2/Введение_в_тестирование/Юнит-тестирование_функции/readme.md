<details>  
<summary>Теория + тестирование:</summary>

# Юнит-тестирование функции

Выполняя ручное тестирование программы в прошлом уроке, вы наверняка отметили следующее:

-   Даже для такой простой программы как «‎Выбор наименьшей строки» понадобилось шесть наборов тестов. Чем сложнее ваша программа, тем больше тестов придётся делать.
-   Полностью тестировать код вручную после каждого изменения — трудоёмкое занятие. Мотивации оно не прибавит.

Эффективнее провести юнит-тестирование. Это подход в разработке, позволяющий автоматизировать проверку отдельных модулей программы. В роли модулей, как правило, выступают классы и функции.

Тестирование отдельных компонентов программы заключается в том, что дополнительно к основному коду пишут модульные тесты — вспомогательный код, проверяющий поведение классов и функций. Напишете тесты один раз — сможете запускать их регулярно и за доли секунды проверять, как работают модули. Юнит-тесты можно использовать сколько угодно раз и сразу получать обратную связь о том, как изменения в коде программы повлияли на её работу.

Разработаем юнит-тесты для программы «‎Выбор наименьшей строки». Чтобы сделать это, код сначала нужно декомпозировать.

### Декомпозиция

Код программы «‎Выбор наименьшей строки» мы написали в прошлом уроке:

```cpp
#include <iostream>
#include <string>

using namespace std;

int main() {
    string a, b, c;

    cin >> a >> b >> c;

    if (a <= b && a <= c) {  // Первая строка минимальная?
        cout << a << endl;
    } else if (b <= a && b <= c) {  // Вторая строка минимальная?
        cout << b << endl;
    } else {
        cout << c << endl;
    }
}

```

Её работу можно условно разделить на две части:

1.  Ввод и вывод данных. Этот код разбирает запросы, поступающие со стандартного ввода, и выводит результаты;
2.  Нахождение минимальной из трёх строк.

Мы разграничили пользовательский интерфейс и логику программы. Благодаря этому стало возможным менять интерфейс, не меняя логику. Тестировать код тоже будет проще.

Выполним декомпозицию программы: выделим функцию нахождения минимальной строки:

```cpp
#include <iostream>
#include <string>

using namespace std;

const string& FindMinStr(const string& a, const string& b, const string& c) {
    if (a <= b && a <= c) {
        return a;
    } else if (b <= a && b <= c) {
        return b;
    }
    return c;
}

int main() {
    string a, b, c;

    cin >> a >> b >> c;

    cout << FindMinStr(a, b, c) << endl;
}

```

Упростился код программы в целом и функции  `main`  в частности. Код нахождения минимальной строки выделен в функцию с понятным именем.

Предварительная декомпозиция на отдельные классы и функции облегчает не только тестирование, но и читаемость кода. В нашем случае имя функции  `FindMinStr`  однозначно говорит, что она делает. Поэтому необходимость комментариев сведена к минимуму.

## Пишем первый модульный тест

Теперь напишем для функции модульный тест. Он должен вызывать функцию  `FindMinStr`  с некоторыми параметрами и сравнивать её результат с ожидаемым значением. Для проверок воспользуемся макросом  [assert](https://en.cppreference.com/w/cpp/error/assert).

Макросы — специальные конструкции языка C++. Как  `#include`, они выполняются на этапе предварительной обработки исходного текста программы. Макросы позволяют заменить одну последовательность символов исходного кода на другую. Применив макрос  `assert`, можем «вставить» в код проверку логического условия. Если во время выполнения программы условие будет истинно, она продолжит работать. Если нет — программа выведет диагностическую информацию и аварийно завершит работу. Макрос  `assert`  проверяет условия, нарушение которых говорит об ошибках в программе. Подключается он директивой  `#include <cassert>`.

Код нашего теста будет размещаться в функции  `TestFindMinStr`, вызываемой в начале функции  `main`. Тест проверит работу функции  `FindMinStr`  на тех же классах входных данных, что и при ручном тестировании. Чтобы проконтролировать поведение функции на граничных условиях, добавим дополнительные проверки на пустых строках:

```cpp
#include <cassert>
#include <iostream>
#include <string>

using namespace std;

const string& FindMinStr(const string& a, const string& b, const string& c) {
    if (a <= b && a <= c) {
        return a;
    } else if (b <= a && b <= c) {
        return b;
    }
    return c;
}

void TestFindMinStr() {
    assert(FindMinStr("alpha"s, "beta"s, "gamma"s) == "alpha"s);
    assert(FindMinStr("beta"s, "alpha"s, "gamma"s) == "alpha"s);
    assert(FindMinStr("gamma"s, "beta"s, "alpha"s) == "alpha"s);

    assert(FindMinStr("alpha"s, "beta"s, "alpha"s) == "alpha"s);
    assert(FindMinStr("beta"s, "alpha"s, "alpha"s) == "alpha"s);
    assert(FindMinStr("alpha"s, "alpha"s, "beta"s) == "alpha"s);

    assert(FindMinStr("alpha"s, "alpha"s, "alpha"s) == "alpha"s);

    assert(FindMinStr(""s, "alpha"s, "beta"s) == ""s);
    assert(FindMinStr("beta"s, ""s, "alpha"s) == ""s);
    assert(FindMinStr("beta"s, "alpha"s, ""s) == ""s);

    cout << "TestFindMinStr is OK"s << endl;
}

int main() {
    TestFindMinStr();

    string a, b, c;

    cin >> a >> b >> c;

    cout << FindMinStr(a, b, c) << endl;
}
```

Скомпилируем и запустим программу. Она выведет сообщение `TestFindMinStr OK` и будет ожидать ввод данных от пользователя. Вывод сообщения показывает, что мы не забыли вызвать тест. Убедившись в этом, можем убрать вывод сообщения и не засорять вывод программы служебными данными. Первый модульный тест прошёл успешно.

Но наибольшую пользу модульные тесты приносят, когда падают, обнаружив ошибку. Воспроизведём эту ситуацию, умышленно изменив  `<=`  на  `<`  в условных выражениях:

```cpp
const string& FindMinStr(const string& a, const string& b, const string& c) {
    if (a < b && a < c) {
        return a;
    } else if (b < a && b < c) {
        return b;
    }
    return c;
}

```

Программа выведет сообщение об ошибке и аварийно завершит работу, так как одна из проверок кончилась неудачей:

```
minstr.cpp:23: void TestFindMinStr(): Assertion `FindMinStr("alpha"s, "alpha"s, "beta"s) == "alpha"s' failed.
```

Диагностическая информация, выведенная макросом `assert`, содержит имя файла и номер строки с условием, не прошедшим проверку. Также здесь указан фрагмент исходного кода, расположенный внутри параметров макроса. Это поможет проанализировать причины возникновения ошибки и исправить её.

Юнит-тест автоматически проверил работу функции  `FindMinStr`. Тестировать её вручную после каждого внесённого изменения уже не нужно.

--------

Чем юнит-тесты полезны при отладке программы? Выберите несколько ответов.

-   Юнит-тесты позволяют выполнить программу по шагам.
    
-   Их несложно придумать, так как они тестируют отдельную часть большой программы.
    
-   Юнит-тесты сами находят данные, на которых программа работает неверно.
    
-   Упавшие юнит-тесты указывают, в каком компоненте программы есть ошибка.
    
-   Юнит-тесты позволяют проверить работоспособность каждого компонента программы на крайних случаях входных данных.
    
-   Успешно выполнившиеся юнит-тесты гарантируют, что тестируемая ими функция или класс не содержит ошибок.
- ----
Что надо сделать, если юнит-тесты нашли ошибку в решении задачи?

-   Исправить ошибку и отправить решение на проверку.
    
-   Отправить решение на проверку.
    
-   Исправить ошибку и повторно протестировать программу на всём наборе тестов. Если новых ошибок нет, отправить решение на проверку.
-----
Зачем декомпозировать программу? Выберите несколько ответов.

-   Декомпозиция упрощает отладку программы.
    
-   Декомпозиция программы гарантирует её корректность.
    
-   Разбиение программы на отдельные блоки позволяет протестировать каждый из них изолированно.
    
-   Декомпозиция кода упрощает его чтение, так как вводит понятные имена функций и классов.
    
-   Программа, разбитая на отдельные блоки, работает быстрее.
</details>  

<details>  
<summary>Ответы:</summary>

# Ответы на задания

Чем юнит-тесты полезны при отладке программы? Выберите несколько ответов.

-   **(-)**  Юнит-тесты позволяют выполнить программу по шагам.
    
    -   Кажется, вы спутали юнит-тестирование с ручным.
-   **(+)**  Их несложно придумать, так как они тестируют отдельную часть большой программы.
    
-   **(-)**  Юнит-тесты сами находят данные, на которых программа работает неверно.
    
    -   Жаль, но нет.
-   **(+)**  Упавшие юнит-тесты указывают, в каком компоненте программы есть ошибка.
    
-   **(+)**  Юнит-тесты позволяют проверить работоспособность каждого компонента программы на крайних случаях входных данных.
    
-   **(-)**  Успешно выполнившиеся юнит-тесты гарантируют, что тестируемая ими функция или класс не содержит ошибок.
    
    -   Тестирование — и ручное, и модульное — показывает наличие ошибок, но не доказывает их отсутствие. Как в естественных науках: можно доказать наличие чего-либо, но отсутствие — нельзя.
----
Что надо сделать, если юнит-тесты нашли ошибку в решении задачи?

-   **(-)**  Исправить ошибку и отправить решение на проверку.
    
    -   Нет, ещё рано. Сначала протестируйте код на всём наборе тестов.
-   **(-)**  Отправить решение на проверку.
    
    -   Исправьте ошибку, протестируйте код на всём наборе тестов. Если новых ошибок не будет, решение можно отправлять на проверку.
-   **(+)**  Исправить ошибку и повторно протестировать программу на всём наборе тестов. Если новых ошибок нет, отправить решение на проверку.
---
Зачем декомпозировать программу? Выберите несколько ответов.

-   **(+)**  Декомпозиция упрощает отладку программы.
    
-   **(-)**  Декомпозиция программы гарантирует её корректность.
    
    -   Нет, зато декомпозиция упрощает отладку.
-   **(+)**  Разбиение программы на отдельные блоки позволяет протестировать каждый из них изолированно.
    
-   **(+)**  Декомпозиция кода упрощает его чтение, так как вводит понятные имена функций и классов.
    
-   **(-)**  Программа, разбитая на отдельные блоки, работает быстрее.
    
    -   Хорошо бы, но нет.

</details>  
