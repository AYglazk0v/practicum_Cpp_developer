<details>  
<summary>Введение:</summary>

<p>В прошлой теме вы тестировали код вручную и создавали модульные тесты. Это трудоёмкий процесс, который можно автоматизировать фреймворком.</p>

<p>Фреймворк для юнит-тестирования увеличивает скорость проверки кода, выдаёт диагностическую информацию и облегчает поддержку тестов в будущем. Его можно менять и переиспользовать.</p>

<p>Вы создадите собственный фреймворк и примените его для тестирования поисковой системы.</p>

</details>  

<details>  
<summary>Теория+тестирование:</summary>

# Создаём альтернативу assert

В предыдущей теме вы написали юнит-тесты, чтобы найти и исправить ошибки в решении задачи «Синонимы», программе «Автобусные остановки» и в своей поисковой системе.

Юнит-тесты были основаны на стандартном макросе  `assert`, который проверяет ожидания от работы кода. Рассмотрим преимущества и недостатки этого макроса.

### Преимущества

-   Макрос  `assert`  показывает, какая именно проверка не сработала в модульном тесте, сообщает название файла и номер строки. Это помогает найти и выяснить причину ошибки. Простейший пример:

```cpp
#include <cassert>

int Add(int x, int y) {
    return x * y;
}

int main() {
    assert(Add(2, 3) == 5);
}

```

При запуске программы  `assert`  «‎выстрелит»: аварийно прекратит её работу и выведет диагностическую информацию:

```
test.exe: test.cpp:8: int main(): Assertion `Add(2, 3) == 5' failed.

```

Макрос  `assert`  проверяет истинность условия, нарушение которого указывает на ошибку в логике программы или на противоречивость в её состоянии. Если условие ложное, программа завершает работу. А мы получаем диагностическую информацию о том, где код не прошёл тест.

На этом преимущества  `assert`  заканчиваются и начинаются недостатки.

### Недостатки

-   Диагностическая информация не содержит значений сравниваемых выражений. В примере выше не сработало условие  `Add(2, 3) == 5`. Но какое именно значение вернула функция  `Add`, мы не знаем. Чтобы выяснить это, приходится использовать отладчик.
-   Первый же «‎выстреливший»‎  `assert`  прекращает работу программы и не даёт узнать, как пройдут остальные проверки.
-   Макрос  `assert`  выводит диагностическую информацию в стандартный поток вывода, и она смешивается с выходными данными программы. Это может быть нежелательным.
-   Следующий недостаток разберём на примере:

```cpp
#define NDEBUG // Объявляем макрос NDEBUG
#include <cassert>

int Add(int x, int y) {
    return x * y; // Ошибка тут специально
}

int main() {
    assert(Add(2, 3) == 5); // Этот assert не сработает
}

```

Запустим программу и увидим, что макрос  `assert`  не сработал. Дело в том, что мы объявили макрос  `NDEBUG`  перед подключением файла  `cassert`. Определение макроса  `assert`  зависит от макроса  `NDEBUG`, который по умолчанию не объявлен в стандартной библиотеке. Если объявить  `NDEBUG`  перед подключением файла  `<cassert>`,  `assert`  не будет делать ничего. Это позволяет ограничить использование макроса  `assert`  отладочными версиями программы и отключить проверки в финальной сборке программы.

Тесты для C++ пишут, используя не только макрос  `assert`. Существуют целые фреймворки, такие как  [Google Test](https://github.com/google/googletest),  [Boost.Test](https://www.boost.org/doc/libs/1_74_0/libs/test/doc/html/index.html),  [Catch2](https://github.com/catchorg/Catch2). На практике для разработки тестов применяют фрейморк, а макрос  `assert`  оставляют, чтобы проверить инварианты в отладочных версиях программы. Вы увидите, как это работает, когда создадите собственный фреймворк на основе своих знаний С++.

Делать это вы начнёте прямо сейчас. При сравнении значений не видно, чему равен каждый из операндов, если  `assert`  «выстрелил». Устраним эту неприятность. Чтобы сравнивать значения разных типов, напишем функцию  `AssertEqual`:

```cpp
AssertEqual(Add(2, 3), 5);
AssertEqual(Sort(vector<int>{1, 4, 2}), vector<int>{1, 2, 4});

```

Если её аргументы будут неравны, хорошо бы увидеть в консоли значения аргументов:

```
Assertion failed: 6 != 5
Assertion failed: [1, 4, 2] != [1, 2, 4]

```

Для этого нужна функция, которая принимает два значения произвольного типа, сравнивает их и, если они оказались неравны, реагирует на это. Как это сделать в C++, вы уже знаете: создать шаблон функции. Напишем шаблон  `AssertEqual`:

```cpp
#include <cstdlib>
#include <iostream>
#include <string>

using namespace std;

template <typename T, typename U>
void AssertEqual(const T& t, const U& u) {
    if (t != u) {
        cout << "Assertion failed: "s << t << " != "s << u << endl;
        // Аварийно завершаем работу программы
        abort();
    }
}

int main() {
    string hello = "hello"s;
    AssertEqual(hello.length(), 5);

    // Эта проверка не сработает
    AssertEqual(2 + 2, 5);
}

```

Функция-шаблон здесь принимает два параметра некоторых типов  `T`  и  `U`. Если значения неравны, она выводит их в консоль и стандартной функцией  `abort`  аварийно завершает программу. Функция  `abort`  подключается заголовочным файлом  `<cstdlib>`.

Возникает логичный вопрос: почему шаблонная функция  `AssertEqual`  принимает аргументы не одного и того же типа, а различных. Ответ: так она удобнее в применении, особенно с целочисленными типами. Мы могли объявить функцию  `AssertEqual`  иначе:

```cpp
template <typename T>
void AssertEqual(const T& t, const T& u) {
    if (t != u) {
        cout << "Assertion failed: "s << t << " != "s << u << endl;
        // Аварийно завершаем работу программы
        abort();
    }
}

```

Тогда результат метода  `length()`, который относится к типу  `size_t`, сравнивался бы со значением 5, которое относится к типу  `int`. Программа не скомпилировалась бы. Компилятор не может определить, какой тип использовать в данной ситуации:

```cpp
string hello = "hello"s;
AssertEqual(hello.length(), 5);

```

То есть разные типы  `T`  и  `U`  в шаблоне  `AssertEqual`  оправданы.

Запустим программу и увидим, что вторая проверка не сработала. В консоль вывелись значения сравниваемых аргументов:

```
Assertion failed: 4 != 5

```

Теперь можем выводить значения аргументов функции  `AssertEqual`. Но макрос  `assert`  сообщал, какая именно проверка сработала, и где искать ошибку. Этой информации мы лишились. Не беда. В следующем уроке вы научитесь получать подробную диагностику и без  `assert`. А пока добавим в  `AssertEqual`  параметр  `hint`. Он содержит строку-подсказку, которая выводится в конце сообщения:

```cpp
template <typename T, typename U>
void AssertEqual(const T& t, const U& u, const string& hint) {
    if (t != u) {
        cout << "Assertion failed: "s << t << " != "s << u << "."s;
        if (!hint.empty()) {
            cout << " Hint: "s << hint;
        }
        cout << endl;
        abort();
    }
}

```

Теперь в тестах можем использовать подсказки, помогающие диагностировать проблему:

```cpp
int Add(int a, int b) {
    // Ошибка здесь специально, чтобы вы увидели вывод информации об ошибке
    return a + b + 1;
}

int main() {
    // Эта проверка не сработает
    AssertEqual(Add(2, 3), 5, "Add() must add its arguments"s);
} 

```

```
Assertion failed: 6 != 5. Hint: Add() must add its arguments

```

Посмотрим, как обстоит дело с проверкой булевых значений:

```cpp
int main() {
    // Ошибка в условии допущена намеренно, чтобы продемонстрировать работу AssertEqual
    AssertEqual(greeting.empty(), true, "Greeting must be non-empty"s);
}

```

Запустим программу и увидим сообщение:

```
Assertion failed: 0 != 1. Hint: Greeting must be non-empty

```

По умолчанию значения  `true`  и  `false`  выводятся в поток как единица и ноль. Чтобы заменить их при выводе на более привычные значения, применим  `boolalpha`. Он подключается директивой  `#include <iomanip>`. Отменяется такой режим манипулятором  `noboolalpha`.

```cpp
#include <cstdlib>
#include <iomanip>  // Подключаем, чтобы использовать манипулятор boolalpha
#include <iostream>
#include <string>

using namespace std;

template <typename T, typename U>
void AssertEqual(const T& t, const U& u, const string& hint) {
    if (t != u) {
        // Включаем режим вывода значений типа bool в виде true и false
****        cout << boolalpha;
        cout << "Assertion failed: "s << t << " != "s << u << "."s;
        if (!hint.empty()) {
            cout << " Hint: "s << hint;
        }
        cout << endl;
        abort();
    }
}

int main() {
    const string greeting = "Hello"s;
    // Ошибка в условии специально, чтобы вы увидели работу AssertEqual
    AssertEqual(greeting.empty(), true, "Greeting must be non-empty"s);
}

```

Логические выражения стали выводиться так:

```
Assertion failed: false != true. Hint: Greeting must be non-empty

```

Проверять булевые значений функцией  `AssertEqual`  допустимо. Но это слишком длинный способ по сравнению с оригинальным макросом  `assert`, который позволяет написать просто  `assert(!greeting.empty());`. Чтобы устранить многословность, нужно реализовать функцию  `Assert`  с аналогичным функционалом. Вы сделаете это, когда будете выполнять задания.

Мы рассмотрели преимущества и недостатки макроса  `assert`, нашли ему замену и создали основу фреймворка юнит-тестирования. В следующих уроках вы разовьёте и улучшите свой фреймворк.

----------

В чём недостатки этой реализации шаблона  `AssertEqual`? Выберите несколько вариантов ответа.

```cpp
template <typename T>
void AssertEqual(const T& first, const T& second) {
    if (first != second) {
        cout << "Assertion failed: "s << first << " != "s << second << endl;
        abort();
    }
}

```

-   Аргументы принимаются по значению, хотя в этом нет необходимости.
    
-   Аргументы  `first`  и  `second`  здесь обязаны быть одного типа.
    
-   Эта реализация не сообщает значения аргументов, если они оказались неравны.
    
-   Эта реализация не помогает понять, какой именно  `assert`  сработал.

</details>  

<details>  
<summary>Ответы:</summary>

# Ответы на задания

----------

В чём недостатки этой реализации шаблона  `AssertEqual`? Выберите несколько вариантов ответа.

```cpp
template <typename T>
void AssertEqual(const T& first, const T& second) {
    if (first != second) {
        cout << "Assertion failed: "s << first << " != "s << second << endl;
        abort();
    }
}

```

-   **(-)**  Аргументы принимаются по значению, хотя в этом нет необходимости.
    
    -   Посмотрите внимательно, как принимаются аргументы  `first`  и  `second`.
-   **(+)**  Аргументы  `first`  и  `second`  здесь обязаны быть одного типа.
    
    -   Это недостаток, так как при сравнении целочисленных значений разных типов произойдёт ошибка компиляции.
-   **(-)**  Эта реализация не сообщает значения аргументов, если они оказались неравны.
    
    -   Внимательно посмотрите, что случится, если аргументы  `first`  и  `second`  неравны.
-   **(+)**  Эта реализация не помогает понять, какой именно  `assert`  сработал.
    
    -   Да, чтобы понимать, какой  `assert`  сработал, потребовалось добавить параметр  `hint`.

</details>  

<details>  
<summary>Задание:</summary>

## Задание

Разработайте функцию  `Assert`, проверяющую значение на равенство  `true`. Если значение равно  `false`, пусть выводится сообщение  `Assertion failed.`, а программа аварийно прекращает работу. Для завершения работы примените функцию  `abort`. При непустом значении параметра  `hint`  дополнительно должен выводиться текст подсказки. Так, заготовка кода должна выводить сообщение:

```
Assertion failed. Hint: Greeting must be non-empty

```

### Подсказка

Реализуйте  `Assert`  аналогично функции  `AssertEqual`.

</details>  
