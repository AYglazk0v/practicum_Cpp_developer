<details>  
<summary>Теория+тестирование:</summary>


# Используем макросы и улучшаем фреймворк

Вы начали разрабатывать собственный фреймворк для юнит-тестирования:

-   написали шаблонную функцию  `AssertEqual`. Она даёт возможность проверять на равенство значения в коде и выводить диагностическую информацию, когда проверка не сработала.
-   написали функцию  `Assert`. Ей удобно проверять значения типа  `bool`.

Но во фреймворке есть недостатки:

-   Функции  `AssertEqual`  и  `Assert`, в отличие от стандартного макроса  `assert`, не выводят название файла и номер строки, где произошла ошибка. Временное решение проблемы — добавить дополнительный параметр  `hint`. Он выводит сообщение с подсказкой.
-   Подсказку нужно писать. Без него найти проблему в коде сложно, а писать текст подсказки при каждой проверке — трудоёмко.

В этом уроке вы научите свой фреймворк выводить диагностическую информацию и внесёте в него другие улучшения.

## Узнаём, где проверка не сработала

В C++ перед компиляцией происходит препроцессинг — обработка исходного кода. На этом этапе макросы заменяются на соответствующие им значения. Некоторые макросы, например  `assert`, объявлены в стандартной библиотеке, другие встроены напрямую в компилятор. Сейчас нас интересуют встроенные:

-   `__FILE__`  — вместо него препроцессор вставляет в текст программы имя текущего файла исходного кода;
-   `__LINE__`  — вместо него препроцессор вставляет номер текущей строки;
-   `__FUNCTION__`  — препроцессор заменяет его на имя текущей функции.

Эти макросы улучшат фреймворк. Вот как они работают:

```cpp
#include <iostream>
#include <string>

using namespace std;

void PrintDiagnosticInformation() {
    cout << "Function name: "s << __FUNCTION__ << endl;
    cout << "File name: "s << __FILE__ << endl;
    cout << "Line number: "s << __LINE__ << endl;
    cout << "Line number: "s << __LINE__ << endl;
}

int main() {
    PrintDiagnosticInformation();
}

```

Препроцессор обнаружит макрос  `__FUNCTION__`  и заменит его на строку  `"PrintDiagnosticInformation"`, которая задаёт имя текущей функции. Макрос  `__FILE__`  будет заменён на имя текущего файла исходного кода, а  `__LINE__`  — на номер текущей строки. В результате на этап компиляции будет передан видоизменённый исходный код:

```cpp
#include <iostream>
#include <string>

using namespace std;

void PrintDiagnosticInformation() {
    cout << "Function name: "s << "PrintDiagnosticInformation" << endl;
    cout << "File name: "s << "macro_0_0.cpp" << endl; // У вас может быть другое имя файла
    cout << "Line number: "s << 9 << endl;
    cout << "Line number: "s << 10 << endl;
}

int main() {
    PrintDiagnosticInformation();
}

```

Программа выведет диагностическую информацию:

```
Function name: PrintDiagnosticInformation
File name: macro_0_0.cpp
Line number: 9
Line number: 10

```

## Применяем макросы, которые меняют текст

Вывести диагностическую информацию можно иначе — применить макросы, меняющие одну последовательность символов на другую. Для объявления такого макроса используют директиву  `#define`:

```cpp
#include <iostream>

using namespace std;

// При помощи директивы #define объявляется макрос GREETING
#define GREETING cout << "Hello, friend"s << endl

int main() {
    // Вместо GREETING в код программы будет cout << "Hello, friend"s << endl
    GREETING;

    // Внутри строковых литералов и комментариев подстановка макроса не происходит
    cout << "GREETING"s << endl;
}

```

Макрос  `GREETING`  на этапе препроцессинга будет заменён на код вывода строки “Hello, friend”. То есть одна последовательность символов сменится на другую. Этот пример наглядно показывает работу макросов, но в реальности для решения такой задачи больше подходит функция.

Чтобы отличать макросы от функций, будем и дальше использовать  `UPPER_SNAKE_CASE`  для их именования. Макрос может иметь один или несколько параметров, передаваемых в скобках. При обработке макроса фактические значения его параметров вставляются в исходный код:

```cpp
#include <iostream>

using namespace std;

// Директивой #define объявляем макрос GREETING параметрами s1 и s2
#define GREETING(s1, s2) cout << "Hello, "s << (s1) << " and "s << (s2) << endl

int main() {
    // Будет заменено на:
    // cout << "Hello, "s << ("Ivan"s) << " and "s << ("Maria"s) << endl;
    GREETING("Ivan"s, "Maria"s);

    // Будет заменено на:
    // cout << "Hello, "s << (5 + 5) << " and "s << (42) << endl;
    GREETING(5 + 5, 42);
}

```

Написанный в скобках параметр  `5 + 5`  будет подставлен в исходный код в виде текста. Заключать параметры макроса в скобки — это важно. Разберёмся почему:

```cpp
#include <iostream>

using namespace std;

// Без заключения параметров в скобки
#define MULTIPLY(a, b) a * b

int main() {
    // Макрос MULTIPLY будет раскрыт как 2 + 3 * 5, а не 5 * 5, так как
    // параметры макроса подставляются такими, какие они есть
    cout << MULTIPLY(2 + 3, 5) << endl;
}

```

После раскрытия макроса  `MULTIPLY`  в исходный код будет вставлен текст  `2 + 3 * 5`. Результатом этого выражения будет число 17, хотя от выражения  `MULTIPLY(2 + 3, 5)`  ожидаем получить число 25.

Если в теле макроса перед именем параметра поставить символ  `#`, при раскрытии макроса вместо параметра появится строка, которая содержит его исходный код:

```cpp
#include <iostream>

using namespace std;

// #<имя параметра> подставляет строковое представление параметра макроса
#define PrintExpression(expr) cout << (#expr) << " = "s << (expr) << endl

int main() {
    PrintExpression((8 + 15) * 3);
}

```

Программа выведет:

```
(8 + 15) * 3 = 69

```

Такие особенности макросов можно использовать для вывода диагностической информации. Объявим функцию  `LogImpl`, которая принимает выводимую строку, имя функции, имя файла и номер строки исходного кода. Применение функции без макроса сделает код громоздким. Компактности можно добиться макросом  `LOG`. Он автоматически подставит имя функции, имя файла и номер строки на место своего использования:

```cpp
#include <iostream>
#include <string>

using namespace std;

// Функция LogImpl выполняет основную работу
void LogImpl(const string& str, const string& func_name, const string& file_name, int line_number) {
    cout << file_name << "("s << line_number << "): "s;
    cout << func_name << ": "s << str << endl;
}

// Макрос LOG используется для удобного вызова функции LogImpl
#define LOG(expr) LogImpl(#expr, __FUNCTION__, __FILE__, __LINE__)

int main() {
    // Функцию LogImpl можно вызывать напрямую, но это не очень удобно
    LogImpl("12345"s, __FUNCTION__, __FILE__, __LINE__);

    // Макрос LOG раскрывается в вызов функции LogImpl более удобно
    LOG(12345);
    LOG("hello"s);
    LOG(1 + 10);
}

```

Код выведет:

```
macro_4.cpp(17): main: 12345
macro_4.cpp(20): main: 12345
macro_4.cpp(21): main: "hello"s
macro_4.cpp(22): main: 1 + 10

```

В повседневной разработке на C++ макросы нужны редко. На этапе препроцессинга они заменяют исходный код на новый. Разница между новым и исходным кодом может затруднить отладку. Иногда макросы действительно позволяют решить задачу более эффективно. Но часто лучше использовать сочетание макросов и функций, в том числе шаблонных.

## Улучшаем функцию AssertEqual

Теперь понятно, как научить функцию  `AssertEqual`  выводить диагностическую информацию. Преобразуем  `AssertEqual`  в функцию  `AssertEqualImpl`  и добавим макросы  `ASSERT_EQUAL`  и  `ASSERT_EQUAL_HINT`. Они упрощают передачу вспомогательных данных в эту функцию:

```cpp
template <typename T, typename U>
void AssertEqualImpl(const T& t, const U& u, const string& t_str, const string& u_str, const string& file,
                     const string& func, unsigned line, const string& hint) {
    if (t != u) {
        cout << boolalpha;
        cout << file << "("s << line << "): "s << func << ": "s;
        cout << "ASSERT_EQUAL("s << t_str << ", "s << u_str << ") failed: "s;
        cout << t << " != "s << u << "."s;
        if (!hint.empty()) {
            cout << " Hint: "s << hint;
        }
        cout << endl;
        abort();
    }
}

#define ASSERT_EQUAL(a, b) AssertEqualImpl((a), (b), #a, #b, __FILE__, __FUNCTION__, __LINE__, ""s)

#define ASSERT_EQUAL_HINT(a, b, hint) AssertEqualImpl((a), (b), #a, #b, __FILE__, __FUNCTION__, __LINE__, (hint))

int Sum(int a, int b) {
    // Ошибка допущена намеренно, чтобы продемонстрировать вывод информации об ошибке
    return a + b + 1;
}

int main() {
    string hello = "hello"s;
    ASSERT_EQUAL(hello.length(), 5);

    // Эта проверка не пройдёт
    ASSERT_EQUAL_HINT(Sum(2, 2), 4, "Sum() must be correct"s);
}

```

При срабатывании макроса будет выведена диагностическая информация, которая облегчит обнаружение и исправление ошибок:

```
assert_3.cpp(38): main: ASSERT_EQUAL_HINT(Sum(2, 2), 4) failed: 5 != 4. Hint: Sum() must be correct

```

В задании вы аналогичным способом улучшите работу функции  `Assert`.

----------

Зачем преобразовывать функции  `AssertEqual`  и  `Assert`  в макросы, вызывающие функции  `AssertEqualImpl`  и  `AssertImpl`? Выберите несколько вариантов ответа.

-   Механизм макросов позволяет получать значения своих параметров в виде строки.
    
-   Внутри макроса можно использовать другие макросы, такие как  `__FILE__`,  `__LINE__`,  `__FUNCTION__`. Их значения будут подставляться при раскрытии основного макроса на этапе препроцессинга.
    
-   Код c макросами работает быстрее.

</details>  

<details>  
<summary>Ответы:</summary>
# Ответы на задания

----------

Зачем преобразовывать функции  `AssertEqual`  и  `Assert`  в макросы, вызывающие функции  `AssertEqualImpl`  и  `AssertImpl`? Выберите несколько вариантов ответа.

-   **(+)**  Механизм макросов позволяет получать значения своих параметров в виде строки.
    
    -   Эту особенность мы использовали, чтобы получить строковое представление сравниваемых параметров макроса в том виде, в каком они были в исходном коде.
-   **(+)**  Внутри макроса можно использовать другие макросы, такие как  `__FILE__`,  `__LINE__`,  `__FUNCTION__`. Их значения будут подставляться при раскрытии основного макроса на этапе препроцессинга.
    
    -   Так при использовании фреймворка не нужно будет передавать большинство параметров вручную.
-   **(-)**  Код c макросами работает быстрее.
    
    -   В общем случае это не так.
</details>  

<details>  
<summary>Задание:</summary>


## Задание

Усовершенствуйте фреймворк. Реализуйте макросы  `ASSERT`  и  `ASSERT_HINT`. Пусть в случае их срабатывания выводится информация об имени файла, номере строки и функции, где макрос сработал.

Пример диагностической информации, выводимой макросом  `ASSERT(2 + 2 == 5)`:

```
assert.cpp(48): main: ASSERT(2 + 2 == 5) failed.

```

Пример диагностической информации, выводимой макросом  `ASSERT_HINT(2 + 2 == 5, "This will fail"s)`:

```
assert.cpp(48): main: ASSERT(2 + 2 == 5) failed. Hint: This will fail

```

### Подсказка

Выделите функцию  `AssertImpl`, принимающую диагностические параметры так же, как функция  `AssertEqualImpl`  в уроке. Макросы  `ASSERT`  и  `ASSERT_HINT`  должны содержать код вызова этой функции с передачей нужных значений параметров.
</details>  
