<details>  
<summary>Тестирование:</summary>

# Тест о тестах



Зачем нужна функция  `RunTestImpl`  и почему она должна быть шаблонной? Выберите несколько вариантов ответа.

-   Чтобы код не дублировался, когда выводится сообщение об успешном окончании теста.
    
-   Чтобы выводить более понятные сообщения, когда тесты падают.
    
-   Чтобы передавать юнит-тесты в качестве параметров, не указывая явно их тип.
    
-   Чтобы студенты Практикума провели больше времени с С++.
    

----------

А для чего в дополнение к функции  `RunTestImpl`  вводится макрос  `RUN_TEST`? Выберите несколько вариантов ответа.

-   Ей одиноко.
    
-   У макроса  `RUN_TEST`  всего один параметр, поэтому его легче использовать.
    
-   Чтобы делать меньше ошибок при вызове тестов.
    
-   Макрос  `RUN_TEST`  выполняется быстрее, чем функция  `RunTestImpl`.

</details> 

<details>  
<summary>Ответы:</summary>

# Ответы на задания

Зачем нужна функция  `RunTestImpl`  и почему она должна быть шаблонной? Выберите несколько вариантов ответа.

-   **(+)**  Чтобы код не дублировался, когда выводится сообщение об успешном окончании теста.
    
    -   Да, без шаблона  `RunTestImpl`  пришлось бы в каждом юнит-тесте писать код вывода сообщений.
-   **(-)**  Чтобы выводить более понятные сообщения, когда тесты падают.
    
    -   Скорее, за это отвечает шаблон  `AssertEqualImpl`  и  `AssertImpl`.
-   **(+)**  Чтобы передавать юнит-тесты в качестве параметров, не указывая явно их тип.
    
    -   Именно поэтому  `RunTestImpl`  — шаблон, а не просто функция. Компилятор выводит тип за нас, и мы можем передавать функции в качестве параметров, не зная, какой именно у них тип.
-   **(-)**  Чтобы студенты Практикума провели больше времени с С++.
    
    -   У вас и так впереди много прекрасных минут.

----------

А для чего в дополнение к функции  `RunTestImpl`  вводится макрос  `RUN_TEST`? Выберите несколько вариантов ответа.

-   **(-)**  Ей одиноко.
    
    -   Причины более приземлённые.
-   **(+)**  У макроса  `RUN_TEST`  всего один параметр, поэтому его легче использовать.
    
    -   Макрос  `RUN_TEST`  автоматически определяет имя теста, переведя в строковое представление свой единственный аргумент, и передаёт его в качестве второго параметра функции  `RunTestImpl`.
-   **(+)**  Чтобы делать меньше ошибок при вызове тестов.
    
    -   Так пользователю не нужно передавать строку, которая задаёт имя теста. То есть риск сделать опечатку в имени теста снижается. А если тестирующую функцию переименуют, синхронизировать её название и имя теста не придётся
-   **(-)**  Макрос  `RUN_TEST`  выполняется быстрее, чем функция  `RunTestImpl`.
    
    -   Так как макрос  `RUN_TEST`  раскрывается в вызов функции  `RunTestImpl`, он не может выполняться быстрее вызываемой функции.

</details>  

<details>  
<summary>Теория:</summary>

# Фреймворк и поисковая система

В предыдущих уроках вы шаг за шагом улучшали свой тестовый фреймворк. Теперь его можно использовать для юнит-тестирования вашей поисковой системы вместо стандартного макроса  `assert`.

</details>  

<details>  
<summary>Задание:</summary>

## Задание

Это задание — итоговый проект второго спринта. Вы будете сдавать его на проверку через репозиторий на GitHub. А пока сохраните решение в своей IDE.

Примените макросы  `ASSERT`,  `ASSERT_HINT`,  `ASSERT_EQUAL`  и  `ASSERT_EQUAL_HINT`  для проверки работы основных функций поисковой системы, таких как:

-   Добавление документов. Добавленный документ должен находиться по поисковому запросу, который содержит слова из документа.
-   Поддержка стоп-слов. Стоп-слова исключаются из текста документов.
-   Поддержка минус-слов. Документы, содержащие минус-слова из поискового запроса, не должны включаться в результаты поиска.
-   Соответствие документов поисковому запросу. При этом должны быть возвращены все слова из поискового запроса, присутствующие в документе. Если есть соответствие хотя бы по одному минус-слову, должен возвращаться пустой список слов.
-   Сортировка найденных документов по релевантности. Возвращаемые при поиске документов результаты должны быть отсортированы в порядке убывания релевантности.
-   Вычисление рейтинга документов. Рейтинг добавленного документа равен среднему арифметическому оценок документа.
-   Фильтрация результатов поиска с использованием предиката, задаваемого пользователем.
-   Поиск документов, имеющих заданный статус.
-   Корректное вычисление релевантности найденных документов.

### Как будет происходить проверка этого задания

Разработанные вами тесты должны иметь точку входа, заданную функцией  `TestSearchServer`. Код поисковой системы должен успешно проходить ваши тесты. Тренажёр проверит работу тестов на нескольких реализациях класса  `SearchServer`. Одна из реализаций будет корректной, в других будут ошибки в логике работы класса. Задача считается решённой при выполнении следующих условий:

-   Корректная реализация класса  `SearchServer`  успешно проходит тесты, которые вы разработали;
-   Ваши тесты выявляют не менее 50% некорректных реализаций класса  `SearchServer`;
-   Ваши тесты используют макросы фреймворка вместо стандартного макроса  `assert`.

Тренажёр ожидает, что ваша реализация класса SearchServer будет содержать следующие публичные методы.

```cpp
struct Document {
    int id;
    double relevance;
    int rating;
};

enum class DocumentStatus {
    ACTUAL,
    IRRELEVANT,
    BANNED,
    REMOVED,
};

class SearchServer {
public:
    void SetStopWords(const string& text) {
        // Ваша реализация данного метода
    }

    void AddDocument(int document_id, const string& document, DocumentStatus status, const vector<int>& ratings) {
        // Ваша реализация данного метода
    }

    template <typename DocumentPredicate>
    vector<Document> FindTopDocuments(const string& raw_query, DocumentPredicate document_predicate) const {
        // Ваша реализация данного метода
    }

    vector<Document> FindTopDocuments(const string& raw_query, DocumentStatus status) const {
        // Ваша реализация данного метода
    }

    vector<Document> FindTopDocuments(const string& raw_query) const {
        // Ваша реализация данного метода
    }

    int GetDocumentCount() const {
        // Ваша реализация данного метода
    }

    tuple<vector<string>, DocumentStatus> MatchDocument(const string& raw_query, int document_id) const {
        // Ваша реализация данного метода
    }

private:
    // Реализация приватных методов вашей поисковой системы
}; 

```

Перед вами исходный код с примером теста, проверяющего, что стоп-слова при добавлении документа исключаются поисковой системой. На проверку отправьте только сами тесты, которые напишете между комментариями:

`// -------- Начало модульных тестов поисковой системы ----------`  и

`// --------- Окончание модульных тестов поисковой системы -----------`.

### Подсказка

Используйте свои готовые юнит-тесты поисковой системы. Макрос  `assert`  в них замените на подходящие по смыслу макросы  `ASSERT`  и  `ASSERT_EQUAL`.  `ASSERT_EQUAL`  выдаёт больше полезной информации, когда нарушается условие равенства проверяемых значений.

</details>  
