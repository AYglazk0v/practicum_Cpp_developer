<details>
<summary>Теория:</summary>

# Устройство unordered_map и unordered_set

В этом уроке разберёмся, что позволило контейнеру  `unordered_map`  работать в разы быстрее, чем его «‎коллега»‎  `map`. Вы увидите, как использовать его для своих классов, заменив собственный контейнер из прошлого урока на стандартный.

Для начала обратимся к документации. Ранее вы использовали методы  `unordered_map::operator[]`  и  `unordered_map::insert`. Согласно сайту  [cppreference.com](http://cppreference.com/), сложность этих методов в среднем действительно лучше, чем у  `map`. Она оценивается как O(1), если хеш-функция имеет константную сложность.

Но в худшем случае возникает O(N), где N — количество элементов в контейнере. Чтобы понять, какой случай будет худшим, а какой средним, нужно разобраться, как работает  `unordered_map`  и как получилось добиться такой удивительной средней сложности O(1).

В устройстве  `unordered_map`  и  `unordered_set`  лежат идеи, похожие на те, что вы применили при решении задачи в прошлом уроке. Эти контейнеры хранят объекты в корзинках и используют хеш-функцию, чтобы определить, в какой корзинке разместить объект. В  `unordered_map`  и  `unordered_set`  реализованы алгоритмы для определения количества корзинок и разрешения коллизий.

Главное отличие  `unordered_set`  от контейнера, который вы разрабатывали в задаче, — он не использует отдельную корзинку для каждого возможного значения хеш-функции. Благодаря этому хеши объектов могут быть очень большими, а количество выделенных корзинок всё равно будет невелико. Заботиться о том, чтобы объекты располагались компактно в отведённых для них корзинках, не нужно: контейнер сам организует размещение объектов по корзинкам.

В хорошем случае коллизий мало или нет вовсе. Каждая корзинка хранит максимум одно значение, добавление очень быстрое — вычисляем хеш объекта, быстро находим по индексу корзинку и добавляем. Проверка наличия и печать всех элементов будет такой же быстрой. Но хороший случай вероятен только при хорошей хеш-функции. При некоторых условиях он практически гарантирован.

Заменим контейнер из предыдущего урока на  `unordered_set`:

```cpp
#include <unordered_set>

// реализация class VehiclePlate из предыдущего урока

int main() {
    unordered_set<VehiclePlate> plate_base;

    plate_base.insert({'B', 'H', 840, 'E', 99});
    plate_base.insert({'O', 'K', 942, 'K', 78});
    plate_base.insert({'O', 'K', 942, 'K', 78});
    plate_base.insert({'O', 'K', 942, 'K', 78});
    plate_base.insert({'O', 'K', 942, 'K', 78});
    plate_base.insert({'H', 'E', 968, 'C', 79});
    plate_base.insert({'T', 'A', 326, 'X', 83});
    plate_base.insert({'H', 'H', 831, 'P', 116});
    plate_base.insert({'A', 'P', 831, 'Y', 99});
    plate_base.insert({'P', 'M', 884, 'K', 23});
    plate_base.insert({'O', 'C', 34, 'P', 24});
    plate_base.insert({'M', 'Y', 831, 'M', 43});
    plate_base.insert({'B', 'P', 831, 'M', 79});
    plate_base.insert({'K', 'T', 478, 'P', 49});
    plate_base.insert({'X', 'P', 850, 'A', 50});

    for (auto& plate : plate_base) {
        cout << plate << endl;
    }
}

```

При попытке собрать и запустить эту программу получим такое сообщение:  `error: static assertion failed: hash function must be invocable with an argument of key type`  `static_assert(__is_invocable<const _H1&, const _Key&>{}`.

Эта ошибка показывает, что контейнер не нашёл хеш-функцию для класса. Мы определили хеш-функцию в методе  `Hash`, но не сказали контейнеру, что именно её нужно использовать для хеширования.

Чтобы сообщить  `unordered_set`  и  `unordered_map`, как именно вычислять хеш произвольного объекта, нужно создать специальный класс — хешер и указать его в качестве шаблонного параметра контейнера. К хешеру предъявляется только одно требование: объект этого класса должен быть вызываемым — например, переопределять оператор «круглые скобки». Вызов этого объекта должен возвращать число типа  `size_t`  (этот тип используется в  `unordered_set`  и  `unordered_map`  для хеширования).

Проще всего понять, как реализовать хешер, на примере:

```cpp
...

class VehiclePlateHasher {
public:
    size_t operator()(const VehiclePlate& plate) const {
        return static_cast<size_t>(plate.Hash());
    }
};

int main() {
    // явно указываем хешер шаблонным параметром
    unordered_set<VehiclePlate, VehiclePlateHasher> plate_base;

    plate_base.insert({'B', 'H', 840, 'E', 99});
    plate_base.insert({'O', 'K', 942, 'K', 78});
    plate_base.insert({'O', 'K', 942, 'K', 78});
    plate_base.insert({'O', 'K', 942, 'K', 78});
    plate_base.insert({'O', 'K', 942, 'K', 78});
    plate_base.insert({'H', 'E', 968, 'C', 79});
    plate_base.insert({'T', 'A', 326, 'X', 83});
    plate_base.insert({'H', 'H', 831, 'P', 116});
    plate_base.insert({'A', 'P', 831, 'Y', 99});
    plate_base.insert({'P', 'M', 884, 'K', 23});
    plate_base.insert({'O', 'C', 34, 'P', 24});
    plate_base.insert({'M', 'Y', 831, 'M', 43});
    plate_base.insert({'B', 'P', 831, 'M', 79});
    plate_base.insert({'K', 'T', 478, 'P', 49});
    plate_base.insert({'X', 'P', 850, 'A', 50});

    for (auto& plate : plate_base) {
        cout << plate << endl;
    }
}

```

В стандартной библиотеке уже определены хешеры для стандартных объектов: строк, чисел, указателей,  `optional`  и некоторых других. Эти хешеры реализованы в шаблонном классе  [`hash`](https://en.cppreference.com/w/cpp/utility/hash).

Скомпилируем заново. Ошибка поменялась, теперь компилятору не нравится отсутствие операции сравнения:  `error: no match for 'operator==' (operand types are 'const VehiclePlate' and 'const VehiclePlate')`. Вы уже разработали эту операцию в задании прошлого урока. В этом уроке реализуем его, используя операцию сравнения объектов  `tuple`  из стандартной библиотеки:

```cpp
#include <tuple>

...

class VehiclePlate {
private:
    auto AsTuple() const {
        return tie(letters_, digits_, region_);
    }

public:
    bool operator==(const VehiclePlate& other) const {
        return AsTuple() == other.AsTuple();
    }
...
};

```

Ура, программа скомпилировалась! Проверяем результат:

```cpp
KT478P49
TA326X83
XP850A50
OK942K78
HE968C79
BH840E99
PM884K23
HH831P116
AP831Y99
MY831M43
BP831M79
OC034P24

```

Результат правильный, но порядок вывода отличается от того, который был в нашем контейнере. Трудно понять почему. Проверим, подчиняется ли этот порядок какому-нибудь закону. Для этого переложим все номера в другой  `unordered_set`  и выведем его содержимое:

```cpp
...

int main() {
    unordered_set<VehiclePlate, VehiclePlateHasher> plate_base;

    ...

    cout << "Первый контейнер:"s << endl;
    for (auto& plate : plate_base) {
        cout << plate << endl;
    }

    cout << "Второй контейнер:"s << endl;
    unordered_set<VehiclePlate, VehiclePlateHasher> plate_base2(plate_base.begin(), plate_base.end());
    for (auto& plate : plate_base2) {
        cout << plate << endl;
    }
}

```

Проверяем результат работы программы:

```cpp
Первый контейнер:
KT478P49
TA326X83
XP850A50
OK942K78
HE968C79
BH840E99
PM884K23
HH831P116
AP831Y99
MY831M43
BP831M79
OC034P24
Второй контейнер:
BP831M79
MY831M43
AP831Y99
HH831P116
PM884K23
OC034P24
BH840E99
HE968C79
OK942K78
XP850A50
TA326X83
KT478P49

```

Оба контейнера содержат одинаковые элементы, но выдают их в разном порядке, значит, порядок  `unordered_set`  действительно произвольный, он не определяется содержимым. Заметим, что элементы одной корзинки вывелись рядом, однако это тоже может зависеть от реализации  `unordered_set`.

Аналогично устроен контейнер  `unordered_map`, которым можно смело заменять  `map`, если порядок элементов неважен. Как и в  `unordered_set`, в этом контейнере требуется, чтобы ключи удовлетворяли двум условиям:

-   имели хешер — класс, вычисляющий хеш-функцию. Тип хешера указывается третьим параметром шаблона  `unordered_map`  и вторым параметром шаблона  `unordered_set`;
-   имели возможность сравнения операцией  `operator==`.

В случае  `unordered_map`  эти условия должны быть соблюдены для ключей, а значения могут быть произвольными.

Если не хотите определять  `operator==`, можно поменять компаратор, задаваемый шаблонным параметром после хешера. Компаратор похож на хешер и тоже использует  `operator()`  для выполнения действия. В отличие от хешера, он не вычисляет характеристику одного объекта, а определяет понятие равенства.

Компаратор можно менять в обычных  `map`  и  `set`. Для этих контейнеров равенства недостаточно, они должны определять, какой элемент больше, а какой меньше. Компаратор по умолчанию в них —  `std::less`. Он использует  `operator<`. Если хотите использовать свой класс в  `set`  или в качестве ключа в  `map`, достаточно определить для элементов этого типа операцию сравнения  `<`. В случае с  `VehiclePlate`  можно определить операцию сравнения, используя уже готовый метод  `AsTuple`:

```cpp
class VehiclePlate {
private:
    auto AsTuple() const {
        return tie(letters_, digits_, region_);
    }

public:
    bool operator<(const VehiclePlate& other) const {
        return AsTuple() < other.AsTuple();
    }
...
};
```

</details>

<details>
<summary>Задание 1:</summary>

## Задание 1

Автостоянка у бизнес-центра «Ассоциарий»‎ взимает плату с владельцев автомобилей за количество парковок в определённом месяце. Реализуйте класс  `ParkingCounter`, который будет считать автомобили. Класс должен иметь три метода:

-   `void Park(VehiclePlate car)`, который регистрирует парковку автомобиля;
-   `int GetCount(const VehiclePlate& car) const`, который вычисляет количество парковок определённого автомобиля;
-   `auto& GetAllData() const`, который возвращает ассоциативный контейнер, содержащий количество парковок по каждому номеру.

Храните количества парковок в контейнере  `unordered_map`. Учитывайте, что для номеров, которые не добавлены ни разу, функция  `GetCount`  должна вернуть 0.

Модифицируйте класс  `VehiclePlateHasher`, чтобы он учитывал все данные номера. Рекомендуется создать для хеширования объект типа  `hash<string>`  и выдавать хеш строкового представления номера, полученного методом  `ToString()`.

Скопируйте реализованный хешер, он вам пригодится для следующего задания.

### Ограничения

-   Для хранения открытых парковок и счетов на данный момент используйте контейнер  `unordered_map`. Не меняйте метод  `GetAllData`.
-   Хешер должен учитывать все данные номера.
-   Не меняйте класс  `VehiclePlate`.
-   Не используйте  `map`  и  `set`.

### Пример

```cpp
ParkingCounter parking;

parking.Park({'B', 'H', 840, 'E', 99});
parking.Park({'O', 'K', 942, 'K', 78});
parking.Park({'O', 'K', 942, 'K', 78});
parking.Park({'O', 'K', 942, 'K', 78});
parking.Park({'O', 'K', 942, 'K', 78});
parking.Park({'H', 'E', 968, 'C', 79});
parking.Park({'T', 'A', 326, 'X', 83});
parking.Park({'H', 'H', 831, 'P', 116});
parking.Park({'A', 'P', 831, 'Y', 99});
parking.Park({'P', 'M', 884, 'K', 23});
parking.Park({'O', 'C', 34, 'P', 24});
parking.Park({'M', 'Y', 831, 'M', 43});
parking.Park({'B', 'P', 831, 'M', 79});
parking.Park({'O', 'K', 942, 'K', 78});
parking.Park({'K', 'T', 478, 'P', 49});
parking.Park({'X', 'P', 850, 'A', 50});

assert(parking.GetCount({'O', 'K', 942, 'K', 78}) == 5);
assert(parking.GetCount({'A', 'B', 111, 'C', 99}) == 0);

for(auto& [plate, count] : parking.GetAllData()) {
    cout << plate << " "s << count << endl;
}

```

Возможный вывод:

```cpp
XP850A50 1
TA326X83 1
HE968C79 1
KT478P49 1
AP831Y99 1
OK942K78 5
BH840E99 1
BP831M79 1
HH831P116 1
MY831M43 1
PM884K23 1
OC034P24 1

```

### Подсказка

-   `unordered_map`  по использованию не отличается от  `map`, только не забудьте указать третий шаблонный параметр — хешер.
-   В класс  `VehiclePlateHasher`  добавьте поле класса  `hash<string> hasher_`. Чтобы вычислить хеш строки, его можно использовать так:  `hasher_("abc"s)`. Примените хешер к строковому представлению номера для вычисления его хеша.

</details>

<details>
<summary>Задание 2:</summary>

## Задание 2

Совет директоров бизнес-центра «Ассоциарий» решил изменить порядок оплаты парковки. Теперь плата взимается за количество проведённых на стоянке секунд. Автовладелец должен иметь возможность в любой момент времени проверить, сколько начислено за парковку его автомобиля в текущий момент, учитывая в том числе незавершённую парковку.

В этом задании вам пригодится хешер номеров из предыдущего задания.

Разработайте класс  `Parking`, имеющий следующие методы:

-   Конструктор  `Parking(int cost_per_second)`  — указывается стоимость одной секунды парковки.
-   `void Park(VehiclePlate car)`  — запарковать машину с указанным номером. В случае если машина с указанным номером уже запаркована, сгенерируйте исключение  `ParkingException`  (этот класс есть в заготовке).
-   `void Withdraw(const VehiclePlate& car)`  — забрать машину с указанным номером. В случае если указанный автомобиль не был запаркован, сгенерируйте исключение  `ParkingException`.
-   `int64_t GetCurrentBill(const VehiclePlate& car) const`  — получить счёт за конкретный автомобиль. Для вычисления стоимости умножьте количество проведённых автомобилем на парковке секунд на число  `cost_per_second_`. Должны быть учтены все завершённые парковки. Если автомобиль запаркован на момент вызова, то в сумму должна быть включена также стоимость его незавершённой парковки на данный момент. Если номера нет в системе, верните ноль.
-   `unordered_map<VehiclePlate, int64_t, VehiclePlateHasher> EndPeriodAndGetBills()`  — завершить расчётный период. Вернуть счета за все автомобили в одном ассоциативном контейнере. Нулевые счета включать в расчёт не нужно. Кроме того, вам нужно обнулить все счета. Если какие-нибудь автомобили запаркованы в момент вызова, они должны остаться на парковке, но отсчёт времени для них начинается заново.

Для определения времени класс  `Parking`  использует шаблонный параметр  `class Clock`. Узнать текущее время можно, вызвав статический метод  `Clock::now()`. Он возвращает объект типа  `Clock::time_point`. Длительность имеет тип  `Clock::duration`, это разность двух объектов типа  `Clock::time_point`. Рекомендуется использовать для этих типов псевдонимы  `TimePoint`  и  `Duration`, которые объявлены в заготовке кода. Получить из  `Duration`  секунды можно функцией  `duration_cast`, которую вы проходили в теме о профилировке.

Во всех методах этого класса, которые зависят от текущего момента, время нужно измерить один раз вызовом  `Clock::now`  в любой момент во время выполнения метода.

В заготовке кода вы найдёте класс  `TestClock`  — часы, упрощающие тестирование кода. Если указать их в качестве шаблонного параметра, время операции вы будете задавать явно статической функцией  `TestClock::SetNow`. Пример — в заготовке кода.

В заготовке кода также есть методы  `GetNowParked`  и  `GetCurrentDurations`. Они возвращают внутренние контейнеры класса  `Parking`. Не меняйте их, иначе программа не пройдёт тестирование.

### Ограничения

Для хранения открытых и завершённых парковок используйте два контейнера  `unordered_map`, которые представлены в заготовке кода. Не меняйте методы получения контейнеров, класс  `VehiclePlate`, не добавляйте в класс  `Parking`  новых полей.

Хешер номеров должен удовлетворять всем требованиям предыдущей задачи.

### Пример

Пример приведён в заготовке кода. Там же реализованы часы, которые можно использовать для тестирования. Они показывают столько времени, сколько задал пользователь явно.

### Как будет тестироваться ваш код

Мы проверим:

-   корректность реализации методов класса  `Parking`;
-   то, что хешер номеров учитывает все компоненты номера автомобиля;
-   то, что вы не меняли класс  `VehiclePlate`;
-   то, что вы не изменили поля класса  `Parking`  и не использовали  `map`;
-   выбрасывание исключения  `ParkingException`  при некорректных операциях;
-   то, что в контейнерах  `now_parked_`  и  `complete_parks_`  всегда корректные данные.

### Подсказка

-   `unordered_map`  очень похож на обычный  `map`, он поддерживает те же методы:  `erase`,  `clear`,  `at`.
-   Для получения количества секунд из  `Duration`  можно применить такую конструкцию:  `chrono::duration_cast<chrono::seconds>(duration).count()`. Затем для получения стоимости нужно умножить количество секунд на стоимость секунды.
-   Можете складывать объекты типа  `Duration`.

</details>
