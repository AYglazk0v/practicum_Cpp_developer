
<details>
<summary>Теория + тестирование:</summary>

# Хорошие и плохие хеш-функции

Мы рассмотрели уже две хеш-функции для автомобильных номеров. Одна — простая — учитывала только цифровую часть. Другая — её вы написали сами — учитывала весь номер, но предварительно конвертировала его в строку. В этом уроке выясним, можно ли утверждать, что одна из них лучше другой, и разберёмся, что такое хорошая хеш-функция. Вы увидите:  `unordered_map`  может быть эффективным, только если выбранная хеш-функция хороша.

В этом уроке нам понадобится генератор случайных номеров:

```cpp
class PlateGenerator {
    char GenerateChar() {
        uniform_int_distribution<short> char_gen{0, static_cast<short>(possible_chars_.size() - 1)};
        return possible_chars_[char_gen(engine_)];
    }

    int GenerateNumber() {
        uniform_int_distribution<short> num_gen{0, 999};
        return num_gen(engine_);
    }

    int GenerateRegion() {
        uniform_int_distribution<short> region_gen{0, static_cast<short>(possible_regions_.size() - 1)};
        return possible_regions_[region_gen(engine_)];
    }

public:
    VehiclePlate Generate() {
        return VehiclePlate(GenerateChar(), GenerateChar(), GenerateNumber(), GenerateChar(), GenerateRegion());
    }

private:
    mt19937 engine_;

    // допустимые значения сохраним в static переменных
    // они объявлены inline, чтобы их определение не надо было выносить вне класса
    inline static const array possible_regions_
        = {1,  2,  102, 3,   4,   5,   6,   7,   8,  9,   10,  11,  12, 13,  113, 14,  15, 16,  116, 17, 18,
           19, 20, 21,  121, 22,  23,  93,  123, 24, 84,  88,  124, 25, 125, 26,  27,  28, 29,  30,  31, 32,
           33, 34, 35,  36,  136, 37,  38,  85,  39, 91,  40,  41,  82, 42,  142, 43,  44, 45,  46,  47, 48,
           49, 50, 90,  150, 190, 51,  52,  152, 53, 54,  154, 55,  56, 57,  58,  59,  81, 159, 60,  61, 161,
           62, 63, 163, 64,  164, 65,  66,  96,  67, 68,  69,  70,  71, 72,  73,  173, 74, 174, 75,  80, 76,
           77, 97, 99,  177, 199, 197, 777, 78,  98, 178, 79,  83,  86, 87,  89,  94,  95};

    // постфикс s у литерала тут недопустим, он приведёт к неопределённому поведению
    inline static const string_view possible_chars_ = "ABCEHKMNOPTXY"sv;
};

```

Протестируем генератор номеров, выведя десять случайных:

```cpp
...

int main() {
    static const int N = 10;
    PlateGenerator plate_gen;

    for (int i = 0; i < N; ++i) {
        cout << plate_gen.Generate() << endl;
    }
}

```

Проверяем:

```cpp
BT905B173
HO221X87
NC278N11
YY996Y95
YY970P17
ET798M13
XB421A16
MY878T59
XH035T159
KO681Y22

```

Номера выглядят как случайные. Протестируем с помощью этого генератора различные хеш-функции. Начнём с простой, учитывающей только цифровую часть:

```cpp
class VehiclePlate {
private:
    auto AsTuple() const {
        return tie(letters_, digits_, region_);
    }

public:
    bool operator==(const VehiclePlate& other) const {
        return AsTuple() == other.AsTuple();
    }

    bool operator<(const VehiclePlate& other) const {
        return AsTuple() < other.AsTuple();
    }

    VehiclePlate(char l0, char l1, int digits, char l2, int region)
        : letters_{l0, l1, l2}
        , digits_(digits)
        , region_(region) {
    }

    string ToString() const {
        ostringstream out;
        out << letters_[0] << letters_[1];
        out << setfill('0') << right << setw(3) << digits_;
        out << letters_[2] << setw(2) << region_;

        return out.str();
    }

    const array<char, 3>& GetLetters() const {
        return letters_;
    }

    int GetDigits() const {
        return digits_;
    }

    int GetRegion() const {
        return region_;
    }

private:
    array<char, 3> letters_;
    int digits_;
    int region_;
};

struct PlateHasherTrivial {
    size_t operator()(const VehiclePlate& plate) const {
        return static_cast<size_t>(plate.GetDigits());
    }
};

```

Для проверки эффективности контейнера с такой хеш-функцией добавим в него 50 000 случайных номеров и столько же поищем. Будем сравнивать  `unordered_set`  и обычный  `set`. Чтобы поставить контейнеры в равное положение, вначале сгенерируем случайные номера и сохраним их в вектор:

```cpp
#include "log_duration.h"

#include <algorithm>
#include <iterator>
#include <set>
#include <unordered_set>

...

int main() {
    static const int N = 50'000;

    PlateGenerator generator;
    vector<VehiclePlate> fill_vector;
    vector<VehiclePlate> find_vector;

    generate_n(back_inserter(fill_vector), N, [&]() {
        return generator.Generate();
    });
    generate_n(back_inserter(find_vector), N, [&]() {
        return generator.Generate();
    });

    int found;
    {
        LOG_DURATION("unordered_set");
        unordered_set<VehiclePlate, PlateHasherTrivial> container;
        for (auto& p : fill_vector) {
            container.insert(p);
        }
        found = count_if(find_vector.begin(), find_vector.end(), [&](const VehiclePlate& plate) {
            return container.count(plate) > 0;
        });
    }
    cout << "Найдено повторов (1): "s << found << endl;

    {
        LOG_DURATION("set");
        set<VehiclePlate> container;
        for (auto& p : fill_vector) {
            container.insert(p);
        }
        found = count_if(find_vector.begin(), find_vector.end(), [&](const VehiclePlate& plate) {
            return container.count(plate) > 0;
        });
    }
    cout << "Найдено повторов (2): "s << found << endl;
}

```

Соберём программу с оптимизацией и проверим результат:

```cpp
unordered_set: 371 ms
Найдено повторов (1): 9
set: 52 ms
Найдено повторов (2): 9

```

Оба алгоритма выдали одинаковый ответ, но  `unordered_set`, вопреки теоретической оценке сложности, оказался вовсе не быстрее, а, наоборот, примерно в семь раз медленнее.

----------

Как вы думаете, почему так происходит?

-   Возникает много коллизий,  `unordered_set`  не может работать эффективно при таких условиях.
    
-   Хеш-функция вычисляется медленно, а в обычном  `set`  ничего не нужно вычислять.
    
-   С  `unordered_set`  всё в порядке, просто попался хороший случай для  `set`  и он работает быстро.
    
-   Всё правильно — оценка худшего случая для  `unordered_set`  хуже, а в предыдущих уроках говорилось, что нужно обращать внимание на худший случай.
    

Мы подобрали неудачную хеш-функцию, она провоцирует коллизии. Хорошо, что это всего лишь коллизии номеров в контейнере, а не машин на дорогах! Однако результат не лучший.

----------

Сможете ли вы оценить примерное количество коллизий? Сколько номеров попадает в одну корзинку?

-   В каждой корзинке ровно один номер.
    
-   Не много, но и не мало — примерно 50 номеров в каждой корзинке.
    
-   Очень много, примерно по 5 000 номеров в каждой корзинке!
    
-   Все номера попали в одну корзинку.
    

Хеш-функция может принимать всего 1000 разных значений. Это значит, что будет задействовано примерно 1000 корзин. Так как номеров 50 000, на каждую корзину приходится по 50 номеров. Это очень большое количество коллизий. Вот почему желательно, чтобы хеш-функция учитывала все данные.

----------

Модифицируем хеш-функцию, чтобы она учитывала не только цифровую часть, но и код региона:

```cpp
struct PlateHasherRegion {
    size_t operator()(const VehiclePlate& plate) const {
        return static_cast<size_t>(plate.GetDigits() + plate.GetRegion() * 1000);
    }
};

...

unordered_set<VehiclePlate, PlateHasherRegion> container;

```

Умножая регион на 1000 и прибавляя цифровую часть, мы как бы объединяем два числа в одно, получая одно пятизначное или шестизначное число.

![img.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint9/%D0%90%D1%81%D1%81%D0%B8%D1%86%D0%B8%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B/%D0%A5%D0%BE%D1%80%D0%BE%D1%88%D0%B8%D0%B5_%D0%B8_%D0%BF%D0%BB%D0%BE%D1%85%D0%B8%D0%B5_%D1%85%D0%B5%D1%88-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8/img.png?raw=true)

Проверяем результат:

```
unordered_set: 19 ms
Найдено повторов (1): 9
set: 58 ms
Найдено повторов (2): 9

```

Скорость увеличилась многократно, и теперь неупорядоченный контейнер заметно выигрывает у своего «коллеги»  `set`. Но увеличим размер ещё, пускай количество номеров станет равно миллиону.

----------

Попробуйте предугадать, насколько эффективно  `unordered_set`  сможет справиться с миллионом. Помните, что количество кодов региона — 122. Как много коллизий можно ожидать?

-   Коллизий не будет, каждый номер попадёт в отдельную корзинку.
    
-   В одну корзину попадут 8–9 номеров, эффективность снизится.
    
-   Коллизий будет около 50 в каждой корзинке, как в прошлый раз. Будем опять существенно проигрывать обычному  `set`.
    
-   Все номера попадут в одну корзинку. Скорее всего, мы не дождёмся завершения программы.
    

Имеем 122 кода региона и 1000 цифровых частей. Всего получится 122 000 различных хешей, которые могут определять различные корзины. При распределении миллиона номеров получится по восемь-девять объектов в каждой корзине.

----------

Запустим программу и проверим эффективность контейнеров:

```
unordered_set: 2055 ms
Найдено повторов (1): 3791
set: 2455 ms
Найдено повторов (2): 3791

```

Неупорядоченный контейнер по-прежнему выигрывает, но уже не так сильно, как хотелось бы. Теперь представьте, что контейнер обрабатывает данные с камеры, установленной в Санкт-Петербурге. Подавляющее количество автомобильных номеров будут иметь коды регионов 78, 98, 178. Количество коллизий тогда будет существенно больше, а контейнер — менее эффективным.

Хорошо, последняя попытка. Возьмём хешер, который вы реализовали в прошлом уроке. Он использует строковое представление номера, а значит, учитывает все его данные. Ваша реализация могла выглядеть так:

```cpp
struct PlateHasherString {
    size_t operator()(const VehiclePlate& plate) const {
        return hasher(plate.ToString());
    }

    hash<string> hasher;
};

...

unordered_set<VehiclePlate, PlateHasherString> container;

```

На этот раз эффективность должна быть на высоте. Проверим это:

```
unordered_set: 2651 ms
Найдено повторов (1): 3791
set: 2462 ms
Найдено повторов (2): 3791

```

Однако нет, эффективность даже ухудшилась. Теперь контейнер проигрывает и  `set`.

----------

Как вы думаете, в чём причина?

-   Возникает много коллизий,  `unordered_set`  не может работать эффективно при таких условиях.
    
-   Хеш-функция вычисляется медленно, а в обычном  `set`  ничего не нужно вычислять.
    
-   С  `unordered_set`  всё в порядке, просто попался хороший случай для  `set`, и он работает очень быстро.
    
-   Всё правильно — оценка худшего случая для  `unordered_set`  хуже, а в предыдущих уроках говорилось, что нужно обращать внимание на худший случай.
    

Хеш-функция учитывает все данные, а значит, коллизий будет минимальное количество. На этот раз причина в другом: мы выбрали медленную хеш-функцию и теперь вынуждены использовать промежуточный поток, а также операции со  `string`  при каждом добавлении и поиске номера.  `set`  не требует вычисления строкового представления номера и работает быстрее.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

----------

Как вы думаете, почему так происходит?

-   **(+)**  Возникает много коллизий,  `unordered_set`  не может работать эффективно при таких условиях.
    
-   **(-)**  Хеш-функция вычисляется медленно, а в обычном  `set`  ничего не нужно вычислять.
    

> Она просто возвращает число. Это очень быстро!

-   **(-)**  С  `unordered_set`  всё в порядке, просто попался хороший случай для  `set`  и он работает быстро.

> `set`  всегда работает примерно одинаково.

-   **(-)**  Всё правильно — оценка худшего случая для  `unordered_set`  хуже, а в предыдущих уроках говорилось, что нужно обращать внимание на худший случай.

> Да, этот случай явно не лучший для  `unordered_set`. Но что-то в коде не так, иначе бы такого не произошло.

----------

Сможете ли вы оценить примерное количество коллизий? Сколько номеров попадает в одну корзинку?

-   **(-)**  В каждой корзинке ровно один номер.

> Это был бы идеальный случай, тогда бы  `unordered_set`  просто летал!

-   **(+)**  Не много, но и не мало — примерно 50 номеров в каждой корзинке.
    
-   **(-)**  Очень много, примерно по 5 000 номеров в каждой корзинке!
    

> Получается только десять корзинок? Маловато будет.

-   **(-)**  Все номера попали в одну корзинку.

> Такое могло быть возможно, если хеш-функция возвращала бы всегда одно и то же число. Но время работы  `unordered_set`  тогда было бы ещё хуже.

----------

Попробуйте предугадать, насколько эффективно  `unordered_set`  сможет справиться с миллионом. Помните, что количество кодов региона — 122. Как много коллизий можно ожидать?

-   **(-)**  Коллизий не будет, каждый номер попадёт в отдельную корзинку.

> Такого нельзя утверждать практически никогда. Даже если все хеши разные, контейнер иногда складывает объекты в одну корзину.

-   **(+)**  В одну корзину попадут 8–9 номеров, эффективность снизится.
    
-   **(-)**  Коллизий будет около 50 в каждой корзинке, как в прошлый раз. Будем опять существенно проигрывать обычному  `set`.
    

> На этот раз поменьше.

-   **(-)**  Все номера попадут в одну корзинку. Скорее всего, мы не дождёмся завершения программы.

> Это было бы грустно, но, к счастью, коллизий значительно меньше.

----------

Как вы думаете, в чём причина?

-   **(-)**  Возникает много коллизий,  `unordered_set`  не может работать эффективно при таких условиях.

> Такой была причина во всех предыдущих примерах, но не в этот раз!

-   **(+)**  Хеш-функция вычисляется медленно, а в обычном  `set`  ничего не нужно вычислять.
    
-   **(-)**  С  `unordered_set`  всё в порядке, просто попался хороший случай для  `set`, и он работает очень быстро.
    

> Проблема именно в  `unordered_set`: мы увидели, что его скорость ухудшилась.

-   **(-)**  Всё правильно — оценка худшего случая для  `unordered_set`  хуже, а в предыдущих уроках говорилось, что нужно обращать внимание на худший случай.

> Мы уже видели, как  `unordered_set`  выигрывает у  `set`, значит, контейнер не так уж и плох.

</details>

<details>
<summary>Задание:</summary>

## Задание

Бенчмарк из этого урока попал на стол генеральному директору «‎Ассоциария», и он пришёл в ярость, увидев, что в коде автостоянки используется неэффективная хеш-функция. Создайте новый хешер  `struct PlateHasherAll`, который:

-   будет быстро вычислять хеш-функцию, не прибегая к строковым и потоковым операциям,
-   будет учитывать все данные автомобильного номера,
-   не будет выдавать одинаковые хеши для разных номеров.

### Ограничения

Исправьте только хешер  `PlateHasherAll`. Не меняйте другие классы и функции программы, которые есть в заготовке кода.

### Что отправлять на проверку

Код заготовки с исправленным хешером  `PlateHasherAll`.

### Пример

Пример для тестирования дан в заготовке. Если всё сделано правильно, эффективность увеличится.

### Подсказка

-   Учитывайте, что к буквам  `char`  можно применять числовые операции. Вычтя из неё  `'A'`, получите двузначное число.
-   Используйте принцип, который применялся для того, чтобы учесть цифровую часть и регион. Его можно обобщить на несколько чисел, если суммарное количество цифр не превышает 19 — столько может вместить  `int64_t`.
-   Вам, скорее всего, понадобится 64-битная арифметика, используйте тип  `uint64_t`. Также вы можете использовать суффикс  `ULL`  для чисел:  `10'000'000'000ULL`.

</details>
