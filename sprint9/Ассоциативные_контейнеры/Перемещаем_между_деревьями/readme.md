<details>
<summary>Теория + тестирование:</summary>

# Перемещаем между деревьями

Садоводы владеют техникой прививки деревьев: при этом ветка берётся с одного дерева и перемещается на другое. Оказывается, нечто подобное можно проделать и с деревьями, на которых строятся ассоциативные контейнеры. В этом уроке мы покажем, как и для чего это делается.

Предположим, мы составили базу номеров автомобилей.  `map`  хранит номер автомобиля, а в качестве ключа использует имя владельца:

```cpp
#include <map>
#include <string>

using namespace std;

...
// класс VehiclePlate из прошлых уроков

class PlateBase {
public:
    PlateBase(map<string, VehiclePlate> plates)
        : plates_(move(plates)) {
    }

    void Print() const {
        for (const auto& [name, plate] : plates_) {
            cout << name << " на машине "s << plate << endl;
        }
    }

private:
    map<string, VehiclePlate> plates_;
};

int main() {
    PlateBase plate_base(map<string, VehiclePlate>{
        {"Кощей Бессмертный"s, {'K', 'K', 123, 'K', 97}},
        {"Илья Муромец"s, {'M', 'Y', 512, 'P', 97}},
        {"Иван Дурак"s, {'B', 'A', 315, 'H', 97}},
        {"Василиса Премудрая"s, {'B', 'A', 534, 'C', 97}},
        {"Иван Купала"s, {'A', 'A', 333, 'A', 97}},
        {"Змей Горыныч"s, {'A', 'M', 777, 'P', 97}},
    });

    plate_base.Print();
}

```

Получим такой вывод:

```cpp
Василиса Премудрая на машине BA534C97
Змей Горыныч на машине AM777P97
Иван Дурак на машине BA315H97
Иван Купала на машине AA333A97
Илья Муромец на машине MY512P97
Кощей Бессмертный на машине KK123K97

```

В  `map`  текстовые ключи упорядочены по алфавиту. Дерево поиска могло бы выглядеть так:

________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

Теперь представим, что хотим менять данные. Если кто-нибудь поменял автомобиль, проблем нет, подойдёт такой метод:

```cpp
class PlateBase {
public:
    ...
    // если имя не найдено, метод ничего не делает и возвращает false
    bool ChangeCar(const string& existing_name, VehiclePlate plate) {
        // чтобы не выполнять один и тот же поиск по дереву дважды -
        // один раз в count, второй раз в operator [],
        // воспользуемся итератором:
        auto iter = plates_.find(existing_name);
        if (iter == plates_.end()) {
            return false;
        }

        // изменяем второй элемент пары (ключ, значение)
        iter->second = move(plate);
        return true;
    }
    ...
};

int main() {
    PlateBase plate_base(map<string, VehiclePlate>{
        {"Кощей Бессмертный"s, {'K', 'K', 123, 'K', 97}},
        {"Илья Муромец"s, {'M', 'Y', 512, 'P', 97}},
        {"Иван Дурак"s, {'B', 'A', 315, 'H', 97}},
        {"Василиса Премудрая"s, {'B', 'A', 534, 'C', 97}},
        {"Иван Купала"s, {'A', 'A', 333, 'A', 97}},
        {"Змей Горыныч"s, {'A', 'M', 777, 'P', 97}},
    });

    plate_base.ChangeCar("Змей Горыныч"s, {'A', 'M', 888, 'P', 97});
    plate_base.Print();
}

```

Проверяем результат:

```cpp
Василиса Премудрая на машине BA534C97
Змей Горыныч на машине AM888P97
Иван Дурак на машине BA315H97
Иван Купала на машине AA333A97
Илья Муромец на машине MY512P97
Кощей Бессмертный на машине KK123K97

```

Всё прошло успешно. Теперь представим, что Иван Дурак повстречался с Царевной Лягушкой и стал Иваном Царевичем. Сделаем метод и для этого:

```cpp
class PlateBase {
public:
    ...
    // если имя не найдено, метод ничего не делает и возвращает false
    bool ChangeName(const string& existing_name, string new_name) {
        // начало аналогичное
        auto iter = plates_.find(existing_name);
        if (iter == plates_.end()) {
            return false;
        }

        // изменяем первый элемент пары (ключ, значение)
        iter->first = move(new_name);
        return true;
    }
    ...
};

int main() {
    PlateBase plate_base(map<string, VehiclePlate>{
        {"Кощей Бессмертный"s, {'K', 'K', 123, 'K', 97}},
        {"Илья Муромец"s, {'M', 'Y', 512, 'P', 97}},
        {"Иван Дурак"s, {'B', 'A', 315, 'H', 97}},
        {"Василиса Премудрая"s, {'B', 'A', 534, 'C', 97}},
        {"Иван Купала"s, {'A', 'A', 333, 'A', 97}},
        {"Змей Горыныч"s, {'A', 'M', 777, 'P', 97}},
    });

    plate_base.ChangeName("Иван Дурак"s, "Иван Царевич"s);
    plate_base.Print();
}

```

Компилируем и запускаем:

```
ivan.cpp: In member function 'bool PlateBase::ChangeName(const string&, std::__cxx11::string)':
ivan.cpp:102:41: error: no match for 'operator=' (operand types are 'const std::__cxx11::basic_string<char>' and 'std::remove_reference<std::__cxx11::basic_string<char>&>::type' {aka 'std::__cxx11::basic_string<char>'})
         iter->first = std::move(new_name);

```

Что-то пошло не так, запуск не удался. Ошибка в том, что мы пытаемся изменить ключ.  `map`  не даёт этого сделать.

----------

Как вы думаете, почему не получилось изменить ключ в  `map`?

-   Нужно убрать  `move`, и тогда всё заработает.
    
-   Это может нарушить свойства дерева поиска.
    
-   Ключи не должны меняться по логике ассоциативного контейнера, поэтому их изменение запретили.
    
-   Этот метод просто не реализовали.
    

У контейнера есть на то причины, ведь если вы будете менять ключи, легко можете нарушить свойство дерева поиска, и  `map`  перестанет работать корректно:

________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

_Выделенные узлы нарушают свойство дерева поиска_

Это же касается и контейнера  `set`. Выйти из положения можно, удалив старый элемент и вставив обратно с обновлённым именем:

```cpp
auto value_holder = std::move(iter->second);
plates_.erase(iter);
plates_.insert({std::move(new_name), std::move(value_holder)});

```

----------

В чём основной недостаток этого решения?

-   Оно будет неэффективно, если значения  `map`  — объекты с тяжёлым перемещением или без него.
    
-   Удаление и вставка могут потребовать перебалансировки дерева.
    
-   Слишком много  `std::move`, лучше без них.
    
-   У него нет недостатков.
    

Значение пришлось переместить два раза. Для объектов, для которых эта операция не реализована эффективно, такое изменение ключа будет весьма накладно. Кажется, что это лишние расходы, ведь изменение ключа вообще не должно затрагивать значение. К счастью, для таких случаев предусмотрен метод  `extract`, который позволяет вынуть узел из дерева. Извлечённый узел можно свободно поменять, а затем вернуть:

```cpp
auto node = plates_.extract(iter);
node.key() = std::move(new_name);
plates_.insert(std::move(node));

```

При такой операции никогда не происходит ни копирований, ни перемещений ключей и значений. Поменяем метод  `ChangeName`  и протестируем его:

```cpp
class PlateBase {
public:
    ...
    // если имя не найдено, метод ничего не делает и возвращает false
    bool ChangeName(const string& existing_name, string new_name) {
        // начало аналогичное
        auto iter = plates_.find(existing_name);
        if (iter == plates_.end()) {
            return false;
        }

        // изменяем ключ
        auto node = plates_.extract(iter);
        node.key() = move(new_name);
        plates_.insert(move(node));

        return true;
    }
    ...
};

```

В этот раз программа компилируется. Запускаем:

```cpp
Василиса Премудрая на машине BA534C97
Змей Горыныч на машине AM777P97
Иван Купала на машине AA333A97
Иван Царевич на машине BA315H97
Илья Муромец на машине MY512P97
Кощей Бессмертный на машине KK123K97

```

В дереве Иван окажется на новом месте, слегка перестроив узлы вокруг. Это может выглядеть так:

________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

Так можно извлекать узлы из дерева, задающего контейнер  `map`. Разберём, что с неупорядоченными контейнерами.

----------

Вспомните устройство  `unordered_set`  и  `unoredered_map`  и подумайте: нужен ли этим контейнерам метод  `extract`?

-   Они не задаются деревьями, так что ключи можно беспрепятственно менять, такого метода нет.
    
-   Ключи можно менять, но метод всё равно есть для других целей, например, перемещения элемента в другой контейнер.
    
-   Ключи также нельзя менять, так что метод нужен для тех же целей.
    

У неупорядоченных контейнеров, как и у обычного  `map`, ключи менять запрещено, ведь изменение ключа влечёт изменение хеша, и элемент окажется не в своей тарелке, то есть корзинке. Метод  `extract`  им необходим, и работает он для этих контейнеров точно так же.

----------

Извлечённый узел можно вставить в другой контейнер такого же типа — подобно садоводу перенести ветку из одного дерева к другому. Представим, что после слияния двух сказочных предприятий понадобилось объединить базы данных автомобилей сотрудников в один объект. Реализуем для этого метод  `Merge`:

```cpp
class PlateBase {
public:
    ...
    // метод извлекает узлы из другой базы данных,
    // поэтому принимает её по rvalue-ссылке
    void Merge(PlateBase&& other) {
        // извлекаем узлы пока они есть
        while (!other.plates_.empty()) {
            auto node = other.plates_.extract(other.plates_.begin());
            plates_.insert(move(node));
        }
    }

private:
    map<string, VehiclePlate> plates_;
};

int main() {
    PlateBase plate_base_1(map<string, VehiclePlate>{
        {"Кощей Бессмертный"s, {'K', 'K', 123, 'K', 97}},
        {"Илья Муромец"s, {'M', 'Y', 512, 'P', 97}},
        {"Иван Царевич"s, {'B', 'A', 315, 'H', 97}},
        {"Василиса Премудрая"s, {'B', 'A', 534, 'C', 97}},
        {"Иван Купала"s, {'A', 'A', 333, 'A', 97}},
        {"Змей Горыныч"s, {'A', 'M', 777, 'P', 97}},
    });

    PlateBase plate_base_2(map<string, VehiclePlate>{
        {"Колобок"s, {'K', 'K', 321, 'K', 97}},
        {"Добрыня Никитич"s, {'H', 'Y', 422, 'K', 97}},
        {"Емеля"s, {'X', 'O', 11, 'T', 97}},
    });

    plate_base_1.Merge(move(plate_base_2));

    plate_base_1.Print();
}

```

Проверяем результат:

```cpp
Василиса Премудрая на машине BA534C97
Добрыня Никитич на машине HY422K97
Емеля на машине XO011T97
Змей Горыныч на машине AM777P97
Иван Купала на машине AA333A97
Иван Царевич на машине BA315H97
Илья Муромец на машине MY512P97
Колобок на машине KK321K97
Кощей Бессмертный на машине KK123K97

```

Результат правильный. Того же эффекта можно добиться проще и, возможно, эффективнее, если использовать метод  `merge`, уже подготовленный для вас разработчиками стандартной библиотеки:

```cpp
void Merge(PlateBase&& other) {
    plates_.merge(std::move(other.plates_));
}

```

На рисунке слияние могло бы выглядеть так:

________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

Кажется, теперь вы узнали всё об упорядоченных и неупорядоченных контейнерах. В следующем уроке вас ждёт небольшой тест. Затем — финальное задание этой темы.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Как вы думаете, почему не получилось изменить ключ в  `map`?

-   **(-)**  Нужно убрать  `move`, и тогда всё заработает.
    
-   **(+)**  Это может нарушить свойства дерева поиска.
    
-   **(-)**  Ключи не должны меняться по логике ассоциативного контейнера, поэтому их изменение запретили.
    
-   **(-)**  Этот метод просто не реализовали.
    

----------

В чём основной недостаток этого решения?

-   **(+)**  Оно будет неэффективно, если значения  `map`  — объекты с тяжёлым перемещением или без него.
    
-   **(-)**  Удаление и вставка могут потребовать перебалансировки дерева.
    

> Это так, но перебалансировки тут не избежать. Элемент с новым ключом обязан находиться в новом месте дерева.

-   **(-)**  Слишком много  `std::move`, лучше без них.

> Лучше использовать  `std::move`  там, где возможно. Это не недостаток.

-   **(-)**  У него нет недостатков.

----------

Вспомните устройство  `unordered_set`  и  `unoredered_map`  и подумайте: нужен ли этим контейнерам метод  `extract`?

-   **(-)**  Они не задаются деревьями, так что ключи можно беспрепятственно менять, такого метода нет.
    
-   **(-)**  Ключи можно менять, но метод всё равно есть для других целей, например, перемещения элемента в другой контейнер.
    
-   **(+)**  Ключи также нельзя менять, так что метод нужен для тех же целей.

</details>
