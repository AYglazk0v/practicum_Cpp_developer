<details>
<summary>Теория:</summary>

# Деревья и поиск

В прошлых уроках мы подробно рассказали об устройстве  `unordered_map`  и  `unordered_set`. Вы увидели: производительность этих контейнеров сильно зависит от хеш-функции, которая в них используется. Вы даже сами написали подобный контейнер. В этом уроке рассмотрим устройство знакомых ещё со вводного курса  `map`  и  `set`.

В основе  `map`  лежит  **двоичное сбалансированное дерево поиска**  — специальная структура, обеспечивающая быстрый поиск нужного ключа среди множества элементов. Разберём каждое слово этого определения.

**Дерево**. Это структура, похожая на знакомый вам список. Как и список, она имеет узлы, которые хранят значение и ссылаются на последующие. Отличие в том, что количество последующих элементов не ограничивается одним. Узлы списка можно расположить в линию, а эта структура принимает разветвлённую форму, напоминающую крону дерева. Первый элемент называется  **корень**  дерева.

**Двоичное**. Двоичность означает, что у каждого узла может быть не более двух последующих. Если их нет совсем, узел называется  **листом**. Если последующих узлов два, все потомки одного из них можно назвать  **левым поддеревом**, а все потомки другого —  **правым поддеревом**. Если последующий один, он может начинать левое или правое поддерево.

**Поиска**. Некоторые деревья учитывают содержимое элементов, помогая искать в дереве нужную позицию. В двоичном дереве поиска левое поддерево узла, содержащего некоторый элемент, хранит в узлах меньшие значения, а правое — большие. Например, если в первом узле дерева, содержащего элементы 1, 2, 3, 4, 5, 6, хранится число 4, то в левом поддереве будут элементы 1, 2, 3, а в правом — 5, 6.

**Сбалансированное**. Иногда в двоичном дереве левое поддерево бывает намного меньше правого, и дерево становится как бы перекошенным. Это усложняет поиск и вредит производительности. Такое дерево называется  **несбалансированным**. В сбалансированном дереве все пути от корня до листа имеют примерно равную длину. Например, различаются не более, чем на один, или не более, чем в два раза. В  **идеально сбалансированном**  дереве все такие пути имеют равную длину.

![1.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint9/%D0%90%D1%81%D1%81%D0%BE%D1%86%D0%B8%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F_%D0%B8_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/img/1.png?raw=true)

_Идеально сбалансированное двоичное дерево поиска. Сиреневым выделен корень, зелёным — листья. Обратите внимание, что примерно половина всех узлов — листья_

Рассмотрим другой пример дерева, содержащего числа от 1 до 9:

![2.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint9/%D0%90%D1%81%D1%81%D0%BE%D1%86%D0%B8%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F_%D0%B8_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/img/2.png?raw=true)

_Двоичное дерево поиска с числами от 1 до 9_

Оно уже не так хорошо сбалансировано, как предыдущее. Посмотрим, как искать в таком дереве. Предположим, требуется найти число четыре. Алгоритм мог действовать так:

1.  Сравниваем четыре с корнем. Там записано число шесть. Так как оно больше искомого, идём в левое поддерево.
2.  Приходим в число три. Оно меньше, чем искомое, поэтому переходим вправо.
3.  Прочитанное число пять больше, чем нужно. Идём влево, где и находим ответ.

Просмотренные при этой операции узлы выделены на схеме:

![3.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint9/%D0%90%D1%81%D1%81%D0%BE%D1%86%D0%B8%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F_%D0%B8_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/img/3.png?raw=true)

_Обход узлов при поиске числа 4_

С каждым шагом переходим на следующий горизонтальный уровень дерева. Теперь понятно появление логарифма в формуле сложности поиска по  `map`. В идеально сбалансированном дереве на каждом следующем уровне в два раза больше элементов, чем на предыдущем. Делая один шаг, удваиваем количество элементов, к которым могли бы прийти. В уроке о логарифмах вы видели: логарифмическая сложность возникает, когда за один шаг алгоритма можно изменить количество рассмотренных случаев в определённое количество раз. В этом примере в два раза. Через логарифм можно выразить высоту сбалансированного дерева, то есть максимальную длину пути от корня до листа: если количество элементов в дереве N, его высота — O(\log N).

----------

В дереве, изображённом на схеме, в узлах вместо букв стоят неизвестные числа. Свойство дерева поиска при этом выполнено.

![4.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint9/%D0%90%D1%81%D1%81%D0%BE%D1%86%D0%B8%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F_%D0%B8_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/img/4.png?raw=true)


_Двоичное дерево поиска. Буквами обозначены некоторые числовые значения_

-   Какой узел является корнем?
    
-   В каком узле находится минимальное число дерева?
    
-   В каком узле находится максимальное число дерева?
    

Алгоритм добавления в дерево похож на поиск. Отличие в том, что он ищет не существующий узел в дереве, а место, куда его можно добавить. Алгоритм поиска может остановиться на верхних уровнях, а при добавлении мы всегда будем доходить до листа. Для примера добавим в приведённое дерево дробное число 7,5. Поиск места для него будет таким:

![5.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint9/%D0%90%D1%81%D1%81%D0%BE%D1%86%D0%B8%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F_%D0%B8_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/img/5.png?raw=true)

_Вставка числа 7,5 в дерево поиска. Зелёным цветом обозначены узлы, которые надо пройти, чтобы найти место для вставки_

1.  Сравниваем 7,5 с корнем. Идём вправо, так как корень оказался меньше.
2.  Попав в восемь, идём влево.
3.  Приходим в элемент семь. Правого поддерева у него нет, поэтому можно вставить узел 7,5 справа от узла семь. Правильный вариант один. Он выглядит так:

![6.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint9/%D0%90%D1%81%D1%81%D0%BE%D1%86%D0%B8%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F_%D0%B8_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/img/6.png?raw=true)

Посмотрите на эти деревья:

![7.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint9/%D0%90%D1%81%D1%81%D0%BE%D1%86%D0%B8%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F_%D0%B8_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/img/7.png?raw=true)



Все эти конфигурации могут возникнуть из пустого дерева после добавления пяти элементов в разном порядке. Мы ограничили их количество условием: не допускается наличие правого поддерева при отсутствии левого. Некоторые из этих конфигураций более сбалансированы, а некоторые менее. Чтобы дерево всегда оставалось сбалансированным, нужно иногда перестраивать его при добавлении нового элемента.

В контейнерах  `map`  и  `set`  используются деревья поиска. В  `set`  узел хранит значения, в  `map`  пары ключ-значение. Чтобы понятие дерева поиска имело смысл, контейнер должен определять, какой элемент больше, а какой меньше. Это делает компаратор, который, как и хеш-функция, задаётся шаблонным параметром. По умолчанию используется компаратор  `less`, который требует, чтобы ключи контейнера можно было сравнивать операцией  `<`. Эту операцию достаточно определить для использования типа в  `set`  или в качестве ключа в  `map`.

Таким образом, деревья — это не только лёгкие нашей планеты, но и полезная структура данных. Решите задачу о деревьях, чтобы получше разобраться в них.

</details>


<details>
<summary>Задание:</summary>

## Задание

Решение этого задания пригодится вам в дальнейшем. Сохраните его.

Директор «‎Ассоциария»‎ любит порядок. Скоро Новый год, и директор поручил сотрудникам нарядить ёлку его любимыми игрушками. Директор любит свои игрушки и периодически подходит к ёлке удостовериться, что сотрудники ни одну из них не разбили. Чтобы игрушки проще было искать, он ввёл порядок — пронумеровал игрушки — и распорядился организовать ёлку в виде двоичного дерева поиска.

Чтобы убедиться, что сотрудники справились со своей задачей, реализуйте функцию  `template <typename T> bool CheckTreeProperty(const TreeNode<T>* node)`  для проверки свойства дерева поиска: элементы в левом поддереве должны быть меньше значения в узле, а элементы правого — больше.

Узел дерева задаётся такой структурой:

```cpp
template <typename T>
struct TreeNode {
    T value;
    TreeNode* left;
    TreeNode* right;
};

```

Указатели на отсутствующие поддеревья равны  `nullptr`.

### Ограничения

Пройдите по дереву не более одного раза. Допускается рекурсивная реализация.

### Пример

Пример — в заготовке кода. В нём используются такие деревья:

![8.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint9/%D0%90%D1%81%D1%81%D0%BE%D1%86%D0%B8%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F_%D0%B8_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA/img/8.png?raw=true)

### Как будет тестироваться ваш код

-   Проверим, что программа правильно решает задачу.
-   Проверим, что программа эффективно решает задачу.

### Подсказка

-   Вам пригодится вспомогательная функция, проверяющая, что все элементы дерева находятся в некотором интервале  `[min, max]`, причём  `min`  и  `max`  могут быть не определены.
    
-   Значения  `min`  и  `max`  можно представить в виде  `optional`  или в виде указателей, задающих верхнюю и нижнюю границы. Указатель может быть равен  `nullptr`, если граница не задана. В случае использования указателей функция проверки может быть рекурсивной и иметь такую сигнатуру:
    
    ```cpp
    /* 
    Возвращает true, если узел node и его дочерние элементы находятся в диапазоне [min, max]
    */
    template <typename T>
    bool CheckTreeProperty(const TreeNode<T>* node, const T* min, const T* max);
    
    ```
    
-   Функция проверки всего дерева с корневым узлом  `node`  сводится к одной строчке:
    
    ```cpp
    return CheckTreeProperty<T>(node, nullptr, nullptr);
    ```

</details>
