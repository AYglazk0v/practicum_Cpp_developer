<details>
<summary>Теория + тестирование:</summary>

# Галопом по map’ам и set’ам

Прекрасно, теперь вы знаете устройство всех контейнеров:  `vector`,  `list`,  `unordered_set`,  `unordered_map`,  `set`  и  `map`. Осталась одна маленькая деталь — итераторы. Вроде бы ничего сложного в жизни итератора быть не может: шагай себе и шагай. Но, как оказывается, и тут есть свои нюансы. Иногда они очень важны.

### Итераторы в  `map`  и  `set`

Контейнеры  `map`  и  `set`  имеют метод  `upper_bound`. Казалось бы, он не нужен, ведь есть алгоритм с таким же названием. Сравним метод и алгоритм между собой.

Создадим  `set`  со случайными числами и 5000 раз поищем позицию какого-нибудь элемента:

```cpp
#include "log_duration.h"

#include <algorithm>
#include <cstdlib>
#include <random>
#include <set>

using namespace std;

int main() {
    static const int NUMBERS = 100'000;
    static const int MAX_NUM = 1'000'000'000;
    static const int NUM_TO_FIND = 500'000'000;
    static const int SEARCHES = 5'000;

    mt19937 generator;
    // Генератор псевдослучайных числел типа int, равномерно
    // распределённых на отрезке [0, MAX_NUM]
    uniform_int_distribution<int> uniform_dist(0, MAX_NUM);

    set<int> nums;
    for (int i = 0; i < NUMBERS; ++i) {
        int random_number = uniform_dist(generator);
        nums.insert(random_number);
    }

    int result_number;
    {
        LOG_DURATION("std::set::upper_bound"s);
        for (int i = 0; i < SEARCHES; ++i) {
            auto iter = nums.upper_bound(NUM_TO_FIND);
            result_number = *iter;
        }
    }
    cout << result_number << endl;

    {
        LOG_DURATION("std::upper_bound"s);
        for (int i = 0; i < SEARCHES; ++i) {
            auto iter = upper_bound(nums.begin(), nums.end(), NUM_TO_FIND);
            result_number = *iter;
        }
    }
    cout << result_number << endl;
}

```

Смотрим результат:

```cpp
std::set::upper_bound: 0 ms
500001207
std::upper_bound: 83741 ms
500001207

```

Разница колоссальная — время метода настолько мало, что его даже не получилось измерить, в то время как алгоритм работал почти полторы минуты. Разгадку легко не заметить сразу: на  [странице алгоритма](https://en.cppreference.com/w/cpp/algorithm/upper_bound)  написано, что его сложность логарифмическая, как и у метода  `set`. Всё объясняет приписка: если переданные итераторы не удовлетворяют концепции LegacyRandomAccessIterators, алгоритм будет совершать линейное, а не логарифмическое количество увеличений итератора. В этом и проблема, потому что линейная сложность гораздо хуже логарифмической.

Концепция LegacyRandomAccessIterators объединяет итераторы произвольного доступа, то есть такие, которым можно прибавить число, и операция прибавления будет очень быстрой — константной. Теперь вы знаете устройство  `set`  и можете понять, почему встать на N-й элемент для него не такая простая операция.

Разберём, как работает итератор в  `set`  и как выглядит его шаг.

________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________


_Путь итератора в дереве поиска от узла 1 до узла 7_

На рисунке — дерево из прошлого урока. Зелёными изогнутыми стрелками изображён нелёгкий путь итератора, начавшего в узле 1 и дошедшего до 7. Как видно, шаг итератора не так прост. Например, чтобы попасть из узла 6 в 7, ему нужно пройти сразу по трём связям.

----------

Сколько связей в приведённом выше дереве пройдёт итератор от первого (1) до последнего (9) элемента? Под связями понимаются сплошные линии, соединяющие узлы на рисунке.

-   6
    
-   9
    
-   10
    
-   13
    
-   18
    
-   21
    

----------

Чтобы пройти от узла 1 до узла 9, итератор должен пройти 13 связей: (1→2), (2→3), (3→5), (5→4), (4→5), (5→3), (3→6), (6→8), (8→7,5), (7,5→7), (7→7,5), (7,5→8), (8→9).

________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

_Unordered-контейнер, в котором шесть элементов распределены по шести корзинкам. Корзинки заполнены неравномерно, так как номер корзинки выбирается на основе хеш-функции ключа_

Тогда итератор может переходить вперёд: либо к следующему элементу по связи, либо в следующую непустую корзинку. Перемещение тут более простое, чем в  `set`, но ход назад запрещён. Значит, итераторы в  `unordered_map`  и  `unordered_set`  ещё более слабые, чем в  `map`  и  `set`: они не поддерживают не только произвольный доступ, но и перемещение назад. Они однонаправленные, то есть умеют одну вещь: шагать вперёд. А итераторы  `map`  и  `set`  — двунаправленные, а значит, умеют шагать в двух направлениях.

----------

Как будет работать алгоритм  `upper_bound`  с  `unordered_set`?

-   Быстро, потому что контейнер не имеет собственного метода  `upper_bound`, значит, нужно использовать алгоритм.
    
-   Медленно, потому что итератор в  `unordered_set`  не имеет произвольного доступа, как и итератор  `map`.
    
-   Он вообще не будет работать, поскольку его можно применять только для отсортированного контейнера.
    

Этот алгоритм для  `unordered_set`  неприменим вовсе, как и  `lower_bound`  и  `binary_search`. Если всё же нужно использовать бинарный поиск для элементов неупорядоченного контейнера, лучше поступить так, как в одном из первых уроков темы: переложить элементы в  `vector`  и затем отсортировать.

----------

### Инвалидация итераторов

С итераторами вы сталкиваетесь почти в каждой теме и уже довольно неплохо умеете с ними обращаться. Итераторы чаще всего используются для алгоритмов: получили через  `begin`  или  `end`, вычислили, забыли. Но иногда возникает соблазн сохранить итератор, чтобы применить его в будущем. Как вы знаете, делать это нужно с осторожностью для  `vector`: после добавления в него, сохранённые ранее итераторы могут стать некорректными. Подобная неприятность поджидает и с  `unordered_map`  и  `unordered_set`: нельзя использовать итератор, если он был сохранён до добавления нового элемента в контейнер. Однако в отличие от  `vector`, в  `unordered_map`  и  `unordered_set`  можно использовать ссылки или указатели на элементы даже после добавления. Такой же принцип работает и в  `deque`.

В этом отношении обычные  `map`  и  `set`  удобнее: итераторы гарантированно остаются корректными после любых добавлений. Удаление не портит итераторы ни в каком случае — ни для упорядоченных контейнеров, ни для неупорядоченных. За исключением того самого элемента, который удалили.

### Итераторы в  `unordered_map`  и  `unordered_set`

Итераторы в  `unordered_map`  и  `unordered_set`  не поддерживают не только произвольный доступ, но и перемещение назад. Впрочем, это не так страшно. Если у  `set`  операция перемещения итератора на N шагов может иметь смысл для доступа к N-му по величине элементу, то у  `unordered_set`, для которого порядок не определён, подобное не имеет смысла.

Элементы в  `unordered_map`  и  `unordered_set`  хранятся в корзинках. В хорошем случае в каждой корзинке только один элемент, тогда итератору ничего не стоит перейти к следующей или предыдущей корзинке. Но в реальности неизбежны коллизии, и в одной корзинке скапливается несколько элементов. Хранение значений в корзинках может быть реализовано внутри библиотеки по-разному, например, в виде односвязного списка.
</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Сколько связей в приведённом выше дереве пройдёт итератор от первого (1) до последнего (9) элемента? Под связями понимаются сплошные линии, соединяющие узлы на рисунке.

-   **(-)**  6
    
-   **(-)**  9
    
-   **(-)**  10
    
-   **(+)**  13
    
-   **(-)**  18
    
-   **(-)**  21
    

----------

Как будет работать алгоритм  `upper_bound`  с  `unordered_set`?

-   **(-)**  Быстро, потому что контейнер не имеет собственного метода  `upper_bound`, значит, нужно использовать алгоритм.
    
-   **(-)**  Медленно, потому что итератор в  `unordered_set`  не имеет произвольного доступа, как и итератор  `map`.
    
-   **(+)**  Он вообще не будет работать, поскольку его можно применять только для отсортированного контейнера.

</details>

<details>
<summary>Задание:</summary>

## Задание

Реализуйте операцию передвижения вперёд для итератора в дереве поиска.

Теперь узел дерева содержит указатель на родительский элемент, то есть элемент над ним:

```cpp
template <typename T>
struct TreeNode {
    T value;
    TreeNode* parent = nullptr;
    TreeNode* left = nullptr;
    TreeNode* right = nullptr;
};

```

Реализуйте функцию  `template <typename T> TreeNode<T>* begin(TreeNode<T>* node)`  для поиска начального узла в дереве, а также функцию  `template <typename T> TreeNode<T>* next(TreeNode<T>* node)`  для поиска следующего по величине узла.

Если узел последний,  `next`  должна вернуть  `nullptr`.

### Ограничения

Реализация  `next`  должна быть эффективной и проходить ровно столько узлов дерева, сколько нужно пройти до требуемой позиции. Сложность функции  `next`  должна быть амортизированной O(1).

Содержимое узлов учитывать не нужно.

### Пример

В заготовке реализована функция  `N`  для создания дерева. В  `main`  создаётся дерево из примера к заданию к прошлому уроку:

```cpp
int main() {
    using T = TreeNode<int>;

    T* root = N(6, N(4, N(3), N(5)), N(8, N(7)));
    cout << root << endl;

    T* iter = begin(root);

    while (iter) {
        cout << iter->value << " "s;
        iter = next(iter);
    }
    cout << endl;

    DeleteTree(root);
}

```

Вывод должен быть следующий:

```cpp
( 6 ( 4 ( 3 )  ( 5 )  )  ( 8 ( 7 ) * )  )
3 4 5 6 7 8

```

### Как будет тестироваться ваш код

Проверим, что

-   `begin`  правильно находит начало дерева;
-   `next`  возвращает  `nullptr`  для последнего узла;
-   `next`  правильно проходит всё дерево;
-   `next`  работает эффективно и не делает лишних действий.

### Подсказка

-   Если у узла есть правое поддерево, ищите следующий в нём
-   Вам пригодится функция  `begin`  для поиска следующего в правом поддереве
-   Если справа ничего нет, идите в родителя. Родитель будет следующим, если вы пришли в него из левого поддерева. А если из правого, то отправляйтесь ещё выше

</details>
