<details>
<summary>Теория +  тестирование:</summary>

# Ускоряем, отказываясь от сортировки

В прошлом уроке мы проанализировали книгу английского писателя 14-го века и увидели, что он, как и современные авторы, чаще всего использовал местоимения, артикли и предлоги. Наша программа анализа имеет довольно неплохую алгоритмическую сложность — O(N\log N). Казалось, мы достигли теоретического пика производительности, улучшить сложность нельзя.

В этом уроке вы увидите, как значительно ускорить эту программу, изменив всего одну строчку. Как и при любой оптимизации, вначале нужно понять, какой из этапов программы занимает большее время. Для этого используем разработанный ранее макрос  `LOG_DURATION`:

```cpp
// файл wordstat.cpp

#include "log_duration.h"

#include <algorithm>
#include <iostream>
#include <iterator>
#include <map>
#include <string>
#include <tuple>
#include <vector>

using namespace std;

vector<pair<string, int>> GetSortedWordCounts(vector<string> words) {
    map<string, int> counts_map;

    {
        LOG_DURATION("Filling"s);

        for (auto& word : words) {
            ++counts_map[move(word)];
        }
    }

    {
        LOG_DURATION("Moving & sorting"s);

        vector<pair<string, int>> counts_vector(move_iterator(counts_map.begin()), move_iterator(counts_map.end()));
        sort(counts_vector.begin(), counts_vector.end(), [](const auto& l, const auto& r) {
            return l.second > r.second;
        });

        return counts_vector;
    }
}

int main() {
    vector<string> words;
    string word;

    while (cin >> word) {
        words.push_back(word);
    }

    auto counts_vector = GetSortedWordCounts(move(words));

    cout << "Слово - Количество упоминаний в тексте"s << endl;
    // выводим первые 10 слов
    for (auto [iter, i] = tuple(counts_vector.begin(), 0); i < 10 && iter != counts_vector.end(); ++i, ++iter) {
        cout << iter->first << " - "s << iter->second << endl;
    }
}

```

Подадим на вход книгу Чосера и посмотрим на результат:

```
Filling: 59 ms
Moving & sorting: 3 ms
Слово - Количество упоминаний в тексте
and - 8877
that - 5832
the - 5623
of - 5351
to - 4002
he - 3718
in - 3544
his - 3103
for - 3027
a - 3025

```

Первый этап работает медленнее в десятки раз несмотря на то, что имеет такую же асимптотическую сложность, как и второй.

----------

Как вы думаете, почему первый этап медленнее?

-   Его асимптотическая сложность на самом деле хуже, чем у второго.
    
-   Это хороший случай для второго этапа и плохой для первого.
    
-   Сложность первого этапа имеет значительно больший множитель при N\log N
    
-   Эти теоретические оценки — сплошной обман, никогда нельзя доверять им.
    

Множитель в первом этапе значительно больше, чем во втором. Этим объясняется медленная работа заполнения, несмотря на одинаковую теоретическую оценку асимптотической сложности. Такой эффект происходит за счёт сложного внутреннего устройства контейнера  `map`, которое будем разбирать ближе к концу этой темы. Благодаря тому, что асимптотическая сложность одинаковая, пропорция времени не будет меняться при увеличении количества входных данных.

----------

Чтобы улучшить производительность, нужно от чего-нибудь отказаться. Какое лишнее действие совершает функция  `GetSortedWordCounts`?

-   Сортирует слова по алфавиту на этапе заполнения.
    
-   Копирует строки. Можно использовать  `string_view`, чтобы их избежать.
    
-   Копирует  `counts_vector`  при возврате из функции.
    

Будем оптимизировать наиболее медленный первый этап. Как обещано, перепишем всего одну строку, вернее одну лексему: заменим  `map`  на  `unordered_map`. Придётся, правда, включить дополнительный заголовочный файл с таким же названием  `<unordered_map>`.

Программа с новым контейнером выдаст следующий результат:

```cpp
Filling: 15 ms
Moving & sorting: 2 ms
Слово - Количество упоминаний в тексте
and - 8877
that - 5832
the - 5623
of - 5351
to - 4002
he - 3718
in - 3544
his - 3103
for - 3027
a - 3025

```

Как видно, результат не изменился, а производительность значительно возросла!

Название контейнера  `unordered_map`  говорит о его особенности: отсутствии порядка. Снова распечатаем промежуточный результат — сразу после заполнения контейнера словами, но до сортировки. Для этого добавим дополнительный вывод в функцию  `GetSortedWordCounts`:

```cpp
vector<pair<string, int>> GetSortedWordCounts(vector<string> words) {
    unordered_map<string, int> counts_map;

    {
        LOG_DURATION("Filling"s);

        for (auto& word : words) {
            ++counts_map[move(word)];
        }
    }

    cout << "Содержимое counts_map:"s << endl;
    for (auto [iter, i] = tuple(counts_map.begin(), 0); i < 10 && iter != counts_map.end(); ++i, ++iter) {
        cout << iter->first << " - "s << iter->second << endl;
    }

    {
        LOG_DURATION("Moving & sorting"s);

        vector<pair<string, int>> counts_vector(move_iterator(counts_map.begin()), move_iterator(counts_map.end()));
        sort(counts_vector.begin(), counts_vector.end(), [](const auto& l, const auto& r) {
            return l.second > r.second;
        });

        return counts_vector;
    }
}

```

Теперь вывод выглядит так:

```
Filling: 16 ms
Содержимое counts_map:
y-pilt - 1
sitthen - 1
ropes - 1
sisours - 2
assise - 2
enquered - 1
iustices - 2
ferd - 1
cheeke-boon - 1
iustise - 3
Moving & sorting: 3 ms
...

```

Видно, что в первой части вывода слова идут вразнобой — это особенность  `unordered_map`. Но нас она нисколько не тревожит — порядок всё равно будет изменён впоследствии, так что для нашей задачи  `unordered_map`  работает идеально.

В этой теме вас ждет подробный рассказ о том, как устроены  `map`  и  `unordered_map`. Разберёмся, почему второй, в отличие от первого, не сортирует элементы, в каком случае нужно использовать  `map`, а когда подойдёт  `unordered_map`. В конце этого урока вы попробуете разработать свой контейнер, который будет настолько же производительным, как  `unordered_map`, а может, и лучше.

Считать слова хорошо, а считать деньги ещё приятнее. Поэтому напишем программу для кошелька. Она будет выполнять похожую задачу — считать количество купюр каждого номинала, но сделает это проще — не понадобится ни  `map`, ни  `unordered_map`. Эффективность алгоритма будет на высоте. Существуют купюры номиналом от 1 до 5000, поэтому хранить количества можно в векторе:

```cpp
#include <cassert>
#include <iostream>
#include <vector>

using namespace std;

class MoneyBox {
public:
    void PushCoin(int value) {
        assert(value >= 0 && value <= 5000);
        ++counts_[value];
    }

    void PrintCoins(ostream& out) const {
        for (int i = 0; i < counts_.size(); ++i) {
            if (counts_[i] > 0) {
                out << i << ": "s << counts_[i] << endl;
            }
        }
    }

private:
    // создаём вектор размера 5001 для того, чтобы последний
    // индекс соответствовал максимальному номиналу 5000
    vector<int> counts_ = vector<int>(5001);
};

ostream& operator<<(ostream& out, const MoneyBox& cash) {
    cash.PrintCoins(out);
    return out;
}

int main() {
    MoneyBox cash;

    int value;
    while (cin >> value) {
        cash.PushCoin(value);
    }

    cout << cash << endl;
}

```

Проверим программу на таком файле:

```
50 200 2000 500 50 500 2000 2000 100 10 50 50 50 200 50 200 
200 2000 200 500 5000 500 2000 50 500 2000 1000 500 2000 5000 
5000 2000 200 100 1000 10 200 200 200 2000 5000 200 100 1000 
50 10 1000 5000 1000 500 200 500 2000 1000 1000 200 200 1000 
50 100 500 200 2000 100 10 100 10 2000 10 10 2000 1000 100 
50 100 2000 2000 1000 50 500 1000 5000 500 100 500 10 2000 
10 200 500 10 5000 100 200 50 100 2000 100 50 1000

```

Результат

```
10: 10
50: 13
100: 12
200: 16
500: 13
1000: 12
2000: 17
5000: 7

```

----------

Как вы думаете, в чём главный недостаток такого кошелька?

-   Он работает неправильно.
    
-   Он работает недостаточно быстро.
    
-   Он потребляет слишком много памяти.
    
-   Программа слишком простая.
    

Нам повезло работать с номиналами до 5000. А если бы расчёт происходил в югославских динарах, памяти, возможно, не хватило бы!

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Как вы думаете, почему первый этап медленнее?

-   **(-)**  Его асимптотическая сложность на самом деле хуже, чем у второго.

> В прошлом уроке вы посчитали, что она одинаковая — N\log N.

-   **(-)**  Это хороший случай для второго этапа и плохой для первого.

> В таком алгоритме время будет слабо варьироваться от случая к случаю.

-   **(+)**  Сложность первого этапа имеет значительно больший множитель при N\log N
    
-   **(-)**  Эти теоретические оценки — сплошной обман, никогда нельзя доверять им.
    

> Просто теорию нужно использовать с умом.

----------

Чтобы улучшить производительность, нужно от чего-нибудь отказаться. Какое лишнее действие совершает функция  `GetSortedWordCounts`?

-   **(+)**  Сортирует слова по алфавиту на этапе заполнения.
    
-   **(-)**  Копирует строки. Можно использовать  `string_view`, чтобы их избежать.
    

> В  `GetSortedWordCounts`  мы только перемещаем строки. Перемещение  `string`  примерно такое же быстрое, как создание  `string_view`.

-   **(-)**  Копирует  `counts_vector`  при возврате из функции.

> При возврате объект не копируется. Кроме того,  `return`  находится во второй, более быстрой секции. А оптимизацию нужно начинать с самого медленного.

----------

Как вы думаете, в чём главный недостаток такого кошелька?

-   **(-)**  Он работает неправильно.

> Да нет, программа правильная.

-   **(-)**  Он работает недостаточно быстро.

> Очень быстро, поверьте.

-   **(+)**  Он потребляет слишком много памяти.
    
-   **(-)**  Программа слишком простая.
    

> Это не недостаток, а преимущество.

</details>

<details>
<summary>Задание:</summary>

## Задание

Теперь вам предстоит работать с купюрами, которые могут даже не влезть в  `int`. Улучшите класс  `MoneyBox`, сократив потребление памяти.

В этом задании вы реализуете очень быстрый контейнер. Считайте, что разных номиналов купюр немного, не более 20. В этом случае контейнер должен выполнять операции добавления и получения с замечательной сложностью — O(1). Программа будет понятной: не понадобятся ни  `map`, ни  `unordered_map`, то есть контейнеры, устройство которых мы пока что не проходили.

В заготовке есть класс  `MoneyBox`. Он хранит в векторе  `nominals_`  все доступные номиналы купюр. Реализуйте его методы:

-   `void PushCoin(int64_t value)`  — для добавления купюры или монеты в копилку,
-   `void PrintCoins(ostream& out) const`  — для печати всех доступных средств в поток. Формат вывода будет в примере ниже.

Метод  `PushCoin`  должен менять вектор  `counts_`  так, чтобы  `counts_[i]`  было количеством добавленных купюр с номиналом  `nominals_[i]`.

### Требования

В конструктор будет передан вектор возможных номиналов купюр в порядке возрастания. Гарантируется, что все они различны.

Реализуйте функцию добавления купюры в кошелёк, а также функцию печати номиналов.

Выведите в поток вывода количество купюр каждого номинала в том же порядке, в каком номиналы были переданы в конструктор  `MoneyBox`. Количество купюр, равное нулю, выводить не нужно.

Вектор  `counts_`  обязан хранить количество купюр каждого номинала в том же порядке, в котором эти номиналы перечислены в  `nominals_`.

### Ограничения

-   Не добавляйте в класс заготовки новые поля.
-   Не меняйте уже реализованные функции.
-   Считайте, что количество разных номиналов невелико — не более 20.

### Пример

```cpp
int main() {
    MoneyBox cash({1, 500, 10000});
    cash.PushCoin(500);
    cash.PushCoin(500);
    cash.PushCoin(10000);
    assert((cash.GetCounts() == vector<int>{0,2,1}));
    cout << cash << endl;
}

```

Вывод:

```
500: 2
10000: 1

```

### Как будет тестироваться ваш код

Проверим, что класс выполняет свою задачу и соответствует ограничениям.

### Подсказка

Напишите вспомогательный метод, который по номиналу купюры определит её индекс в векторе  `counts_`. Воспользуйтесь индексом, чтобы увеличить счётчик купюр этого номинала.

</details>
