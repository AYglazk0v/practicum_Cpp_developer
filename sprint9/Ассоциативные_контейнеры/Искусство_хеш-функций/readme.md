<details>
<summary>Теория + тестирование:</summary>

# Искусство хеш-функций

Как вы увидели в прошлом уроке, неупорядоченный контейнер сильно зависит от хеш-функции. Если хешер плохой, то контейнер будет работать неэффективно — даже хуже, чем его «коллега»  `set`  или  `map`. И у хеш-функции есть минимум две причины быть плохой:

-   она может учитывать не все данные объекта, провоцируя коллизии,
-   она может медленно вычисляться.

Решая задачу, вы научились строить совершенную хеш-функцию, значения которой никогда не совпадают для разных объектов. Подумаем, всегда ли это возможно. Попробуем захешировать структуру, задающую фрагмент файла позициями начала и конца фрагмента:

```cpp
#include <cstdint>

struct Fragment {
    uint64_t begin;
    uint64_t end;
};

```

Поля структуры имеют размер 64 бита, а значит, могут принимать 2⁶⁴ различных значения. Вся структура содержит два таких поля, а значит, может иметь 2¹²⁸ различных значений. Результат хеш-функции представлен числом типа  `size_t`, занимающим обычно 64 бита. Чтобы посчитать количество всевозможных хешей, возведём двойку в степень 64. Получим, что количество различных хешей гораздо меньше, чем количество различных значений структуры  `Fragment`. Это значит, что как бы мы не реализовывали хеш-функцию, всегда будут возможны коллизии — различные объекты  `Fragment`, имеющие одинаковые хеши. Подобное относится и к хешированию  `string`, которое мы неявно использовали, когда применяли  `unordered_set`  для подсчёта частот слов в произведении Чосера.

Поскольку реализовать совершенный хешер для  `Fragment`  невозможно, реализуем несовершенный:

```cpp
struct FragmentHasher {
    size_t operator() (const Fragment& f) const {
        return static_cast<size_t>(f.begin + f.end);
    }
};

```

----------

Как вы думаете, в каком из следующих случаев возникнет коллизия двух фрагментов?

-   Когда фрагменты одинаковой длины
    
-   Когда каждый фрагмент имеет одинаковый отступ от начала и конца файла
    
-   Когда оба фрагмента имеют одинаковое начало
    
-   Когда оба фрагмента имеют одинаковый конец
    

Как видим, коллизии могут возникать во вполне естественных случаях. Изменим эту функцию, чтобы её вычисление оставалось быстрым, но коллизии были менее вероятны:

```cpp
struct FragmentHasher {
    static const uint64_t N;
    size_t operator() (const Fragment& f) const {
        return static_cast<size_t>(f.begin * N + f.end);
    }
};

```

По некоторым статистическим соображениям обычно в качестве  `N`  выбирают простое число, например 37. Для обычных целей будет вполне достаточно такой хеш-функции, но её минус в том, что есть простой алгоритм, позволяющий находить коллизии:

```cpp
int main() {
    FragmentHasher hasher;
    Fragment f1{10, 1000};
    Fragment f2{10 + 1, 1000 - 37 * 1};
    Fragment f3{10 + 2, 1000 - 37 * 2};
    Fragment f4{10 + 3, 1000 - 37 * 3};

    cout << "f1 hash - "s << hasher(f1) << endl;
    cout << "f2 hash - "s << hasher(f2) << endl;
    cout << "f3 hash - "s << hasher(f3) << endl;
    cout << "f4 hash - "s << hasher(f4) << endl;
}

```

Результат программы:

```
f1 hash - 1370
f2 hash - 1370
f3 hash - 1370
f4 hash - 1370

```

Более совершенные хеш-функции, используемые в криптографии, имеют собственные названия: MD5, SHA-512, BLAKE3. Алгоритм поиска коллизий для них крайне сложный и требует больших вычислительных ресурсов. Маловероятно, что коллизии будут возникать естественным образом или будут подобраны злоумышленниками.

Криптографические хеш-функции вычисляются достаточно медленно. В криптографических задачах это иногда даже считается плюсом, но на практике их лучше не использовать без необходимости. Как правило, бывает достаточно хеш-функции из приведённого примера с умножением на простое число. Рассмотрим структуру, состоящую из трёх полей и задающую окружность на плоскости:

```cpp
struct Circle {
    double x;
    double y;
    double r;
};

```

Можно вычислить хеш каждого из трёх полей структуры, используя хешер  `std::hash<double>`, а затем объединить их, умножив на число 37. Одну компоненту нужно умножать на 37, а вторую на 37²:

```cpp
struct CircleHasher {
    size_t operator() (const Circle& circle) const {
        size_t h_x = d_hasher_(circle.x);
        size_t h_y = d_hasher_(circle.y);
        size_t h_r = d_hasher_(circle.r);
        
        return h_x + h_y * 37 + h_r * (37 * 37);
    }

private:
    std::hash<double> d_hasher_;
};

```

Такая хеш-функция будет обладать хорошими статистическими свойствами, обеспечивая равномерное заполнение корзинок. Если полей больше, можно складывать их хеши, умножая на новые степени числа 37: на 37³, 37⁴, 37⁵ и т. д. Только учтите — разные параметры хешируемых данных должны обязательно умножаться на разные степени простого числа. Если степень у двух параметров получится одинаковой, статистические свойства хеш-функции ухудшатся.

Выхода за пределы допустимого диапазона  `size_t`  при этом можно не бояться — на качестве хеш-функции это не отразится. Так можно хешировать произвольные типы данных, объединяя поля, которые могут иметь самые разные типы. Даже не обязательно, чтобы их количество было заранее известно. Приведём пример — реализуем хешер для  `vector<int>`:

```cpp
struct IntVectorHasher {
    size_t operator() (const vector<int>& vec) const {
        size_t res = 0;
        for (int num : vec) {
            res = res * 37 + static_cast<size_t>(num);
        }
        return res;
    }
};

```

Хеш-функция перемешивает данные, делая их неузнаваемыми. И если для обычной функции понятность и предсказуемость результата — это плюс, то для хеш-функции — большой минус. Она должна запутать данные как можно сильнее. Если при этом происходит что-нибудь необратимое и непонятное, прекрасно — значит, коллизии будут возникать реже. Однако в практических примерах, не связанных с криптографией, на первом месте остаётся производительность.

Это был последний урок о хеш-функциях, далее вам предстоит поработать с деревьями. К сожалению, речь не о поездке на природу, а всего лишь о структуре данных — дерево.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Как вы думаете, в каком из следующих случаев возникнет коллизия двух фрагментов?

-   **(-)**  Когда фрагменты одинаковой длины
    
-   **(+)**  Когда каждый фрагмент имеет одинаковый отступ от начала и конца файла
    
-   **(-)**  Когда оба фрагмента имеют одинаковое начало
    
-   **(-)**  Когда оба фрагмента имеют одинаковый конец

</details>

<details>
<summary>Задание 1:</summary>

## Задание 1

Реализуйте функцию, которая будет определять количество коллизий в тексте:

```cpp
template <typename Hash>
int FindCollisions(const Hash& hasher, istream& text);

```

Хешер будет передан одним из параметров. Текст нужно читать из потока по словам. Коллизией считаем ситуацию, когда прочитано слово, которое не встречалось ранее, и его хеш совпал с хешем одного из предыдущих слов.

Искать границы слов не нужно. Считайте, что в тексте они уже разделены пробелами, и доверьтесь операции  `>>`.

Эту программу можно будет использовать для проверки качества строковой хеш-функции.

### Пример

```cpp
#include <iostream>
#include <sstream>
#include <string>

using namespace std;

// ваша реализация функции FindCollisions

struct DummyHash {
    size_t operator()(const string&) const {
        return 42;
    }
};

int main() {
    DummyHash dummy_hash;
    hash<string> good_hash;

    {
        istringstream stream("I love C++"s);
        cout << FindCollisions(dummy_hash, stream) << endl;
    }
    {
        istringstream stream("I love C++"s);
        cout << FindCollisions(good_hash, stream) << endl;
    }
}

```

Вывод:

```cpp
2
0

```

### Ограничения

Ваша реализация должна быть эффективна. Будьте готовы, что:

-   возможна плохая хеш-функция, при которой коллизий будет очень много;
-   возможна хорошая хеш-функция, при которой коллизий будет мало.

Рекомендуется использовать  `unordered_map`  и  `unordered_set`  для эффективности реализации.

Сортирующие контейнеры  `map`  и  `set`  использовать запрещено.

### Как будет тестироваться ваш код

Мы проверим, что:

-   функция правильно находит количество коллизий;
-   функция работает эффективно для плохих хеш-функций;
-   функция работает эффективно для хороших хеш-функций;
-   функция работает эффективно для совсем плохих хеш-функций;
-   вы не используете  `map`  и  `set`.

### Подсказка

-   Читайте слова из потока в переменную  `string word`  таким образом:  `while (text >> word)`
-   Создайте ассоциативный контейнер, который будет хранить слова по хешу
-   Подойдёт  `unordered_map<size_t, unordered_set<string>>`
-   Если для хеша есть слово, и вы нашли другое, возникает коллизия
-   Где можно используйте  `move`  для слов

</details>

<details>
<summary>Задание 2:</summary>

## Задание 2

Реализуйте хороший хешер для структуры  `Dumbbell`, состоящей из двух окружностей и текста.

```cpp
struct Circle {
    double x;
    double y;
    double r;
};

struct Dumbbell {
    Circle circle1;
    Circle circle2;
    string text;
};

```

Используйте для вычисления хеша степени простого числа, но учтите: никакие два параметра не должны умножаться на одну и ту же степень, иначе хеш-функция получится некачественной.

### Ограничения

Не меняйте название класса хешера  `DumbbellHash`. Не меняйте структуры  `Dumbbell`  и  `Circle`.

### Как будет тестироваться ваш код

Проверим качество вашей хеш-функции.

### Подсказка

-   Можете использовать хешер окружности из урока. Хешер текста — стандартный.
-   Объединять хеши компонентов структуры нужно с умом, чтобы использовались разные степени числа 37 при разных компонентах: хеш первой окружности должен умножаться на 37⁴, хеш второй — на 37¹ или 37, а хеш строки — на 37⁰ или 1.

</details>
