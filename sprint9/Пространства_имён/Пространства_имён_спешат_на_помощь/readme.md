<details>
<summary>Теория + тестирование:</summary>

# Пространства имён спешат на помощь

В C++ разные сущности кода могут иметь одинаковые имена. В некоторых случаях это не создаёт проблем:

```cpp
#include <iostream>
using namespace std;

int x() {
    int x = 42;
    return x;
}

int main() {
    int y = x();
    {
        int x = y;
        {
            int x = 100500;
            cout << x << endl;
        }
        cout << x << endl;
    }
}

```

Программа два раза подряд выводит  `x`, но выдаёт разные числа:

```cpp
100500
42

```

----------

Сколько разных сущностей кода этой программы имеют имя  `x`?

-   1
    
-   2
    
-   3
    
-   4
    
-   5
    
-   6
    

Посчитаем:

1.  функция  `x`,
2.  переменная в функции  `x`,
3.  переменная в функции  `main`, которой мы присвоили значение  `y`,
4.  переменная в функции  `main`, которой мы присвоили 100500.

----------

Когда сущности с одинаковым именем начинают конкурировать друг с другом, компилятор выбирает ту из них, которая находится в наиболее близкой объемлющей области видимости. Если же несколько имён расположены одинаково по отношению к месту использования, неизбежно возникает конфликт: компилятор не сможет выбрать между ними. Подбрасывать монетку, чтобы выбрать победителя, компилятор не станет. Вместо этого он покажет вам ошибку и откажется собирать программу.

Вспомним две задачи, которые вы решали перед этим уроком. В одной использовали библиотеку для работы с JSON, а в другой — для работы с XML. Теперь попробуем сделать универсальную программу, которая бы поддерживала оба формата. Здесь нас поджидают проблемы. Подключив  `json.h`  и  `xml.h`  в  `main.cpp`, получим целую плеяду ошибок:

```
xml.h:11:7: error: redefinition of 'class Node'
 class Node {
       ^~~~
In file included from main.cpp:7:
json.h:10:7: note: previous definition of 'class Node'
 class Node {
       ^~~~
In file included from main.cpp:8:
xml.h:28:7: error: redefinition of 'class Document'
 class Document {
       ^~~~~~~~
In file included from main.cpp:7:
json.h:29:7: note: previous definition of 'class Document'
 class Document {
       ^~~~~~~~
In file included from main.cpp:8:
xml.h:44:10: error: no declaration matches 'T Node::AttributeValue(const string&) const'
 inline T Node::AttributeValue(const string& name) const {
          ^~~~
xml.h:44:10: note: no functions named 'T Node::AttributeValue(const string&) const'
In file included from main.cpp:7:
json.h:10:7: note: 'class Node' defined here
 class Node {

```

Ошибка  `redefinition of class`  сообщает о том, что класс с таким именем был определён ранее. Иначе говоря, о конфликте имён. Компилятор указал два места, где определяются классы с именем  `Node`, и с ним не поспоришь.

Выходит, в библиотеках JSON и XML есть серьёзный просчёт — они используют простые названия для классов и функций:  `Node`,  `Document`,  `Load`. Эти имена в двух библиотеках конфликтуют. Использовать их одновременно нельзя, более того, такие простые названия могут конфликтовать и с другими частями большой программы.

----------

Как можно решить эту проблему?

-   Добавить к каждому имени префикс или постфикс. Например,  `XMLNode`,  `XMLDocument`,  `JSONLoad`  и т. д.
    
-   Сделать два независимых cpp-файла. В одном включить  `json.h`, в другом —  `xml.h`.
    
-   Не делать так: в одной программе и XML, и JSON не нужны одновременно, надо выбрать что-нибудь одно.
    

Добавление к именам префикса часто используется, особенно в библиотеках, которые могут быть доступны на чистом C.

Но мы поступим иначе и вместо добавления префикса к каждому имени используем такую возможность C++ как пространства имён. Чтобы это сделать, нужно все определения и объявления в cpp и h-файлах заключить в конструкцию  `namespace имя {...}`:

```cpp
//файл json.h

#pragma once

// #include ...

// начинаем пространство имён
namespace json {

// В соответствии с принятым в Практикуме стилем оформления кода
// содержимое внутри namespace {...} пишется без отступов.
class Node {
    // ...
};

class Document {
    // ...
};

Document Load(std::istream& input);

template <typename T>
inline T Node::AttributeValue(const std::string& name) const {
    // ...
}

// нужно закрыть namespace
}

```

Так будет выглядеть файл json.cpp:

```cpp
#include "json.h"

using namespace std;

// начинаем пространство имён
namespace json {

Node::Node(vector<Node> array) : as_array(move(array)) {
}

// определения других конструкторов и методов класса Node

Node LoadNode(istream& input);

Node LoadArray(istream& input) {
    // ...
}

// определения других вспомогательных функций

Document Load(istream& input) {
    // ...
}

// нужно закрыть namespace
}

```

Аналогично поступим с библиотекой XML: обернём все объявления и определения в этих файлах в  `namespace xml`.

Теперь включение обоих заголовочных файлов в  `main.cpp`  не вызовет ошибок. Эта операция оказалась проще добавления префикса  `JSON`  или  `XML`  ко всем именам библиотек — не пришлось редактировать каждое имя. Но вне пространства имён, например в файле  `main.cpp`, имя  `Document`  стало недоступно. Нужно сообщить компилятору, документ из какого пространства имён мы имеем в виду, добавив перед именем  **квалификацию**  — явное указание на то, в каком пространстве имён его искать.

Вот как можно дать квалификацию:

```cpp
vector<Spending> LoadFromXml(istream& input) {
    xml::Document doc = xml::Load(input);
    vector<Spending> result;
    for (const xml::Node& node : doc.GetRoot().Children()) {
        result.push_back({node.AttributeValue<string>("category"s), node.AttributeValue<int>("amount"s)});
    }
    return result;
}

vector<Spending> LoadFromJson(istream& input) {
    json::Document doc = json::Load(input);
    vector<Spending> result;
    for (const json::Node& node : doc.GetRoot().AsArray()) {
        result.push_back({node.AsMap().at("category"s).AsString(), node.AsMap().at("amount"s).AsInt()});
    }
    return result;
}

```

К именам библиотеки JSON добавлен префикс  `json::`  и префикс  `xml::`  для имён XML. Такой способ имеет минимум два преимущества перед явным приписыванием префиксов ко всем именам файла:

-   имя с квалификацией  `json::Document`  выглядит структурировано и его проще читать, чем  `JSONDocument`;
-   внутри библиотеки нет необходимости каждый раз писать префикс.

В этом уроке вы ближе познакомились с понятием пространства имён. Но на самом деле вы активно использовали пространства имён и до этого.

----------

Перед вами сущности из стандартной библиотеки. Выберите среди них пространства имён. В случае сомнений можете сверяться с документацией.

-   `std`
    
-   `string`
    
-   `cout`
    
-   `chrono`
    
-   `unordered_set`
    

Квалификация имени похожа на написание адреса. Если хотите попросить кого-нибудь сходить в ближайший магазин, можете просто сказать «сходи в магазин N». Если имеется в виду определённый магазин вашего города, нужно дать квалификацию, то есть название улицы: «магазин N на улице Бассейной». Если же магазин находится в другом городе или даже другой стране, квалификация будет больше, например «магазин N на Марион-стрит, Сиэтл, США». В C++ этому соответствует использование нескольких вложенных пространств имён, например  `std::chrono::steady_clock`.

В следующем уроке подробнее разберём синтаксис пространств имён.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

----------

Сколько разных сущностей кода этой программы имеют имя  `x`?

-   **(-)**  1
    
-   **(-)**  2
    
-   **(-)**  3
    
-   **(+)**  4
    
-   **(-)**  5
    
-   **(-)**  6
    

----------

Как можно решить эту проблему?

-   **(+)**  Добавить к каждому имени префикс или постфикс. Например,  `XMLNode`,  `XMLDocument`,  `JSONLoad`  и т. д.

> Сложно, но можно. Если вы столкнулись с конфликтами в большой библиотеке, придётся переписывать много кода. Но проблема конфликтов решится.

-   **(-)**  Сделать два независимых cpp-файла. В одном включить  `json.h`, в другом —  `xml.h`.

> Проблемы всё равно возникнут на этапе компоновки. Компилятор соберёт каждый из cpp-файлов. Но когда компоновщик начнёт собирать их в один, он увидит две реализации конструктора  `Document::Document`, две реализации функции  `Load`  и наверняка что-нибудь ещё. Компоновщик не сможет выбрать из двух и от безысходности покажет ошибку.

-   **(-)**  Не делать так: в одной программе и XML, и JSON не нужны одновременно, надо выбрать что-нибудь одно.

> В реальной жизни заказчик не обрадуется таким рассуждениям.

----------

Перед вами сущности из стандартной библиотеки. Выберите среди них пространства имён. В случае сомнений можете сверяться с документацией.

-   **(+)**  `std`
    
-   **(-)**  `string`
    
-   **(-)**  `cout`
    
-   **(+)**  `chrono`
    
-   **(-)**  `unordered_set`

</details>
