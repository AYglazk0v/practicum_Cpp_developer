<details>
<summary>Теория + тестирование:</summary>
# Глобальное пространство имён и std

До подробного изучения пространств имён мы добрались только в этой теме. Но некоторые пространства вы постоянно использовали и раньше. С одним из них вы знакомы с первых шагов в C++ — с момента, когда вы написали строку  `using namespace std;`. Это пространство стандартной библиотеки  `std`. Другое объемлет всё, что есть в вашей программе. Оно называется глобальным. Разберём эти пространства имён.

### Пространство имён  `std`

Сказать, что пространство  `std`  содержит всё, что есть в стандартной библиотеке, будет преувеличением, потому что некоторые вещи вынужденно в него не входят и доступны глобально.

----------

Вы можете сами догадаться, что из этого не является именем в  `std`:

-   `vector`
    
-   `return`
    
-   `assert`
    
-   `find`
    

В  `std`  находятся многие имена, с которыми вы имели дело. Например:

-   контейнеры —  `std::vector`,  `std::map`,  `std::list`,  `std::set`,  `std::string`;
-   алгоритмы —  `std::find`,  `std::find_if`,  `std::upper_bound`,  `std::reverse`,  `std::max`;
-   потоки и манипуляторы —  `std::cin`,  `std::cout`,  `std::endl`;
-   математические функции —  `std::log`,  `std::sin`,  `std::atan`;
-   многопоточность —  `std::mutex`,  `std::lock_guard`,  `std::future`;
-   вспомогательные функции —  `std::move`,  `std::exchange`,  `std::swap`.

Некоторые имена стандартной библиотеки могут стать доступны в глобальном пространстве имён, то есть без префикса  `std::`. Так исторически сложилось. Какие конкретно имена будут видны без префикса, стандартом не регламентировано и зависит от используемой вами стандартной библиотеки.

Из-за этого при разработке поисковой системы вы могли столкнуться со следующей проблемой. Взгляните на программу, которая сортирует документы по убыванию рейтинга и релевантности:

```cpp
#include <algorithm>
#include <cstdlib>
#include <iostream>
#include <vector>

struct Document {
    int id = 0;
    double relevance = 0.0;
    int rating = 0;
};

// Сортирует документы по релевантности и рейтингу
void SortDocuments(std::vector<Document>& docs) {
    std::sort(docs.begin(), docs.end(), 
        [](const Document& lhs, const Document& rhs){
            if (abs(lhs.relevance - rhs.relevance) < 1e-6) {
                // релевантности примерно равны, упорядочиваем документы по рейтину
                return lhs.rating > rhs.rating;
            } else {
                return lhs.relevance > rhs.relevance;
            }
        });
}

int main() {
    std::vector<Document> docs{ {1, 0.3, 3}, {2, 0.2, 5} };
    SortDocuments(docs);
    for (const auto& doc : docs) {
        std::cout << doc.id << ',';
    }
}

```

----------

Что выведет эта программа?

-   `1,2,`
    
-   `2,1,`
    
-   Результат зависит от компилятора
    

----------

На первый взгляд кажется, что программа должна вывести сначала документ с id=1 и релевантностью 0,3, а потом документ с id=2 релевантностью 0,2. Если программу скомпилировать, используя Visual C++, так и произойдёт. А с компилятором gcc программа выведет документы в противоположном порядке. Дело в том, что в gcc в заголовочных файлах стандартной библиотеки функция  `abs`  объявлена примерно так:

```cpp
// Версии функции abs в глобальном пространстве имён называются по-разному,
// так же, как это реализовано в C
int abs(int);
float fabsf(float);
double fabs(double);

namespace std {
// C++ поддерживает перегрузку функций, поэтому внутри namespace std
// есть функции с одинаковым именем, но разными типами аргументов

float fabsf(float);
float fabs(float);
double fabs(double);

int abs(int x);
float abs(float x);
double abs(double);

}  // namespace std

```

В gcc глобальное пространство имён содержит только одну функцию  `abs`, которая принимает и возвращает  `int`. Теперь взглянем ещё раз на сортировку документов:

```cpp
std::sort(docs.begin(), docs.end(), 
    [](const Document& lhs, const Document& rhs) {
        if (abs(lhs.relevance - rhs.relevance) < 1e-6) {
            // релевантность примерно равна, упорядочиваем документы по рейтину
            return lhs.rating > rhs.rating;
        } else {
            return lhs.relevance > rhs.relevance;
        }
    });

```

В программе отсутствует директива  `using namespace std;`. Поэтому по короткому имени  `abs`  компилятор gcc находит только функцию, принимающую  `int`. Разность релевантностей документов, равная 0.1 или -0.1, преобразуется из  `double`  в  `int`  и становится равной нулю. В результате  `abs`  возвращает 0, и компаратор сравнивает рейтинг документов. Документ с меньшей релевантностью, но более высоким рейтингом поднимается наверх.

Visual C++ в стандартной библиотеке в глобальном пространстве имён объявляет функции  `abs`, принимающие как целые числа, так и числа с плавающей запятой:

```cpp
namespace std {
    // Здесь то же, что и в gcc
} 

float fabsf(float);
float fabs(float);
double fabs(double);

int abs(int);
inline float abs(float x) { return fabsf(x); }
inline double abs(double x) { return fabs(x); }

```

Чтобы программа везде работала одинаково, нужно в компараторе вызвать  `std::abs`  явно, либо использовать  `using namespace std`. Во втором случае перегруженные версии  `std::abs`  станут видны в глобальном пространстве имён, и gcc между  `abs(int)`  и  `std::abs(double)`  выберет  `std::abs(double)`  как более подходящий под аргумент  `double`.

```cpp
namespace std {

int abs(int);
float abs(float);
double abs(double);

float fabs(float);
double fabsl(double);

}  // namespace std

// В языке C нет перегрузки функций, поэтому версии функции abs, 
// работающие с разными типами, имеют разные имена
int abs(int);
float fabs(float);
double fabsl(double);

```

В теме о многофайловых проектах мы договорились не писать  `using namespace std`  в h-файлах. Писать его в cpp-файлах или нет — дело вкуса. Нужно понимать, что при использовании  `using namespace std`  могут возникать конфликты между именами стандартной библиотеки и именами вашей программы. Кроме того, стандартная библиотека расширяется с принятием нового стандарта, что происходит примерно раз в 3 года. Это может добавить новые имена, которые вы не учитывали при написании своей программы.

В задачах и проектах курса вы можете смело использовать  `using namespace std`  в cpp-файлах. Здесь принят стиль, согласно которому функции и классы называются с большой буквы, а значит, с именами  `std`  они конфликтовать не будут.

### Глобальное пространство имён

Ещё одно пространство имён, которое мы используем, не задумываясь — глобальное. Если функция или класс не помещены ни в какой  `namespace`, говорят, что они расположены в глобальном пространстве. Например, в нём должна находиться функция  `main`  любой программы. В нём же были все классы и функции, которые вы писали до того, как узнали о  `namespace`. В него попадают все имена из  `std`, если написать  `using namespace std;`  в начале файла.

К имени из глобального пространства можно гарантированно получить доступ, написав перед ним два двоеточия  `::`.

Когда отправляете письмо, вы всегда пишете полный адрес. Например: Россия, Москва, улица Лесная, дом 55. Даже если в вашем городе есть гостиница «‎Россия»‎, почтальону не придёт в голову искать нужный адрес в ней. Но C++ в случае конфликта всегда будет выбирать наиболее близкое при поиске имя, предпочитая его глобальному. Рассмотрим пример:

```cpp
#include <iostream>
using namespace std;

class Street;

namespace neverhood { // Пространство имён "Небывальщина"
Street& MoonStreet();
}

namespace highland {   // Пространство имён "Плоскогорье"
namespace neverhood {} // Пространство имён "Небывальщина"

Street& GoToNeverhood() {
    return neverhood::MoonStreet();
}
}  // namespace highland

```

Такая программа не скомпилируется, потому что имя  `highland::neverhood`  закроет глобальное имя  `neverhood`  при поиске в функции  `GoToNeverhood`. Получить доступ к правильному  `neverhood`  можно, явно указав, что имя глобальное:  `::neverhood::MoonStreet()`. Это равносильно написанию полного адреса на конверте.

----------

Посмотрите на пример:

```cpp
#include <string>

using namespace std;

template <typename T>
string Bark(T barker);

namespace pet {
class Dog {
public:
    class Barker {};
};

class Kitty {
public:
    class Meower {};
};
}  // namespace pet

using pet::Kitty;

int main() {
    Bark(::pet::Dog::Barker());
    Bark(::pet::Kitty::Meower());
}

```

Какие из следующих имён окажутся в глобальном пространстве имён, то есть будут доступны при обращении через два двоеточия?

-   Dog
    
-   Kitty
    
-   pet
    
-   Bark
    
-   Barker
    
-   main
    
-   string
    

На этом изучение пространств имён в рамках этого курса почти завершено. В следующем уроке вас ждут рекомендации, которых следует придерживаться при решении задач курса и разработке других программ на C++.
</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Вы можете сами догадаться, что из этого не является именем в  `std`:

-   **(-)**  `vector`

> Квалифицированное имя  `std::vector`.

-   **(+)**  `return`

> Это не имя, а ключевое слово.

-   **(+)**  `assert`

> Это не имя, а название макроса. На этапе препроцессирования макросы изменяют исходный код программы. Это происходит ещё до того, как за работу возьмётся компилятор.

-   **(-)**  `find`

> Квалифицированное имя  `std::find`.

----------

Что выведет эта программа?

-   **(-)**  `1,2,`
    
-   **(-)**  `2,1,`
    
-   **(+)**  Результат зависит от компилятора
    

----------

Посмотрите на пример:

```cpp
#include <string>

using namespace std;

template <typename T>
string Bark(T barker);

namespace pet {
class Dog {
public:
    class Barker {};
};

class Kitty {
public:
    class Meower {};
};
}  // namespace pet

using pet::Kitty;

int main() {
    Bark(::pet::Dog::Barker());
    Bark(::pet::Kitty::Meower());
}

```

Какие из следующих имён окажутся в глобальном пространстве имён, то есть будут доступны при обращении через два двоеточия?

-   **(-)**  Dog
    
-   **(+)**  Kitty
    
-   **(+)**  pet
    
-   **(+)**  Bark
    
-   **(-)**  Barker
    
-   **(+)**  main
    
-   **(+)**  string

</details>
