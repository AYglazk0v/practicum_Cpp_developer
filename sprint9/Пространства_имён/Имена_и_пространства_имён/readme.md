<details>
<summary>Введение:</summary>

# Введение

В этой теме вы узнаете, как структурировать свою программу, используя пространства имён. Вам предстоит подробно изучить понятие имени, поиск имён и конкуренцию, которая при этом возникает. Вы сможете повысить понятность и читаемость программ.

Вас ждут задания на понимание чужого кода, рефакторинг и написание собственной мини-библиотеки. В процессе вы поработаете со следующими форматами структурирования данных: JSON, XML, INI.

</details>

<details>
<summary>Теория + тестирование:</summary>

# Зови меня по имени

— Меня зовут Иван Андреевич Иванов.

— А меня Петр Васильевич Петров.

Такой диалог можно услышать где-нибудь в общественном месте. Имена мы используем, чтобы обратиться к человеку. Имена есть у всех, причём не только у людей: у домашних животных, у железнодорожных станций, у улиц и площадей, городов, компаний, брендов, сайтов и у многого другого. А в C++ имена есть… Впрочем, давайте вы сами скажете.

----------

У каких сущностей кода в C++ есть имена?

-   У переменных
    
-   У параметров функции
    
-   У классов, структур, enum и union-деклараций
    
-   У функций
    
-   У циклов
    
-   У лямбда-функций
    
-   У областей видимости
    
-   У псевдонимов типов
    
-   У шаблонных параметров
    

Ещё имена есть у пространств имён, которые вы будете проходить в этой теме. И отдельно нужно сказать, у чего имён нет — у макросов, определённых через  `#define`  или параметры компиляции. Макросы обрабатываются во время препроцессирования, и компилятор получает код, где никаких макросов уже нет. Поэтому названия макросов не стоит считать именами. Эти идентификаторы живут по своим законам и не конкурируют с другими.

Имя — это идентификатор. Оно:

-   состоит из латинских букв: больших и маленьких, цифр и знака подчёркивания;
-   не может начинаться с цифры;
-   может состоять даже из одного символа, например, знака подчёркивания:  `_`  — допустимое имя для сущности в C++.

Имена людей в реальной жизни могут совпадать. Имена разных сущностей кода тоже. Но они не должны совпадать с ключевыми словами, набор которых в C++ жёстко ограничен. Если в одной программе встретились одинаковые имена, они конкурируют между собой. Компилятор по строгим правилам будет определять, какую сущность имел в виду программист, когда написал имя, принадлежащее нескольким сущностям. Если выбрать не удалось, компилятор выдаст ошибку.

Некоторые сущности кода, которые обычно имеют имя, могут вдруг оказаться безымянными. Бывает, что хозяева не дали имя своей собачке, и её зовут просто Собака. Но в C++ назвать структуру словом  `struct`  нельзя, потому что это слово ключевое. Поэтому она будет безымянной. Всё, что вы можете сделать с такой структурой, — это сразу объявить переменную такого типа:

```cpp
int main() {
    // Объявляем переменную point. 
    // Её тип - безымянная структура с полями x и y типа int.
    struct {
        int x;
        int y;
    } point;
    point.x = 5;
    point.y = 10;
}

```

Помимо структуры и класса, безымянным может быть параметр функции или шаблона, если они не используются, но должны быть указаны. Вспомните, например, самый плохой в мире хешер, который всегда выдаёт 42, вне зависимости от значения своего параметра:

```cpp
struct DummyHasher { 
    size_t operator() (const std::string& s) const {
        return 42;
    }
};

```

Параметр  `s`  не используется, о чём может предупредить компилятор:

```
In member function 'size_t DummyHasher::operator()(const string&) const':
prog.cc:6:43: warning: unused parameter 's' [-Wunused-parameter]
    6 |     size_t operator() (const std::string& s) const {
      |                        ~~~~~~~~~~~~~~~~~~~^

```

Объявив параметр операции  `()`  безымянным, можно устранить это предупреждение:

```cpp
struct DummyHasher { 
    size_t operator() (const std::string&) const {
        return 42;
    }
};

```

Другой способ указать, что параметр может быть неиспользуемым — пометить его атрибутом  `[[maybe_unused]]`:

```cpp
struct DummyHasher { 
    size_t operator() ([[maybe_unused]] const std::string& s) const {
        // Теперь компилятор не будет предупреждать о том, что s не используется
        return 42;
    }
};

```

Разрешается не писать имена параметров и при объявлении функции. А вот переменные и сами функции безымянными быть не могут.

В некоторых случаях имя может быть составным — разбиваться на лексемы. Так бывает с операциями. Операция — это обычная функция, имя которой состоит из ключевого слова  `operator`  и знака операции, например,  `operator+`. Ещё один пример составного имени — имя деструктора класса, которое содержит знак  `~`.

----------

Укажите имена в коде следующей программы. В случае сомнений можете свериться со  [списком ключевых слов](https://ru.cppreference.com/w/cpp/keyword)  на сайте cppreference.com.

```cpp
#include <iostream>

using namespace std;

template <int X>
struct S {
    int operator()() const {
        return X;
    }
};

int main() {
    S<42> get42, _;
    cout << "Hello world, "s << get42() << endl;
}

```

-   `include`
    
-   `iostream`
    
-   `using`
    
-   `namespace`
    
-   `std`
    
-   `template`
    
-   `int`
    
-   `X`
    
-   `struct`
    
-   `S`
    
-   `operator()`
    
-   `const`
    
-   `return`
    
-   `main`
    
-   `42`
    
-   `get42`
    
-   `_`
    
-   `cout`
    
-   `endl`
    

----------

В этом уроке мы говорили о синтаксисе программы — структуре её кода, но не о семантике — том, что программа делает. Вы увидели, у каких сущностей кода программы есть имена, и какими эти имена бывают. В заданиях к этому уроку вам предстоит отвлечься от имён и поработать с уже готовым кодом, написанным другими программистами. Материалы этих заданий пригодятся в последующих уроках.

В заданиях говорится о компьютерных языках JSON и XML, которые задают форматы структурирования данных. Для вас подготовлены простые библиотеки для чтения этих форматов. Ваша задача — самостоятельно в них разобраться и научиться использовать.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

----------

У каких сущностей кода в C++ есть имена?

-   **(+)**  У переменных
    
-   **(+)**  У параметров функции
    
-   **(+)**  У классов, структур, enum и union-деклараций
    
-   **(+)**  У функций
    
-   **(-)**  У циклов
    

> Циклы называют  `for`,  `while`,  `do`  — но это не имя, а тип цикла.

-   **(-)**  У лямбда-функций

> Они безымянны. Вы можете записать лямбда-функцию в переменную, которую отдельно создали, но она будет иметь имя переменной.

-   **(-)**  У областей видимости

> Область видимости это просто фигурные скобки, она никак не именуется.

-   **(+)**  У псевдонимов типов
    
-   **(+)**  У шаблонных параметров
    

----------

Укажите имена в коде следующей программы. В случае сомнений можете свериться со  [списком ключевых слов](https://ru.cppreference.com/w/cpp/keyword)  на сайте cppreference.com.

```cpp
#include <iostream>

using namespace std;

template <int X>
struct S {
    int operator()() const {
        return X;
    }
};

int main() {
    S<42> get42, _;
    cout << "Hello world, "s << get42() << endl;
}

```

-   **(-)**  `include`

> Это директива препроцессора. На этапе компиляции её уже нет.

-   **(-)**  `iostream`

> Это имя файла. До компилятора оно не доходит.

-   **(-)**  `using`

> Ключевое слово.

-   **(-)**  `namespace`

> Ключевое слово.

-   **(+)**  `std`
    
-   **(-)**  `template`
    

> Ключевое слово.

-   **(-)**  `int`

> Ключевое слово. Некоторые базовые типы являются ключевыми словами, хотя ведут себя во многом подобно именам. Определить своё имя  `int`  не получится. Это нужно запомнить.

-   **(+)**  `X`
    
-   **(-)**  `struct`
    

> Ключевое слово.

-   **(+)**  `S`
    
-   **(+)**  `operator()`
    
-   **(-)**  `const`
    

> Ключевое слово.

-   **(-)**  `return`

> Ключевое слово.

-   **(+)**  `main`
    
-   **(-)**  `42`
    

> Это литерал. Имя не может начинаться с цифры.

-   **(+)**  `get42`
    
-   **(+)**  `_`
    
-   **(+)**  `cout`
    
-   **(+)**  `endl`

</details>

<details>
<summary>Задание 1:</summary>

## Задание 1

Перед вами программа для подсчёта трат:

```cpp
#include <algorithm>
#include <cassert>
#include <fstream>
#include <iostream>
#include <numeric>
#include <vector>
using namespace std;

// структура хранит информацию о трате:
// категорию товара или услуги и стоимость
struct Spending {
    string category;
    int amount;
};

int CalculateTotalSpendings(const vector<Spending>& spendings) {
    return accumulate(
        spendings.begin(), spendings.end(), 0, [](int current, const Spending& spending){
            return current + spending.amount;
        });
}

string FindMostExpensiveCategory(const vector<Spending>& spendings) {
    assert(!spendings.empty());
    auto compare_by_amount = [](const Spending& lhs, const Spending& rhs) {
        return lhs.amount < rhs.amount;
    };
    return max_element(begin(spendings), end(spendings), compare_by_amount)->category;
}

int main() {
    const vector<Spending> spendings = {{"food"s, 2500},    {"transport"s, 1150}, {"restaurants"s, 5780},
                                        {"clothes"s, 7500}, {"travel"s, 23740},   {"sport"s, 12000}};
    cout << "Total "s << CalculateTotalSpendings(spendings) << '\n';
    cout << "Most expensive is "s << FindMostExpensiveCategory(spendings) << '\n';
}

```

Две функции этой программы вычисляют сумму всех трат и наиболее дорогую категорию.

В  `main`  показан пример загрузки данных. Но так использовать программу неудобно. Поэтому примените предлагаемую библиотеку для чтения JSON.

Ваша задача разработать функцию:

```cpp
vector<Spending> LoadFromJson(istream& input)

```

Она должна прочитать JSON из входного потока и возвратить вектор трат.

Нужно обрабатывать только JSON строго определённого вида, подобный тому, который указан в примере. Проверять корректность входа не нужно, считайте, что на вход подаётся только JSON, поддерживаемый предоставленной библиотекой.

В рамках этой задачи вам нужно изучить интерфейс приведённой библиотеки и понять, как её применить для чтения данных задачи. В подсказках ****— ****советы по использованию этой библиотеки.

Учтите, библиотека JSON создана специально для задания, это не полноценная библиотека для чтения этого формата.

### Пример

Пусть в поток передан следующий JSON:

```json
[
  {"amount": 2500, "category": "food"},
  {"amount": 1150, "category": "transport"},
  {"amount": 5780, "category": "restaurants"},
  {"amount": 7500, "category": "clothes"},
  {"amount": 23740, "category": "travel"},
  {"amount": 12000, "category": "sport"}
]

```

Если вы не поменяли  `main`, программа должна прочитать JSON, используя вашу функцию, и вывести следующий текст:

```cpp
Total 52670
Most expensive is travel

```

### Ограничения

-   Можно менять только функцию  `LoadFromJson`  и при необходимости добавлять свои функции в файл main.cpp.
-   Не меняйте структуру  `Spendings`, функцию  `main`, файлы  `json.h`  и  `json.cpp`.

### Как будет тестироваться ваш код

Проверим, что:

-   Вы не поменяли ничего лишнего;
-   Вы правильно читаете JSON и делаете это, используя нашу библиотеку.

Гарантируется, что:

-   JSON, подаваемый на вход, будет иметь строго определённый формат: непустой массив словарей, содержащих ключи  `amount`  и  `category`. Не переусложняйте свой код избыточными проверками.
-   Значение  `amount`  целочисленное. Значение  `category`  всегда строковое.

### Подсказка

-   Прочитать JSON можно функцией  `Load`. Она возвратит объект типа  `Document`, содержащий все необходимые данные.
-   JSON состоит из узлов, главный из которых — корневой. Получить его можно методом документа  `GetRoot()`.
-   Корневой узел JSON из этой задачи — всегда массив. Получить доступ к его элементам можно методом  `AsArray()`.
-   Элементы корневого узла — словари. Можно получить ассоциативный контейнер, лежащий в их основе методом  `AsMap()`.
-   Получив из словаря нужный узел, конвертируйте его в число методом  `AsInt()`  либо в  `string`  методом  `AsString()`.

</details>

<details>
<summary>Задание 2:</summary>

## Задание 2

Вы реализовали удобный способ задавать данные для калькулятора трат. Но современные программы умеют открывать самые разные файлы — вряд ли ваш любимый графический редактор поддерживает только один формат изображений.

Расширьте калькулятор трат, добавив другой формат — XML.

Разработайте функцию:

```cpp
vector<Spending> LoadFromXml(istream& input)

```

Она должна прочитать XML из входного потока и возвратить вектор трат.

Как и в прошлой задаче, на вход будут подаваться данные строго определённого вида. Пример указан ниже. Проверять корректность входа не нужно.

В рамках этой задачи вам нужно самостоятельно изучить интерфейс приведённой библиотеки и понять, как её можно использовать для чтения данных задачи. В подсказках — советы по использованию этой библиотеки.

Библиотека XML создана специально для этого задания, это не полноценная библиотека для чтения этого формата.

### Пример

Пусть во входной поток передан следующий XML:

```xml
<july>
  <spend amount="2500" category="food"></spend>
  <spend amount="1150" category="transport"></spend>
  <spend amount="5780" category="restaurants"></spend>
  <spend amount="7500" category="clothes"></spend>
  <spend amount="23740" category="travel"></spend>
  <spend amount="12000" category="sport"></spend>
</july>

```

Программа прочтёт этот XML, используя вашу функцию, и выведет следующий текст:

```cpp
Total 52670
Most expensive is travel

```

Название корневого элемента можно проигнорировать.

### Ограничения

-   Можно менять только функцию  `LoadFromXml`, при необходимости добавлять свои функции в файл main.cpp.
-   Не меняйте структуру  `Spendings`, функцию  `main`, файлы  `xml.h`  и  `xml.cpp`.

### Как будет тестироваться ваш код

Проверим, что:

-   Вы не поменяли ничего лишнего;
-   Вы правильно читаете XML и делаете это, используя нашу библиотеку.

Гарантируется, что:

-   XML, подаваемый на вход, будет иметь строго определённый формат: в корневой тег, имеющий произвольное имя, вложены только теги  `spend`.
-   Количество тегов  `spend`  — не менее одного.
-   Эти теги имеют атрибуты  `amount`  и  `category`, данные из которых вам нужно использовать.

### Подсказка

-   Прочитать XML можно функцией  `Load`. Она возвратит объект типа  `Document`, содержащий все необходимые данные.
-   XML состоит из элементов или тегов, главный из которых — корневой. Получить его можно методом документа  `GetRoot()`.
-   Вам нужны вложенные теги корневого элемента. Доступ к ним можно получить методом  `Children()`.
-   Нужные значения получи́те, применив шаблонный метод  `AttributeValue`  тега, который принимает один аргумент — название атрибута.
-   Используйте  `AttributeValue<int>`  для получения числовых атрибутов и  `AttributeValue<string>`  для строковых.

</details>
