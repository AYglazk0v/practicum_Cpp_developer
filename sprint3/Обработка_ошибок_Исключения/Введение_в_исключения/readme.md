<details>  
<summary>Теория:</summary>

# Введение в исключения

В предыдущем уроке вы использовали  `optional`  и упростили код обработки ошибок поисковой системы. Но в таком решении есть ряд недостатков.

-   Некоторые конструкции могут выглядеть неочевидно из-за приведения значений  `optional`  к типу  `bool`. Например, вызов метода  `FindTopDocuments`:

```cpp
if (search_server.FindTopDocuments("кот пушистый"s)) {
}

```

Этот код воспринимается как «‎Если поисковый сервер нашел документы»‎. Но семантика у него иная: «‎Если поиск документов завершился без ошибок»‎. А чтобы проверить наличие документов, нужно написать:

```cpp
if (auto documents = search_server.FindTopDocuments("кот пушистый"s);
    documents && !documents->empty())
{
}

```

-   Когда важно знать не только о наличии ошибки, но и о её причинах,  `optional`  уступает кодам ошибок.

Посмотрим, во что может превратиться программа, использующая коды ошибок:

```cpp
struct SomeResult { /*...*/ };

enum class ErrorCode {
    Success,
    FailedToSolveQuadraticEquation,
    FailedToWriteDataToFile,
};
// Эта функция может завершиться неудачей по разным причинам, поэтому используем enum
// для возврата кода ошибок
ComplexProblemSolvingErrorCode SolveComplexProblem(SomeResult& result) {
    double a, b, c;
    /* ... */
    pair<double, double> roots;
    // Проверили результат функции, которая может завершиться неудачей
    if (!SolveQuadraticeEquation(a, b, c, roots)) {
        return ErrorCode::CantSolveQuadraticEquation;
    }

    vector<double> numbers = {roots.first, roots.second};
    // Проверяем результат работы еще одной функции
    if (!SaveNumbersToFile(numbers, "file.txt"s)) {
        return ErrorCode::FailedToWriteDataToFile;
    }
    /* Еще несколько подобных проверок */

    // Наконец-то собрали результат
    result = MakeResult(roots.first, roots.second, a + b);
    // Сообщаем об успешном выходе
    return ErrorCode::Success;
}

```

Читаемость сильно пострадала, потому что код, выполняющий полезную работу, перемешался с кодом, который обрабатывает ошибки. Более того, код по-прежнему нельзя назвать надёжным. Ведь приложение реагирует на коды возврата только тогда, когда проверяет их.

В случае с классами коды ошибок работают ещё хуже. Конструкторы, как мы знаем, не имеют возвращаемого значения. Но они должны создать объект, который находится в согласованном состоянии. Это влечёт множество вопросов. А что, если конструктор не может создать такой объект? Например, как параметризованный конструктор класса  `Rational`  должен создать дробь, если в качестве знаменателя передали ноль? Проигнорировать ошибку и оставить объект в невалидном состоянии? Превратить число с нулевым знаменателем в 0/1 и притвориться, что ничего не было? Завести у дроби особое состояние вроде  `nan`, усложнив тем самым операции над ним и заставив пользователей класса мучиться с его обработкой?

```cpp
class Rational {
public:
    Rational(int numerator, int denominator)
        : numerator_(numerator)
        , denominator_(denominator)
    {
        if (denominator_ == 0) {
            /* В каком состоянии оставить дробь? */
        }
    }
    ...
private:
    int numerator_ = 0;
    int denominator_ = 1;
};

```

Беспомощны коды ошибок и при перегрузке операций. В обычные функции можно добавить параметр для возврата кода ошибки, а в операцию — нельзя:

```cpp
int main() {
    Rational x, y;
    cin >> x >> y;
    // Неужели перед каждым делением нужно проверять, не делим ли мы на 0?
    cout << x / y << endl;
}

```

К счастью, создатели языка C++ включили в него мощный механизм исключений. Они исправят недостатки, присущие кодам ошибок. Чтобы начать работать с исключениями, разберём несколько новых понятий и ключевых слов.

### Выбрасывание исключения. Ключевое слово throw

Сигнализируя о возникновении исключительной ситуации, программа может выбросить исключение. Для этого применяется ключевое слово  `throw`. Синтаксис throw-выражения:

```cpp
throw *выражение*

```

При выполнении выражения  `throw`, происходит следующее:

-   На основе  `выражения`  создаётся объект исключительной ситуации;
-   Управление передаётся в ближайший обработчик исключений, способный поймать выброшенное исключение;
-   Если подходящий обработчик исключения не найден, программа аварийно завершает свою работу.

Например, эта программа не успеет вывести текст и аварийно прекратит работу, потому что возникающие внутри неё исключения никак не обрабатываются:

```cpp
int main() {
    throw 42; // Выбрасываем значения 42 типа int в качестве объекта исключения
    cout << "Этот текст не будет выведен"s << endl;
}

```

### Обработка исключений в блоке try-catch

Чтобы программа реагировала на исключительные ситуации, код, выбрасывающий исключения, должен выполняться внутри блока  `try`, за которым следуют один или несколько блоков  `catch`:

```cpp
#include <iostream>

using namespace std;

void ThrowSomething() {
    int value;
    cin >> value;
    throw value;
}

int main() {
    // Внутри блока try могут быть выброшены ислючения
    try {
        ThrowSomething();
        cout << "Этот текст не будет выведен"s << endl;
    } catch (int i) {
        // Это обработчик исключений типа int
        cout << "Поймано целое число: "s << i << endl;
    } catch (double d) {
        cout << "Поймано вещественное число: "s << d << endl;
    } catch (...) {
        // В этот обработчик мы попадём, если ни один из предыдущих обработчиков не сработает
        cout << "Поймано исключение неизвестного типа"s << endl;
    }
    cout << "Выход из программы"s << endl;
}

```

Запустим программу и проанализируем её работу:

```
**123**
Поймано целое число: 123
Выход из программы

```

В этот раз выражение  `throw`  располагается в теле функции  `ThrowSomething`, вызванной внутри блока  `try`. Так как этот try-блок содержит блок  `catch`, способный поймать выброшенное исключение типа  `int`, управление будет передано в блок  `catch`. Внутри него пойманный объект исключения будет доступен по имени  `i`. После выхода из блока  `catch`  управление будет передано на ближайшую инструкцию, следующую за блоками  `try-catch`. В данном случае — на вывод строки «Выход из программы».

Обработчик  `catch (...)`  способен поймать любые типы исключений, которые не были пойманы предыдущими блоками  `catch`. Например, если бы мы выбросили исключение типа  `string`  вместо  `int`  или  `double`. Внутри этого обработчика объект пойманного исключения напрямую не доступен, ведь мы не знаем его тип. Поэтому просто сообщаем, что поймали неизвестное исключение.

### Объекты исключительных ситуаций. Стандартные классы исключений

В примерах выше тип  `int`  для наглядности используется как объект, который несёт информацию об исключительной ситуации. На практике в качестве объектов-исключений применяются не примитивные типы, а классы. Это даёт преимущества:

-   Классы позволяют хранить подробную информацию о возникшей проблеме: понятное сообщение об ошибке, которое можно показать пользователю или записать в файл журнала ошибок, числовой код ошибки, название функции или метода, в котором возникла проблема.
-   Разные классы ошибок могут требовать различной реакции, и приложение может использовать для них разные обработчики.

В стандартной библиотеке C++ определены несколько классов стандартных исключений. Они объявлены в файле  `<stdexcept>`. Вот некоторые из них:

-   [`invalid_argument`](https://en.cppreference.com/w/cpp/error/invalid_argument). Исключение связано с некорректным значением аргумента функции или метода.
-   [`domain_error`](https://en.cppreference.com/w/cpp/error/domain_error). Ошибки, связанные с выходом за пределы области определения функции. Например, этот тип ошибок можно использовать, чтобы сообщить о попытке деления на ноль или найти точку пересечения параллельных прямых.
-   [`out_of_range`](https://en.cppreference.com/w/cpp/error/out_of_range). Исключение, связанные с обращением к элементам коллекции за пределами указанного диапазона. Именно это исключение выбрасывается методом  `at`  в коллекциях  `map`  и  `vector`  при попытке обратиться к несуществующему элементу.
-   [`runtime_error`](https://en.cppreference.com/w/cpp/error/runtime_error). Исключения, которые связаны с ошибками, возникающими во время выполнения программы, а не с логикой её работы.
-   [`bad_alloc`](https://en.cppreference.com/w/cpp/memory/new/bad_alloc). Ошибки, сообщающие о нехватке памяти. Например, при добавлении элемента в контейнер.

Применим механизм исключений и перепишем функцию  `SolveQuadraticEquation`:

```cpp
#include <cmath>
#include <iostream>
#include <stdexcept>

using namespace std

pair<double, double> SolveQuadraticEquation(double a, double b, double c) {
    double discriminant = b * b - 4 * a * c;
    if (discriminant < 0) {
        throw domain_error("квадратное уравнение не имеет действительных корней"s);
    }

    double x1 = (-b - sqrt(discriminant)) / (2 * a);
    double x2 = (-b + sqrt(discriminant)) / (2 * a);
    return {x1, x2};
}

```

В отличие от версии с кодом возврата, здесь нет ничего лишнего: функция принимает коэффициенты уравнения и возвращает пару корней уравнения. Если найти решение не удаётся, она вместо результата выбрасывает исключение  `domain_error`, содержащее описание возникшей ошибки.

Для перехвата исключения обернём содержимое тела функции  `main`  в блок  `try`:

```cpp
int main() {
    try {
        cout << "Введите коэффициенты уравнения a*x^2 + b*x + c = 0"s << endl;
        double a, b, c;
        cin >> a >> b >> c;

        pair<double, double> roots = SolveQuadraticEquation(a, b, c);
        cout << "Корни: уравнения "s << a << "*x^2 + "s << b << "*x + "s << c << " = 0"s << endl;
        cout << "  x1="s << roots.first << "; x2="s << roots.second << endl;
    } catch (const domain_error& error) {
        // При помощи метода what() можно получить строковое представление текста ошибки
        cout << "Ошибка: "s << error.what() << endl;
    }
}

```

Структура функции  `main`  изменилась по сравнению с версией, где мы использовали коды возврата. Внутри блока try размещается код, который выполняется, если проблем нет. А обработка исключительной ситуации теперь находится в блоке  `catch`, куда управление попадёт только при возникновении ошибки. Код, выполняющий полезную работу, отделился от кода обработки ошибок. Это улучшило читаемость кода.

Рассмотрим перехват исключений, имеющих тип  `int`  и  `runtime_error`, для которых не заданы особые обработчики, в обработчике  `catch(...)`:

```cpp
#include <iostream>
#include <stdexcept>
#include <string>

using namespace std;

int main() {
    try {
        int x;
        cin >> x;
        if (x == 0) {
            throw invalid_argument("value is zero"s);
        } else if (x == 1) {
            throw domain_error("value is equal to 1"s);
        } else if (x == 2) {
            throw runtime_error("value is equal to 2"s);
        } else {
            throw 42;
        }
    } catch (const domain_error& e) {
        cout << "Domain error: "s << e.what() << endl;
    } catch (const invalid_argument& e) {
        cout << "Invalid argument: "s << e.what() << endl;
    } catch (...) {
        cout << "Unknown error"s << endl;
    }
}

```

Исключения, типы которых — это классы и структуры, ловите по константной ссылке, а не по значению. Вы подробно разберёте данный вопрос, когда будете изучать наследование. А пока просто запомните. Если обработчик исключения не модифицирует пойманный объект исключения, ссылку следует делать константной.

Механизм исключений языка C++ позволяет разделить путь выполнения программы на две части:

-   работающую, если программа выполняется успешно;
-   работающую, когда нормальный ход выполнения невозможен.

Программа всегда реагирует на исключительную ситуацию. Управление передаётся в подходящий обработчик исключительной ситуации. Если обработчик найден не будет, программа аварийно завершит работу.

</details>  

<details>  
<summary>Задание:</summary>

## Задание

Сделайте класс  `Rational`  более надёжным, запретив операцию деления на ноль. Доработайте  `Rational`  так, чтобы при попытке деления дроби на 0 оператором  `/`  либо  `/=`  выбрасывалось исключение  `invalid_argument`. Следующий код иллюстрирует обработку данного типа исключений:

```cpp
int main() {
    try {
        const Rational three_fifth{3, 5};
        const Rational zero;
        cout << three_fifth << " / " << zero << " = " << (three_fifth / zero) << endl;
    } catch (const invalid_argument& e) {
        cout << "Ошибка: "s << e.what() << endl;
    }

    try {
        Rational value{3, 5};
        value /= Rational();
        // Следующая строка не должна выполниться
        cout << value << endl;
    } catch (const invalid_argument& e) {
        cout << "Ошибка: "s << e.what() << endl;
    }
}

```

### Подсказка

Добавьте в оператор  `/=`  проверку делителя на равенство нулю с выбрасыванием соответствующего исключения. Если вы реализовали операцию  `/`  на основе  `/=`, этого будет достаточно для решения задачи. Если нет — добавьте аналогичную проверку и в операцию  `/`.

</details>  
