<details>  
<summary>Введение:</summary>

# Введение

До недавних пор мы обходили стороной тему обработки ошибок. Для простоты обучения всё происходило в идеальном мире, где на вход программе всегда поступают корректные данные, ресурсы у компьютера бесконечны, а операции ввода-вывода всегда завершаются успешно.

В реальном мире программы редко работают в тепличных условиях. Доступная память может закончиться, сетевое соединение оборваться, файл на диске оказаться повреждённым, а пользователь может ошибиться и вместо числа передать программе произвольную строку.

Программа, игнорирующая существование ошибок, едва ли проработает долго. Она быстро дойдёт до состояния, в котором её данные перестанут быть согласованными. Тогда программа либо зависнет, либо совершит неразрешённую операцию, после чего её работа будет прервана операционной системой. Пользователи такой программы тоже будут не в восторге. Особенно если потеряют результаты своей многочасовой работы или безопасность компьютера окажется под угрозой.

Хорошо написанные программы умеют обнаруживать проблемные ситуации, корректно их обрабатывать и продолжать работу. А если ошибка окажется серьёзной, такая программа корректно прервётся, по возможности сохранив пользовательские данные.

В этой теме вы познакомитесь с исключениями — механизмом языка C++, позволяющим сигнализировать о внештатных ситуациях в работе программы и обрабатывать их.

</details>  

<details>  
<summary>Теория:</summary>

# Используем для обработки ошибок коды возврата

В этом уроке разберёмся, как обнаруживать внештатные ситуации в программе и реагировать на них, используя уже знакомые вам средства языка.

Рассмотрим программу, находящую корни квадратного уравнения:

```cpp
#include <cmath>
#include <iostream>
#include <utility>

using namespace std;

// Находим корни квадратного уравнения a*x^2 + b*x + c = 0
pair<double, double> SolveQuadraticEquation(double a, double b, double c) {
    // Находим дискриминант
    double discriminant = b * b - 4 * a * c;

    // Находим корни уравнения
    double x1 = (-b - sqrt(discriminant)) / (2 * a);
    double x2 = (-b + sqrt(discriminant)) / (2 * a);

    return {x1, x2};
}

int main() {
    cout << "Введите коэффициенты уравнения a*x^2 + b*x + c = 0"s << endl;
    double a, b, c;
    cin >> a >> b >> c;
    const pair<double, double> roots = SolveQuadraticEquation(a, b, c);

    cout << "Корни уравнения "s << a << "*x^2 + "s << b << "*x + "s << c << " = 0"s << endl;
    cout << "  x1="s << roots.first << "; x2="s << roots.second << endl;
}

```

Запустим код и проанализируем, что получится. Для некоторых входных данных программа выдаст понятные результаты:

```
Введите коэффициенты уравнения a*x^2 + b*x + c = 0
1 0 -4
Корни уравнения 1*x^2 + 0*x + -4 = 0
  x1=-2; x2=2

```

При других входных данных результаты будут странные:

```
Введите коэффициенты уравнения a*x^2 + b*x + c = 0
1 0 4
Корни уравнения 1*x^2 + 0*x + 4 = 0
  x1=-nan; x2=-nan

```

Дело в том, что во втором случае дискриминант квадратного уравнения оказался отрицательным, а функция  `sqrt`, вычисляющая квадратный корень, для отрицательных чисел возвращает особое значение  `nan`  — «не число». Последующие операции с участием  `nan`  также возвращают «не число». Так или иначе, пользователю стоило бы выдать более осмысленный результат вроде сообщения «Уравнение не имеет действительных корней».

Есть несколько способов решить эту задачу.

**Способ 1 (плохой): нештатную ситуацию обнаруживает вызывающий код.**  Проверку на отрицательность дискриминанта можно было бы разместить внутри функции  `main`  перед вызовом функции  `SolveQuadraticEquation`:

```cpp
int main() {
    cout << "Введите коэффициенты уравнения a*x^2 + b*x + c = 0"s << endl;
    double a, b, c;
    cin >> a >> b >> c;
    if (b * b - 4 * a * c < 0) {
        cout << "Уравнение не имеет действительных корней"s << endl;
    } else {
        const pair<double, double> roots = SolveQuadraticEquation(a, b, c);

        cout << "Корни уравнения "s << a << "*x^2 + "s << b << "*x + "s << c << " = 0"s << endl;
        cout << "  x1="s << roots.first << "; x2="s << roots.second << endl;
    }
}

```

У этого способа несколько серьёзных недостатков. Функция пишется один раз, а применяется, как правило, многократно. Проверки в каждом месте использования  `SolveQuadraticEquation`  приводят к дублированию кода и ошибкам, особенно когда над проектом работает несколько человек. Другая проблема в том, что так мы выносим детали реализации функции за её пределы. Задача функции — упрощать использование фрагмента кода, а не усложнять его. Третья проблема — лишнее вычисление дискриминанта.

**Способ 2 (очень плохой): проверить корни на равенство**  `nan`**, применив функцию  [`isnan`](https://en.cppreference.com/w/cpp/numeric/math/isnan).**  Функция  `isnan`  проверяет, будет ли переданное ей значение  `double`  «‎не-числом», то есть особым значением, показывающим что результат нельзя выразить вещественным числом:

```cpp
int main() {
    cout << "Введите коэффициенты уравнения a*x^2 + b*x + c = 0"s << endl;
    double a, b, c;
    cin >> a >> b >> c;

    pair<double, double> roots = SolveQuadraticEquation(a, b, c);
    if (!isnan(roots.first) && !isnan(roots.second)) {
        cout << "Корни уравнения "s << a << "*x^2 + "s << b << "*x + "s << c << " = 0"s << endl;
        cout << "  x1="s << roots.first << "; x2="s << roots.second << endl;
    } else {
        cout << "Уравнение не имеет действительных корней"s << endl;
    }
}

```

Недостаток этого способа в том, что функция решения уравнения в случае отрицательного дискриминанта выполняет вычисления, не имеющие смысла. Здесь это приводит к появлению результата, равного  `nan`. В более сложных ситуациях игнорирование ошибок может привести к краху программы или порче данных.

**Способ 3: нештатную ситуацию обнаруживает сама функция.**  Проверка на отрицательный дискриминант размещается внутри функции, выполняющей вычисления. Это решение устраняет дублирование кода и сохраняет детали реализации внутри функции. Но возникает проблема: надо сообщить вызывающему коду об ошибке.

Изменим сигнатуру функции так, чтобы она принимала по ссылке дополнительный параметр  `success`  типа  `bool`:

```cpp
pair<double, double> SolveQuadraticEquation(double a, double b, double c, bool& success) {
    double discriminant = b * b - 4 * a * c;
    if (discriminant < 0) {
        success = false;
        // Функция должна вернуть пару значений. Пусть это будут нули
        return {0, 0};
    }
    success = true;

    double x1 = (-b - sqrt(discriminant)) / (2 * a);
    double x2 = (-b + sqrt(discriminant)) / (2 * a);
    return {x1, x2};
}

```

В точке использования нужно завести переменную, передать её в функцию, а потом проверить значение:

```cpp
int main() {
    cout << "Введите коэффициенты уравнения a*x^2 + b*x + c = 0"s << endl;
    double a, b, c;
    cin >> a >> b >> c;

    bool success = false;
    const pair<double, double> roots = SolveQuadraticEquation(a, b, c, success);

    if (success) {
        cout << "Корни уравнения "s << a << "*x^2 + "s << b << "*x + "s << c << " = 0"s << endl;
        cout << "  x1="s << roots.first << "; x2="s << roots.second << endl;
    } else {
        cout << "Уравнение не имеет действительных корней"s << endl;
    }
}

```

Но и у третьего способа есть недостатки:

-   функция стала принимать на один параметр больше;
-   в случае ошибки функция возвращает результат  `{0,0}`. Этот результат — не решение уравнения. Правильная его интерпретация отдаётся на откуп вызывающему коду, который должен предварительно проверить значение выходного параметра  `success`.

Нужен другой способ. Снова изменим сигнатуру функции, чтобы она возвращала значение типа  `bool`, сигнализирующее об успехе, а корни уравнения записывала в параметр, принимаемый по ссылке:

```cpp
bool SolveQuadraticEquation(double a, double b, double c, pair<double, double>& roots) {
    double d = b * b - 4 * a * c;
    if (d < 0) {
        return false;
    }

    double x1 = (-b - sqrt(d)) / (2 * a);
    double x2 = (-b + sqrt(d)) / (2 * a);
    roots = {x1, x2};
    return true;
}

```

В месте использования нужно заранее объявить переменную для сохранения результата и проверить возвращаемое значение функции в условном операторе:

```cpp
int main() {
    cout << "Введите коэффициенты уравнения a*x^2 + b*x + c = 0"s << endl;
    double a, b, c;
    cin >> a >> b >> c;

    pair<double, double> roots;
    if (SolveQuadraticEquation(a, b, c, roots)) {
        cout << "Корни уравнения "s << a << "*x^2 + "s << b << "*x + "s << c << " = 0"s << endl;
        cout << "  x1="s << roots.first << "; x2="s << roots.second << endl;
    } else {
        cout << "Уравнение не имеет действительных корней"s << endl;
    }
}

```

Нельзя сказать, что такой способ намного лучше третьего. Хотя функция не пытается вернуть суррогатное значение, проверка возвращаемого значения возлагается на вызывающий код. А об этом легко забыть:

```cpp
pair<double, double> roots;
// Здесь программист забыл проверить результат вызова функции
SolveQuadraticEquation(a, b, c, roots);
cout << "Корни уравнения "s << a << "*x^2 + "s << b << "*x + "s << c << " = 0"s << endl;
cout << "  x1="s << roots.first << "; x2="s << roots.second << endl;

```

Проблемы с проверкой возвращаемого значения можно частично решить, если пометить функцию  `SolveQuadraticEquation`  специальным атрибутом  `[[nodiscard]]`. Так компилятор будет предупреждать, что возвращаемое значение функции не используется:

```cpp
[[nodiscard]] bool SolveQuadraticEquation(double a, double b, double c, 
                                          pair<double, double>& roots) {
    double d = b * b - 4 * a * c;
    if (d < 0) {
        return false;
    }

    double x1 = (-b - sqrt(d)) / (2 * a);
    double x2 = (-b + sqrt(d)) / (2 * a);
    roots = {x1, x2};
    return true;
}

```

При попытке скомпилировать код увидим предупреждение:

```
warning: ignoring return value of function declared with 'nodiscard' attribute [-Wunused-result]
    SolveQuadraticEquation(a, b, c, roots);
    ^~~~~~~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~

```

Казалось бы, победа! Но этот способ не панацея. В более сложной ситуации предупреждение о неиспользуемом результате выдаваться не будет:

```cpp
bool success;
/*...*/
pair<double, double> roots1, roots2;
success = SolveQuadraticEquation(a1, b1, c1, roots1);

// Информация об ошибке вычисления предыдущего уравнения оказалась утеряна
success = SolveQuadraticEquation(a2, b2, c2, roots2);
if (success) {
    /* обрабатываем roots1 и roots2 */
}

```

Когда пишете надёжные программы, выдающие предсказуемые результаты, позаботьтесь об обработке нештатных ситуаций. Для этих целей подойдут коды возврата и атрибут  `[[nodiscard]]`. Он предупреждает вас о неиспользуемом результате вызова функции или метода.

</details>  

<details>  
<summary>Задание:</summary>

## Задание

Сделайте поисковую систему надёжнее, добавив в методы  `AddDocument`,  `MatchDocument`  и  `FindTopDocuments`  обработку следующих ошибок:

-   Указание в поисковом запросе более чем одного минуса перед словами, которых не должно быть в документах, например:  `кот --пушистый`. В середине слов минусы разрешаются, например:  `иван-чай`.
-   Отсутствие в поисковом запросе текста после символа «минус», например  `кот -`.
-   Наличие спецсимволов — то есть символов с кодами в диапазоне от 0 до 31 включительно — в тексте документов и поискового запроса.
-   Попытка добавить документ с отрицательным id.
-   Попытка добавить документ с id, совпадающим с id документа, который добавился ранее.

Обновите сигнатуру методов  `MatchDocument`  и  `FindTopDocuments`, чтобы они сообщали об успехе выполнения возвратом значения типа  `bool`, а результаты поиска и сопоставления документов возвращали через выходной параметр  `result`, принимаемый по ссылке. В случае, если методы выполнились с ошибкой, основная функция не должна выводить результаты их работы в стандартный поток вывода.

Метод  `AddDocument`  должен возвращать значение типа  `bool`: в случае успеха —  `true`, а если запрос неудачный —  `false`. Чтобы не забыть проверить результат этих методов, пометьте их атрибутом  `[[nodiscard]]`.

Также добавьте метод  `GetDocumentId`, позволяющий получить идентификатор документа по его порядковому номеру. В случае, если порядковый номер документа выходит за пределы от  `[0; кол-во документов)`, метод должен вернуть значение  `SearchServer::INVALID_DOCUMENT_ID`:

```cpp
class SearchServer {
public:
    // Defines an invalid document id
    // You can refer to this constant as SearchServer::INVALID_DOCUMENT_ID
    inline static constexpr int INVALID_DOCUMENT_ID = -1;
    ...
    [[nodiscard]] bool AddDocument(int document_id, const string& document, DocumentStatus status,
                                   const vector<int>& ratings) {
        ...
    }

    template <typename DocumentPredicate>
    [[nodiscard]] bool FindTopDocuments(const string& raw_query, DocumentPredicate document_predicate,
                                        vector<Document>& result) const {
        ...
    }

    [[nodiscard]] bool FindTopDocuments(const string& raw_query, DocumentStatus status,
                                        vector<Document>& result) const {
        ...
    }

    [[nodiscard]] bool FindTopDocuments(const string& raw_query, vector<Document>& result) const {
        ...
    }

    [[nodiscard]] bool MatchDocument(const string& raw_query, int document_id,
                                     tuple<vector<string>, DocumentStatus>& result) const {
        ...
    }

    int GetDocumentId(int index) const {
        ...
    }
    ...
};

```

Пример использования класса поисковой системы с обновлённым интерфейсом:

```cpp
void PrintDocument(const Document& document) {
    cout << "{ "s
         << "document_id = "s << document.id << ", "s
         << "relevance = "s << document.relevance << ", "s
         << "rating = "s << document.rating << " }"s << endl;
}

int main() {
    SearchServer search_server("и в на"s);

    // Явно игнорируем результат метода AddDocument, чтобы избежать предупреждения
    // о неиспользуемом результате его вызова
    (void) search_server.AddDocument(1, "пушистый кот пушистый хвост"s, DocumentStatus::ACTUAL, {7, 2, 7});

    if (!search_server.AddDocument(1, "пушистый пёс и модный ошейник"s, DocumentStatus::ACTUAL, {1, 2})) {
        cout << "Документ не был добавлен, так как его id совпадает с уже имеющимся"s << endl;
    }

    if (!search_server.AddDocument(-1, "пушистый пёс и модный ошейник"s, DocumentStatus::ACTUAL, {1, 2})) {
        cout << "Документ не был добавлен, так как его id отрицательный"s << endl;
    }

    if (!search_server.AddDocument(3, "большой пёс скво\x12рец"s, DocumentStatus::ACTUAL, {1, 3, 2})) {
        cout << "Документ не был добавлен, так как содержит спецсимволы"s << endl;
    }

    vector<Document> documents;
    if (search_server.FindTopDocuments("--пушистый"s, documents)) {
        for (const Document& document : documents) {
            PrintDocument(document);
        }
    } else {
        cout << "Ошибка в поисковом запросе"s << endl;
    }
}

```

### Подсказка

Внесите необходимые изменения в методы парсинга поискового запроса и документа, чтобы они могли сообщить вызываемому коду о наличии ошибки возвратом булевых значений.

Чтобы проверить, что слово не содержит спецсимволы, добавьте в класс поисковой системы статический метод  `IsValidWord`, проверяющий при помощи стандартного алгоритма  [`none_of`](https://en.cppreference.com/w/cpp/algorithm/all_any_none_of), что  **ни один из**  символов строки не содержит символов с кодами от 0 до пробела (не включая пробел).

```cpp
class SearchServer {
    ...
private:
    ...
    static bool IsValidWord(const string& word) {
        // A valid word must not contain special characters
        return none_of(word.begin(), word.end(), [](char c) {
            return c >= '\0' && c < ' ';
        });
    }
    ...
};
```

</details>  
