<details>  
<summary>Теория:</summary>

# Раскрутка стека. Исключения в конструкторе и деструкторе

В этом уроке вы узнаете, что именно происходит при выбрасывании исключения в программе. А ещё изучите особенности работы исключений в конструкторе и деструкторе объекта.

### Раскрутка стека

В прошлом уроке вы узнали, что при выполнении выражения  `throw`  управление передаётся в ближайший подходящий обработчик исключения. Чтобы проследить, как выбрасывание исключений влияет на жизненный цикл созданных в программе объектов, создадим класс  `Greeter`. Он выводит сообщения в своём конструкторе и деструкторе:

```cpp
class Greeter {
public:
    Greeter(const string& name)
        : name_(name)  // Сохраняем name_ внутри
    {
        cout << "Hello, "s << name_ << endl;
    }

    ~Greeter() {
        cout << "Goodbye, "s << name_ << endl;
    }

private:
    string name_;
};

void Test() {
    Greeter a{"Test-A"s};
    Greeter b{"Test-B"s};
    cout << "Throwing an exception"s << endl;
    throw runtime_error("oops");
}

int main() {
    Greeter greeter_main{"main"s};
    try {
        Greeter outer{"outer"s};

        try {
            Greeter inner{"inner"s};
            Test();
        } catch (const invalid_argument& e) {
            cout << "invalid_argument: "s << e.what() << endl;
        }
        cout << "This text will not be printed"s << endl;
    } catch (const runtime_error& e) {
        cout << "runtime_error: "s << e.what() << endl;
    }
    cout << "------"s << endl;
}

```

Программа выведет:

```
Hello, main
Hello, outer
Hello, inner
Hello, Test-A
Hello, Test-B
Throwing an exception
Goodbye, Test-B
Goodbye, Test-A
Goodbye, inner
Goodbye, outer
runtime_error: oops
------
Goodbye, main

```

При выбрасывании исключения происходит раскрутка стека: программа последовательно покидает вложенные блоки, пока не достигнет начала блока  `try`. Если в текущем блоке  `try`  будет найден подходящий блок  `catch`, управление передаётся в него. В противном случае процесс будет продолжаться. Во время раскрутки стека вызываются деструкторы всех локальных переменных каждого блока в порядке, обратном вызову конструкторов.

В нашем случае обработчик исключения, способный поймать  `runtime_error`, находится во внешнем блоке  `try`. Первыми будут вызваны деструкторы объектов внутри функции  `Test`. Вызваны они будут в порядке, обратном их конструированию: сначала деструктор  `b`, потом  `a`. Затем — деструктор объекта  `inner`  из внутреннего блока  `try`, а после — деструктор объекта  `outer`  из внешнего блока  `try`. Следом выполнится обработчик пойманного исключения. В конце, перед самым выходом из функции  `main`, произойдёт разрушение переменной  `greeter_main`.

Таким образом, C++ гарантирует вызов деструкторов для всех созданных объектов при выходе из их области видимости, какова бы ни была причина выхода: обычное выполнение программы, возврат из функции по  `return`  либо выбрасывание исключения.

Детерминированный механизм вызова деструкторов — одна из сильных сторон C++. Он упрощает управление ресурсами. Если каждым ресурсом программы владеет некоторый класс, то при выходе из области видимости переменной этого класса гарантированно произойдёт вызов деструктора. Деструктор автоматически освободит ресурс.

### Выбрасывание исключения в конструкторе и деструкторе

Вы уже знаете, что в C++ жизненный цикл объекта начинается с вызова конструктора. Его основная задача — инициализировать начальное состояние объекта. После окончания работы конструктора инициализация объекта считается завершённой. При выходе из области видимости объекта происходит его деинициализация. Она сопровождается вызовом деструктора. Посмотрим, что происходит на этих этапах при выбрасывании исключения.

Иногда конструктор не может создать объект, находящийся в согласованном состоянии. Например, при попытке создать обыкновенную дробь с нулевым знаменателем. Если конструктор не может выполнить свою задачу, откажитесь от конструирования такого объекта, выбросив в конструкторе исключение. При этом нужно иметь в виду особенности, специфичные для языка C++.

Если во время работы конструктора выбрасывается исключение, инициализация объекта считается незавершённой. При этом деструктор такого объекта вызван не будет, что логично: объект фактически не создан. Зато будут вызваны деструкторы тех его полей, которые к этому моменту уже сконструированы. Рассмотрим на примере:

```cpp
#include <iostream>
#include <stdexcept>
#include <string>

using namespace std;

class Greeter {
public:
    Greeter(const string& name)
        : name_(name)  // Сохраняем name_ внутри
    {
        cout << "Hello, "s << name_ << endl;
    }

    ~Greeter() {
        cout << "Goodbye, "s << name_ << endl;
    }

private:
    string name_;
};

class Thrower {
public:
    Thrower()
        : field_("field"s) // передаём параметры конструктору поля field_
    {
        cout << "Thrower()"s << endl;
        // Исключение, выброшенное здесь, будет поймано за пределами конструктора
        throw runtime_error("Oops"s);
    }

    ~Thrower() {
        cout << "~Thrower()"s << endl;
    }

private:
    Greeter field_;
};

int main() {
    try {
        Thrower t;
    } catch (const runtime_error& e) {
        cout << e.what() << endl;
    }
}

```

Программа выведет:

```
Hello, field
Thrower()
Goodbye, field
Oops

```

Сначала будет сконструировано поле  `field_`  класса  `Thrower`. Об этом говорит вывод  `Hello, field`. Затем при выполнении тела конструктора  `Thrower`  будет выведена строка  `Thrower()`  и выброшено исключение, обработчик которого находится за пределами конструктора. В процессе раскрутки стека вызовется деструктор сконструированного поля  `field_`, что подтверждает вывод строки  `Goodbye, field`. А вот деструктор  `Thrower`  вызван не будет, так как конструирование объекта не было завершено.

### Выбрасывание исключения в деструкторе

По умолчанию деструкторы в C++ не должны выбрасывать исключения. Если нарушить это правило, программа аварийно завершится. Такое ограничение обеспечивает корректную работу механизма раскрутки стека.

В коде ниже деструктор класса  `ThrowsInDestructor`  бросает исключение, которое в самом деструкторе никак не обрабатывается. В результате при выбрасывании исключения программа аварийно завершит работу:

```cpp
#include <iostream>
#include <stdexcept>
#include <string>

using namespace std;

class ThrowsInDestructor {
public:
    ~ThrowsInDestructor() {
        cout << "See you"s << endl;
        throw runtime_error("Oops"s);
    }
};

int main() {
    try {
        ThrowsInDestructor x;
    } catch (...) {
        // Этот код не будет вызван, так как выбрасывание исключения в деструкторе
        // класса ThrowsInDestructor приведёт к аварийному завершению работы программы
        cout << "Exception was caught"s;
    }
}

```

Современные компиляторы умеют сообщать о таких проблемах предупреждением:

```
warning: '~ThrowsInDestructor' has a non-throwing exception specification but can still throw [-Wexceptions]
        throw runtime_error("Oops"s);
        ^

```

Если в деструкторе есть код, который может выбросить исключение, этот код помещают внутрь блока  `try/catch`:

```cpp
// Удаляет файл. В случае ошибки может выбросить исключение
void DeleteFile(const string& path) {
    // ...
}

// Управляет временным файлом на диске. При своём разрушении удаляет временный файл
class TemporaryFile {
public:
    explicit TemporaryFile(const string& path)
        : path_(path) {
    }

    const string& GetPath() const {
        return path_;
    }

    ~TemporaryFile() {
        int retries = 10;
        while (retries > 0) {
            try {
                DeleteFile(path_);
                break;
            } catch (...) {
                // Возможно, повезёт на следующей попытке,
                // если ошибка удаления файла была временной. 
                // Например, в момент удаления файл проверялся антивирусом 
                --retries;
            }
        }
    }

private:
    string path_;
};

int main() {
    // Для работы использует
    TemporaryFile tmpFile("temp.txt"s);

    /* Что-нибудь делаем с этим файлом */

    // При выходе из функции деструктор TemporaryFile постарается удалить файл с диска
}

```

Раскрутка стека — полезный механизм, который за счёт детерминированного вызова деструкторов объектов освобождает ресурсы системы при возникновении исключительных ситуаций. Выбрасывание исключения в конструкторе — стандартный способ уведомить об ошибках, препятствующих созданию жизнеспособного объекта. А вот деструкторы выбрасывать исключений не должны.

</details>  

<details>  
<summary>Задание:</summary>

## Задание

Класс  `Rational`  уже умеет сообщать об ошибках деления на ноль, но всё ещё разрешает создавать дроби с нулевым знаменателем. Доработайте конструктор класса  `Rational`  так, чтобы при попытке сконструировать дробь с нулевым знаменателем, выбрасывалось исключение типа  `domain_error`.

```cpp
int main() {
    try {
        // При попытке сконструировать дробь с нулевым знаменателем
        // должно выброситься исключение domain_error
        const Rational invalid_value{1, 0};
        // Следующая строка не должна выполниться
        cout << invalid_value << endl;
    } catch (const domain_error& e) {
        cout << "Ошибка: "s << e.what() << endl;
    }
}

```

### Подсказка

Добавьте проверку знаменателя на равенство нулю с выбрасыванием соответствующего исключения в параметризованный конструктор, принимающий числитель и знаменатель дроби. Это сделает невозможным конструирование дроби с нулевым знаменателем.

</details>  
