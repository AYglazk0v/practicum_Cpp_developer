<details>  
<summary>Теория+тестирование:</summary>

# Деструкторы и время жизни объекта

В прошлых уроках вы научились работать с конструктором — особым методом класса. Его основная задача — инициализация объекта, после которой все поля объекта находятся в согласованном состоянии. Конструктор объекта вызывается один раз — в тот момент, когда объявляется переменная класса:

```cpp
// В момент объявления переменной вызывается конструктор класса string
string name = "Hello"s;

```

На протяжении всей жизни объекта мы можем с ним взаимодействовать через публичные методы класса. Каждый вызов публичного метода может переводить объект в новое состояние, изменяя значения его полей, либо оставлять объект в прежнем состоянии. Методы, которые не влияют на состояние объекта, мы объявляем константными. Константные методы гарантируют, что состояние объекта при их вызове не изменится. Это позволяет вызывать их у константных объектов.

Но объекты программы не живут вечно. Рано или поздно их жизнь подходит к концу. Поэтому у класса есть ещё один специальный метод — деструктор.

### Знакомство с деструктором

Деструктор автоматически вызывается в конце жизни объекта. Имя деструктора совпадает с именем класса. Разница в том, что перед именем деструктора ставится символ  `~`  (тильда), а параметры не указываются:

```cpp
class SomeClass {
public:
    // Это деструктор
    ~SomeClass() {
    }
};

```

У класса бывает несколько конструкторов, задающих различные способы инициализации объекта. Но деструктор у класса может быть только один. Основная задача деструктора — освободить ресурсы, которые объект использовал на протяжении цикла жизни. Например:

-   освободить память, динамически выделяемую с использованием низкоуровневых функций языка или операционной системы;
-   закрыть открытые файлы и сетевые соединения.

Знакомые вам классы стандартных контейнеров  `string`,  `vector`,  `map`  и  `set`  динамически запрашивают память у системы, когда вы добавляете в них элементы, и освобождают ее, когда вы элементы удаляете. Деструкторы этих коллекций освобождают память от оставшихся элементов, которые вы не удалили явно:

```cpp
int main() {
    vector<int> strings;
    for (int i = 0; i < 100; ++i) {
        strings.push_back(i);
    }
}

```

Здесь в  `vector`  добавили сотню элементов. Но беспокоиться о том, чтобы освободить занимаемую ими память, не стó‎ит. Деструктор класса  `vector`  будет вызван автоматически и сделает это за нас.

Писать собственный деструктор при повседневном программировании на C++ нужно довольно редко, особенно если пользуетесь классами стандартной библиотеки C++ и других популярных библиотек вроде  [boost](http://boost.org/). Эти библиотеки созданы опытными программистами и предоставляют удобные классы, которые автоматизируют управление памятью и другими ресурсами.

Свой деструктор понадобится при разработке классов, использующих низкоуровневые функции операционной системы и компоненты, написанные на других языках. В следующих спринтах вы встретитесь с подобными задачами.

### Время жизни объекта

Чтобы узнать, в какой момент вызывается деструктор, рассмотрим класс  `Greeter`, выводящий сообщения в своём конструкторе и деструкторе:

```cpp
class Greeter {
public:
    Greeter(const string& name)
        : name_(name) 
    {
        cout << "Hello, "s << name_ << "!"s << endl;
    }

    ~Greeter() {
        // Поля класса внутри деструктора еще не уничтожены, и к ним можно обращаться
        cout << "Goodbye, "s << name_ << "!"s << endl;
    }
private:
    string name_;
};

```

Создадим этот объект внутри цикла по массиву имён:

```cpp
int main() {
    vector<string> names = {
        "Ivan"s,
        "Vladimir"s,
    };
    for (const string& name : names) {
        cout << "Begin"s << endl;
        Greeter greeter(name);
        cout << "End"s << endl;
    }
}

```

Запустим программу и увидим следующее:

```
Begin
Hello, Ivan!
End
Goodbye, Ivan!
Begin
Hello, Vladimir!
End
Goodbye, Vladimir!

```

В начале каждой итерации цикла  `for`  выведется текст  `Begin`. Затем будет вызван конструктор по умолчанию, выводящий приветствие. Потом выведется текст  `End`, и только после последней инструкции будет вызван деструктор, выводящий прощание. На следующей итерации цикла процесс повторится снова.

Итак, в C++ для деинициализации используется деструктор — метод класса, вызываемый в конце жизненного цикла объекта. Время жизни переменной в C++ ограничено блоком, внутри которого она объявлена. При выходе из блока происходит вызов деструкторов объявленных в нём переменных. Деструкторы объектов вызываются в порядке, обратном конструированию объектов.

В других ситуациях — например, для полей класса или глобальных переменных — порядок и время вызова конструкторов и деструкторов можно выяснить самостоятельно. Просто напишите класс с выводом в конструкторе и деструкторе.Теперь изменим код функции  `main`, добавив в него ветвление:

```cpp
#include <cmath>
#include <iostream>

using namespace std;

/* код класса Greeter */

int main() {
    double n;
    cin >> n;
    
    Greeter greeter1("1"s);
    if (n < 0) {
        cout << n << " is negative"s << endl;
        return 0;
    } else {
        Greeter greeter2("2"s);
        cout << "sqrt("s << n << ") = "s << sqrt(n) << endl;
    }
    Greeter greeter3("3"s);
}

```

Запустим программу и попробуем ввести число -10:

```
**-10**
Hello, 1!
-10 is negative
Goodbye, 1!

```

После ввода отрицательного числа был вызван конструктор класса  `Greeter`, выводящий строчку  `"Hello, 1!".`  Затем поток выполнения попадёт внутрь положительного условия  `if`, где будет выведено сообщение о невозможности извлечения корня. Следом оператор  `return 0`  выполнит выход из функции. На этом время жизни переменной  `greeter1`  закончится, будет вызван её деструктор. Он выведет строку  `Goodbye, 1!`.

Если же запустить программу и ввести неотрицательное число, вывод программы изменится:

```
9
Hello, 1!
Hello, 2!
sqrt(9) = 3
Goodbye, 2!
Hello, 3!
Goodbye, 3!
Goodbye, 1!

```

Поток выполнения программы выглядит так:

ВСТАВИТЬ ИЗОБРАЖЕНИЕ!

Деструктор переменной  `greeter2`  вызван сразу после вывода квадратного корня, то есть при выходе из блока  `else`, ограничивающего область видимости этой переменной. Деструктор переменной  `greeter3`  вызван раньше деструктора  `greeter1`.

В C++ время жизни переменной ограничивается блоком, где она объявлена. При этом переменные, которые в этом блоке объявлены раньше, будут разрушены в последнюю очередь. То есть порядок разрушения объектов обратен порядку их конструирования. Теперь попробуем передать  `Greeter`  в качестве параметра функции:

```cpp
void Fn(Greeter g) {
    Greeter g1("function body"s);
}

int main() {
    Fn({"function parameter"s});
}

```

Вывод программы:

```
Hello, function parameter!
Hello, function body!
Goodbye, function body!
Goodbye, function parameter!

```

При вызове функции  `Fn`  будет сконструирован объект  `Greeter`  и передан в качестве аргумента функции. Его время жизни будет дольше времени жизни объекта, объявленного внутри тела функции. Опять-таки, объект, созданный раньше, будет разрушен позже.

Похожая картина будет наблюдаться и при возврате из функции. Рассмотрим вызов функции, возвращающей объект  `Greeter`.

```cpp
Greeter ReturnGreeter() {
    return {"result"s};
}

int main() {
    Greeter result = ReturnGreeter();
    Greeter body("body"s);
}

```

Вывод программы:

```
Hello, result!
Hello, body!
Goodbye, body!
Goodbye, result!

```

Сначала будет создан объект  `Greeter`  и возвращён из функции, затем он будет сохранен переменной  `result`, до того как будет создана переменная  `body`. И снова разрушение этих объектов произойдёт в противоположном порядке.Теперь попробуем просто вызвать  `ReturnGreeter`, но не будем сохранять результат ни в какой переменной:

```cpp
Greeter ReturnGreeter() {
    return {"result"s};
}

int main() {
    ReturnGreeter();
    Greeter body("body"s);
}

```

В этот раз вывод программы изменится:

```
Hello, result!
Goodbye, result!
Hello, body!
Goodbye, body!

```

В отличие от предыдущего примера мы не сохранили результат вызова функции в переменной. Теперь у возвращённого временного объекта нет имени, по которому к нему можно обратиться, поэтому он будет разрушен сразу после окончания инструкции вызова  `ReturnGreeter();`.

----------

### Задание для храбрых сердцем

Определите время жизни глобальных переменных и сравните его со временем выполнения функции  `main`. В каком порядке происходит инициализация и деинициализация глобальных переменных?

----------

----------

Подсказка: объявите несколько переменных типа  `Greeter`  вне тела функции main и внутри нее и проанализируйте выходные данные программы. Сделайте выводы.

----------

----------

### Задание для ещё более храбрых сердцем

Определите время жизни и порядок инициализации и деинициализации полей классов и структур. Сравните время жизни полей класса со временем выполнения тела конструктора и деструктора.

Как влияет порядок перечисления полей в списке инициализации конструктора на последовательность вызова их конструкторов и деструкторов?

Как влияет порядок объявления полей внутри класса на последовательность вызова их конструкторов и деструкторов?

----------

Подсказка: объявите класс с несколькими полями типа  `Greeter`, инициализированными различными строками. Проанализируйте, как меняется или не меняется вывод программы при изменении порядка объявления полей внутри класса и их перечислении в списке инициализации конструктора.

</details>  


<details>  
<summary>Ответы:</summary>

# Ответы на задания

Что выведет в output следующая программа? Введите ответ без пробелов.

```cpp
#include <iostream>
#include <string>

using namespace std;

class Cat {
public:
    Cat(const string& name)
        : name_(name) {
        cout << "c-"s << name_;
    }
    void Meow() const {
        cout << "-meow-"s;
    }
    ~Cat() {
        cout << "d-"s << name_;
    }
private:
    string name_;
};

int main() {
    Cat cat("tom"s);
    cat.Meow();
}

```

----------

с-tom-meow-d-tom

----------

Что выведет следующая программа? Введите ответ в одну строку без пробелов:

```cpp
#include <iostream>
#include <string>

using namespace std;

class Fruit {
public:
    Fruit(const string& name)
        : name_(name) {
        cout << "+"s << name_;
    }
    ~Fruit() {
        cout << "-"s << name_;
    }
private:
    string name_;
};

int main() {
    Fruit mango{"mango"s};

    for (string s : {"apple"s, "banana"s}) {
        Fruit fruit{s};
        if (s.length() % 2 == 0) {
            Fruit another_fruit{s};
            cout << "?"s;
        }
        cout << "!"s;
    }
}

```

----------

+mango+apple!-apple+banana+banana?-banana!-banana-mango

----------

Что выведет следующая программа? Введите ответ в одну строчку без пробелов.

```cpp
#include <iostream>
#include <string>

using namespace std;

class Tree {
public:
    Tree() {
        cout << "+tree"s;
    }
    ~Tree() {
        cout << "-tree"s;
    }
};

class House {
public:
    House() {
        cout << "+house"s;
    }
    ~House() {
        cout << "-house"s;
    }
};

House BuildHouse(Tree tree) {
    return House{};
}

int main() {
    House house = BuildHouse({});
    cout << "~life"s;
}

```

----------

+tree+house-tree~life-house

</details>  
