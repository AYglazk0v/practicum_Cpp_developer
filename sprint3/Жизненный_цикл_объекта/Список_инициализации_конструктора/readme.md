<details>  
<summary>Теория:</summary>


# Список инициализации конструктора

В предыдущих уроках вы узнали, как создавать для класса конструктор по умолчанию и параметризованный конструктор. В этом уроке научитесь их правильно использовать для инициализации отдельных переменных, а также полей классов и структур.

### Вызов параметризованного конструктора

Когда вызываем функцию и возвращаем значение из неё, компилятор знает и типы аргументов, и тип возвращаемого значения. Поэтому имя класса перед фигурными скобками можно опустить при условии, что код останется понятным:

```cpp
Rational AddRationals(Rational r1, Rational r2) {
    int numerator = r1.Numerator() * r2.Denominator() + r2.Numerator() * r1.Denominator();
    int denominator = r1.Denominator() * r2.Denominator();

    // Компилятор знает, что функция возвращает Rational, и неявно
    // вызывает соответствующий конструктор
    return {numerator, denominator};
    // Эта запись в данном контексте аналогична:
    // return Rational{numerator, denominator};
}

int main() {
    // Компилятор знает, что функция AddRationals принимает аргументы типа Rational
    // и конструирует дроби 1/6 и 1/3
    Rational sum = AddRationals({1, 6}, {1, 3});
}

```

Здесь инструкция  `return {numerator, denominator}`  расположена близко к заголовку функции, и читатель видит тип возвращаемого значения. Поэтому компактную запись можно использовать вместо  `return Rational{numerator, denominator};`. Имя функции  `AddRationals`  чётко показывает, что именно она делает, и вызов  `AddRationals({1, 6}, {1, 3})`  будет понятен.

Краткую форму вызова конструктора используйте только когда у неё нет неоднозначного толкования. В остальных случаях вызывайте конструктор явно.

### Вызов параметризованного конструктора при композиции

Каждый раз, когда создаёте классы и структуры с другими классами и структурами внутри, имеете дело с композицией. Композиция — способ писать новые классы и структуры путём включения уже имеющихся. Рассмотрим структуру  `RationalPoint`, которая задаёт координаты точки на плоскости, используя композицию рациональных чисел:

```cpp
struct RationalPoint {
    Rational x;
    Rational y;
};

```

Чтобы задать точку, можно передать в качестве координат уже имеющиеся переменные типа  `Rational`  или указать координаты напрямую:

```cpp
 int main() {
    // Допустимые способы объявления переменной типа Rational
    const Rational x1{7, 8};
    const Rational y1(3, 4);

    // Инициализируем поля структуры при помощи имеющихся переменных
    RationalPoint p1 = {x1, y1};

    // Инициализируем поля структуры явным образом
    RationalPoint p0 = {
        {2, 3},
        {5, 6},
    };

    // Совмещаем разные способы инициализации полей структуры
    const RationalPoint p2{x2, {7, 8}};
}

```

### Списки инициализации

С инициализацией полей структур всё довольно просто: поля у структуры публичные, поэтому можем свободно задавать их значения. А у классов поля приватные и защищены от доступа извне. Поэтому инициализировать их сложнее. Рассмотрим на примере классов  `Cat`  и  `Witch`:

```cpp
class Cat {
public:
    Cat(const string& name) {
        name_ = name;
    }
    string GetName() const {
        return name_;
    }
private:
    string name_;
};

class Witch {
public:
    Witch(const string& catName) {
        cat_ = Cat{catName}; // Пытаемся задать значение полю cat_
    }
private:
    Cat cat_;
};

int main() {
    Witch hermione{"Живоглот"s};
}

```

Попытаемся скомпилировать код и столкнёмся с ошибкой:

```
error: constructor for 'Witch' must explicitly initialize the member 'cat_' which does not have a default constructor
    Witch(const string& catName) {
    ^

```

Компилятор сообщает: конструктор класса  `Witch`  должен явно инициализировать поле  `cat_`, у которого нет конструктора по умолчанию. Причём инициализация должна завершиться ещё до выполнения тела конструктора. Только так в теле конструктора можно будет безопасно обращаться к полям класса. Исправим ошибку:

```cpp
class Witch {
public:
    Witch(const string& catName) {
        // Чтобы безопасно использовать поле cat_ внутри конструктора, 
        // инициализируем его ещё до выполнения тела конструктора Witch
        cout << "Моего кота зовут "s << cat_.GetName() << endl;
    }
private:
    Cat cat_;
};

```

В C++ для неявной инициализации полей класса применяют конструктор по умолчанию. Поля, у которых его нет, инициализируйте явно внутри списка инициализации конструктора.

Чтобы написать список инициализации, поставьте двоеточие после скобки, закрывающей список параметров конструктора, и перечислите через запятую имена полей с их значениями внутри скобок в формате  `имя_поля_1(значение_поля_1), имя_поля_2(значение_поля), ...`. Значениями полей могут быть параметры конструктора, выражения и константы. Перепишем конструкторы классов  `Cat`  и  `Witch`:

```cpp
class Cat {
public:
    Cat(const string& name)
        // задаём значение поля name_, копируя в него аргумент конструктора
        : name_(name) 
    {
    }
    string GetName() const {
        return name_;
    }
private:
    string name_;
};

class Witch {
public:
    Witch(const string& catName)
        // Передаём параметр конструктору поля cat_
        : cat_(catName) 
    {
        cout << "Моего кота зовут "s << cat_.GetName() << endl;
    }
private:
    Cat cat_;
};

```

Список инициализации конструктора служит для инициализации полей класса до выполнения тела конструктора. Старайтесь всегда задавать значения полей класса в списке инициализации конструктора, а не в его теле. Тогда программа не будет выполнять двойную работу: вызывать у поля конструктор по умолчанию, а потом перезаписывать его значение через присваивание. В списке инициализации сразу вызовется нужный параметризованный конструктор.
</details>  


<details>  
<summary>Задание:</summary>

Перепишите конструкторы класса  `Rational`, чтобы инициализация его полей выполнялась в списках инициализации.

### Подсказка

Вы сможете переписать конструкторы без подсказки.

</details>  
