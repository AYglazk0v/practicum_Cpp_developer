<details>  
<summary>Теория:</summary>

# Параметризованный конструктор

Вы научились задавать для полей объекта значение по умолчанию. Так все данные объекта после его создания будут согласованными.

Но используя класс  `Rational`, сталкиваемся с проблемами.

-   Код, который выполняет инициализацию, слишком громоздкий. В нём целых три строки:

```cpp
Rational x;
// Задаём для дроби значение 1/3
x.SetNumerator(1);
x.SetDenominator(3);

```

-   Другую проблему рассмотрим на примере. Объявим константную переменную типа  `Rational`, равную  `1/3`:

```cpp
const Rational scale;
// Ошибка компиляции: 'this' argument to member function 'SetNumerator' 
// has type 'const Rational', but function is not marked const
scale.SetNumerator(1);
// Здесь будет аналогичная ошибка
scale.SetDenominator(3);

```

Компилятор напоминает, что у константного объекта можно вызывать только константные методы. Методы  `SetNumerator`  и  `SetDenominator`  предназначены для изменения дроби, поэтому мы и не можем их вызвать — константные объекты изменять нельзя.

Эти проблемы решит параметризованный конструктор. Он принимает один или более параметров:

```cpp
class Rational {
public:
    // Явно сообщаем компилятору, что в этом классе нужно создать конструктор по умолчанию
    Rational() = default;

    // Параметризованный конструктор
    Rational(int numerator, int denominator) {
        numerator_ = numerator;
        denominator_ = denominator;
    }

    int Numerator() const {
        return numerator_;
    }

    int Denominator() const {
        return denominator_;
    }

private:
    // Задаём значения по умолчанию для числителя и знаменателя
    int numerator_ = 0;
    int denominator_ = 1;
};

```

Если в классе объявлен параметризованный конструктор, конструктор по умолчанию для этого класса сгенерирован не будет. Наличие конструктора с параметрами как бы сообщает компилятору: «‎Этот класс требует особой инициализации». Если конструктор по умолчанию всё-таки нужен, вы можете написать его сами либо попросить компилятор. Для этого вместо тела конструктора укажите  `= default`  и задайте полям значения по умолчанию.

Чтобы использовать параметризованный конструктор, передадим ему параметры в скобках после имени переменной:

```cpp
int main() {
    const Rational scale(1, 3);

    cout << scale.Numerator() << "/"s << scale.Denominator() << endl;
}

```

Применив параметризованный конструктор, мы не только избавились от многословности при объявлении объекта, но и смогли задать начальное состояние константных объектов. Часто в классах делают несколько конструкторов, задающих различные способы инициализации объектов.

</details>  


<details>  
<summary>Задание 1:</summary>

## Задание 1

Разработайте для представленного класса  `Animal`  параметризованный конструктор, который позволяет задать тип и кличку животного и имя хозяина.

### Подсказка

Добавьте конструктор, принимающий параметры  `type`,  `name`  и  `owner_name`. Используйте их для полей  `type_`,  `name_`  и  `owner_name_`.

</details>  

<details>  
<summary>Задание 2:</summary>

## Задание 2

Многие стандартные классы языка C++ имеют несколько конструкторов. Вот, например, несколько способов создания экземпляров классов  `string`  и  `vector`:

```cpp
#include <string>
#include <vector>

using namespace std;

int main() {
    string empty; // пустая строка
    string greeting("hello, c++"); // строка "hello, c++"
    string aaaaa(5, 'A'); // строка "AAAAA"
    string cpp(greeting, 7, 3); // строка "c++"

    vector<string> empty_vec;                 // {}
    vector<string> four_empty_strings(4);     // {"", "", "", ""|
    vector<string> three_greetings(3, "Hi!"s); // {"Hi!", "Hi!", "Hi!"} 
}

```

В дополнение к конструктору по умолчанию для класса  `Rational`  разработайте такие параметризованные конструкторы:

-   Конструктор с одним параметром, создающий дробь из целого числа. Числитель такой дроби равен переданному целому числу, а знаменатель — единице.
-   Конструктор, который принимает два параметра типа  `int`, задающих значение числителя и знаменателя, а затем приводит дробь к несократимому виду с положительным знаменателем. Например, дробь  `6/15`  должна быть преобразована в  `2/5`, а дробь  `8/(-6)`  — в  `(-4)/3`. Гарантируется, что знаменатель не равен нулю.

Эти конструкторы сделают возможными такие действия над обыкновенными дробями:

```cpp
Rational Add(Rational r1, Rational r2) {
    int numerator = r1.Numerator() * r2.Denominator() + r2.Numerator() * r1.Denominator();
    int denominator = r1.Denominator() * r2.Denominator();

    // Создаём и возвращаем дробь с заданным числителем и знаменателем
    return Rational{numerator, denominator};
}

int main() {
    Rational zero;     // Дробь 0/1 = 0
    const Rational seven(7); // Дробь 7/1 = 7
    const Rational one_third(1, 3); // Дробь 1/3

    vector<Rational> numbers;
    numbers.push_back(Rational{7, 8});

    // Следующие 2 строки эквивалентны - добавляют в numbers дробь 3/1
    numbers.push_back(Rational{3});
    numbers.push_back(3);

    Rational sum = Add(Rational{1,6}, one_third);
    // Выведет 1/2
    cout << sum.Numerator() << "/" << sum.Denominator();
}

```

### Подсказка

Перед приведением дроби к несократимому виду измените знак числителя и знаменателя, если знаменатель изначально был отрицательным. Затем и числитель, и знаменатель разделите на их наибольший общий делитель. Для нахождения наибольшего общего делителя в C++ есть удобная функция gcd из заголовочного файла  `<numeric>`. Вы можете познакомиться с ней в  [документации по С++](https://en.cppreference.com/w/cpp/numeric/gcd)  или разработать такую функцию самостоятельно.

</details>  

