<details>  
<summary>Теория+тестирование:</summary>

# Явный и неявный вызов конструктора

В прошлом уроке вы познакомились с параметризованным конструктором, который принимает один или более параметров. В этом уроке разберём конструктор, принимающий один аргумент, — конвертирующий конструктор. Его можно вызвать неявным образом. Например, при передаче и возврате из функции:

```cpp
class Rational {
public:
    // Конвертирующий конструктор, создающий дробь из целого числа
    Rational(int numerator) { /* содержимое пропущено */ }
    // прочие конструкторы, методы и поля класса пропущены
};

Rational AddRationals(Rational r1, Rational r2) {
    int numerator = r1.Numerator() * r2.Denominator() + r2.Numerator() * r1.Denominator();
    int denominator = r1.Denominator() * r2.Denominator();

    return {numerator, denominator};
}

int main() {
    Rational sum = AddRationals(Rational{1, 6}, 5);
    // выведет 31/5
    cout << sum.Numerator() << "/"s << sum.GetDenominator() << endl;
}

```

Функция  `AddRationals`  оказалась способна принимать в качестве аргументов и корректно складывать не только обыкновенные дроби, но и целые числа. Вместо ожидаемого типа  `Rational`  мы передали значение типа  `int`. Компилятор видит, что в классе  `Rational`  есть конструктор, способный сделать из целого числа дробь. Этот конструктор компилятор использует, чтобы создать объект типа  `Rational`, а затем передаёт объект в качестве второго параметра функции. Благодаря конвертирующему конструктору функцию  `AddRationals`  можно применять для сложения целых и дробных чисел в любых комбинациях.

Такое приведение типов не всегда хорошо. Рассмотрим класс  `Cat`  и функцию  `Feed`:

```cpp
class Cat {
public:
    Cat(const string& name)
        : name_(name)
    {
    }
    const string& GetName() const {
        return name_;
    }
private:
    string name_;
};

void Feed(const Cat& cat) {
    cout << cat.GetName() << ", eat some milk"s << endl;
}

int main() {
    Cat cat1{"Матроскин"s};
    Feed(cat1); // Выглядит нормально
    Feed(Cat{"Леопольд"s}); // И это тоже

    // Следующие 2 строки выглядят странно: мы кормим какой-то объект и строку
    Feed({"Том"s});
    Feed("Котёнок по имени Гав"s);
}

```

Когда используете конвертирующий конструктор, функцию  `Feed`  можно вызвать при передаче ей объектов типа  `Cat`  и значений типа  `string`. Вызов  `Feed`  при передаче значений типа  `string`  — спорная возможность, ведь создание кота на основе некоторой строки должно выполняться явно. Все-таки строки и коты — очень разные сущности.

Чтобы запретить неявный вызов конструктора, пометьте его ключевым словом  `explicit`. Обычно так помечают конструктор с одним параметром, но иногда стó‎ит помечать конструкторы с несколькими аргументами. Почему так — узнаете в следующих спринтах. Взгляните на класс  `Cat`  с явным конструктором:

```cpp
class Cat {
public:
    explicit Cat(const string& name)
        : name_(name)
    {
    }
    const string& GetName() const {
        return name_;
    }
private:
    string name_;
};

```

Здесь при попытке вызвать  `Feed`  без явного конструирования объекта  `Cat`  компиляция завершится ошибкой:

```cpp
int main() {
    Feed(Cat{"Матроскин"s}); // Так можно
    Feed({"Леопольд"s});     // Ошибка компиляции: no matching function for call to 'Feed'
    Feed("Живоглот"s);       // Ошибка компиляции: no matching function for call to 'Feed'
}

```

Иногда неявный вызов конструктора с одним параметром ожидаем и не порождает вопросов при чтении кода. Но как правило, неявное преобразование типов нежелательно. Поэтому запрещайте неявный вызов: делайте явным конструктор с одним параметром, используя ключевое слов  `explicit`.

----------

Следует ли пометить ключевым словом  `explicit`  конструктор класса  `User`?

```cpp
class User {
public:
    User(const string& name)
        : name_(name)
    {
    }
private:
    string name_;
}

```

-   Да
    
-   Нет
    

----------

У вас есть конструктор класса  `Complex`, моделирующий комплексное число. Вы будете помечать конструктор словом  `explicit`?

```cpp
class Complex {
public:
    Complex(double real)
        : real_(real)
        , imaginary_(0)
    {
    }
    // ...
private:
    double real_;
    double imaginary_;
}

```

-   Да
    
-   Нет

</details>  


<details>  
<summary>Ответы:</summary>

# Ответы на задания

----------

Следует ли пометить ключевым словом  `explicit`  конструктор класса  `User`?

```cpp
class User {
public:
    User(const string& name)
        : name_(name)
    {
    }
private:
    string name_;
}

```

-   **(+)**  Да
    
    -   Неявное преобразование типа  `string`  в  `User`  выглядит странно, поэтому пометив конструктор ключевым словом  `explicit`, вы сделаете явным конструирование пользователя из строки.
-   **(-)**  Нет
    
    -   Лучше пометить. Иначе неявное преобразование типа  `string`  в  `User`  будет выглядеть странно.

----------

У вас есть конструктор класса  `Complex`, моделирующий комплексное число. Вы будете помечать конструктор словом  `explicit`?

```cpp
class Complex {
public:
    Complex(double real)
        : real_(real)
        , imaginary_(0)
    {
    }
    // ...
private:
    double real_;
    double imaginary_;
}

```

-   **(-)**  Да
    
    -   Если сделать конструктор  `explicit`, код станет объёмнее. Так как любое вещественное число — частный случай комплексного, возможность неявно создавать комплексные числа из вещественных будет ожидаемой и полезной. Поэтому  `explicit`  здесь не нужен.
-   **(+)**  Нет
    
    -   Комплексные числа — обобщение вещественных. Без  `explicit`  код станет короче. Возможность неявно создавать комплексные числа из вещественных будет ожидаемой и полезной.
</details>  
