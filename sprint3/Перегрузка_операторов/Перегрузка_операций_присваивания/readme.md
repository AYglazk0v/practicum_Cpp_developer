<details>
<summary>Теория</summary>

# Перегрузка операций присваивания

Вы уже знаете, что несмотря на суровость C++, в нём есть синтаксический сахар. К синтаксическому сахару относятся, например, лямбда-функции и краткая форма операций присваивания, таких как `+=`, `-=`, `*=` и `/=`.

`a += b` — лаконичная запись арифметического выражения `a = a + b`.

`a -= b` — лаконичная запись арифметического выражения `a = a - b`.

`a *= b` — лаконичная запись арифметического выражения `a = a * b`.

`a /= b` — лаконичная запись арифметического выражения `a = a / b`.

Эти операции можно задать и для пользовательских типов.

В C++ операции присваивания объявляются внутри класса, подобно методам. Левым аргументом такой операции будет текущий объект, а правый передаётся как единственный параметр операции.

Для примера рассмотрим перегрузку операции `+=` в структуре `Vector2D`:

```cpp
struct Vector2D {
    Vector2D() = default;

    Vector2D(double x0, double y0)
        : x(x0), y(y0) {
    }

    // левый аргумент операции += — это текущий экземпляр класса,
    // а правый передаётся в виде параметра операции
    Vector2D& operator+=(Vector2D right) {
        // Результат операции сохраняется в текущем экземпляре класса
        x += right.x;
        y += right.y;
        
        // return *this позволяет вернуть ссылку на текущий объект
        return *this;
    }

    double x = 0.0;
    double y = 0.0;
};

```

В отличие от операции сложения, `+=` не возвращает новый вектор, а записывает результат в текущий объект и возвращает ссылку на него командой `return *this`.

В C++ присваивающие выражения для встроенных типов и большинства классов стандартной библиотеки модифицируют левый аргумент операции и возвращают ссылку на него. Так на основе операций присваивания можно компактно реализовать соответствующие бинарные операции вроде `+`, `-` , `*` и `/`.

Например, задав `+=`, реализуем операцию сложения буквально в одну строку кода:

```cpp
Vector2D operator+(Vector2D left, Vector2D right) {
    // аргумент left принят по значению; можно спокойно модифицировать
    // это значение внутри операции и вернуть в виде результата
    return left += right;
}

```

Левый аргумент операции `+` здесь передаётся по значению. Это позволяет кратко записать тело оператора и помогает компилятору оптимизировать цепочку вызовов вида `a + b + c`.

Пример использования:

```cpp
int main() {
    Vector2D v1{1, 2};
    Vector2D v2{6, 1};

    // Сначала вычислится выражение в скобках (v1 += v2), в результате чего 
    //   v1 примет значение {13, 2}, а само выражение вернёт ссылку на v1.
    // Затем вычислится выражение v2 + v1, в результате чего 
    //   в переменную v3 будет записано значение {25, 2}.
    // Переменная v2 своего значения не изменит
    Vector2D v3 = v2 + (v1 += v2);

    cout << v1.x << ","s << v1.y << endl; // Выведет 13,2
    cout << v2.x << ","s << v2.y << endl; // Выведет 6,1
    cout << v3.x << ","s << v3.y << endl; // Выведет 25,2
}

```

</details>

<details>
<summary>Задание 1:</summary>

## Задание 1

Реализуйте для класса `Rational` операции присваивания `+=`, `-=`, `*=` и `/=`. После выполнения этих операций результирующая дробь должна приводиться к несократимому виду с положительным знаменателем. Входные данные программы исключают деление на ноль.

### Подсказка

Объявите присваивающие выражения внутри класса `Rational`, как в примере с классом `Vector2D`. Убедитесь, что они модифицируют текущий объект и возвращают ссылку на него командой `return *this;`. Перед выходом из операции не забудьте нормализовать дробь. Для этого выделите код нормализации дроби в приватный метод `Normalize()`. Вызывайте его в этих операциях перед `return *this;`.

</details>

<details>
<summary>Задание 2:</summary>

## Задание 2

Перегрузите бинарные арифметические операции `+`, `-`, `*`, `/` для класса `Rational` на основе реализованных вами присваивающих выражений.

### Подсказка

В теории вы узнали, как это сделать на примере структуры `Vector2D`. Здесь сделайте по аналогии.

</details>


