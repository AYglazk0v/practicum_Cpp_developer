<details>
<summary>Теория</summary>

# Перегрузка арифметических операций

Перегрузка операций — мощное средство C++. Перегрузка позволяет выполнять арифметические и другие операции над пользовательскими типами данных естественным образом — то есть так же, как над встроенными типами.

Встроенные в язык типы, операторы, языковые конструкции — это атомы, из которых можно создать более крупные и абстрактные сущности — молекулы и организмы. Например, координаты точки на плоскости можно описать двумя переменными `x` и `y`, имеющими тип `double`. Но это будут разные переменные. На их связь с точкой будут указывать в лучшем случае комментарии в коде, а в худшем — только знания в голове программиста. Улучшить ситуацию можно. Используем класс и структуру и зададим новый тип данных «‎точка»‎:

```cpp
struct Point { 
double x, y; 
};

```

Теперь объявлять точку можем этим пользовательским типом:

```cpp
// объявляем точки p1 и p2
Point p1, p2;

```

У нас появилась собранная из атомов молекула. В этой структуре можно написать методы, перегрузить операции. Тогда молекула будет обладать ещё и поведением. Во вселенной программы появится некоторое подобие законов физики. Всё новые и новые молекулы позволят программировать поведение сложной системы, такой как графический редактор, браузер, поисковая или операционная система.

Пользовательские типы — это классы, структуры, перечислимые типы и пока не знакомые вам объединения (`union`). При объявлении новых типов данных в коде появляются новые сущности из предметной области, где работает программа. Предметная область — часть реального или нереального мира, которую программа моделирует. Её ещё можно назвать контекстом.

У каждой предметной области свои особенности. Например, если создаём программу для работы с дробями, она должна подчиняться правилам арифметики. А предметная область бухгалтерской программы содержит термины вроде «счёт», «накладная», «контрагент».

В некоторой предметной области над вводимыми сущностями могут выполняться операции: сложение векторов, умножение матриц, арифметические операции над дробями. Применив перегрузку, вы сможете объявить в программе собственные операции над введёнными вами типами. Например, сложить дроби можно операцией сложения `number1 + number2` вместо многословной функции `AddRationals(number1, number2)`. Такой код быстрее писать и легче читать.

При правильном использовании перегрузка операций повысит выразительность вашего кода. Но в работе с таким инструментом есть ограничения:

-   Когда реализуете перегрузку операции, следите за тем, чтобы это органично вписывалось в программу, соответствовало предметной области и не вызывало вопросов у других разработчиков. Например, не стоит определять операцию сложения дроби со строкой. Если язык позволяет сделать что-то, не означает, что это нужно делать.
-   Перегрузка операций в C++ не изменяет размерность операций и их приоритет. Как и со встроенными типами данных, у операций умножения и деления над пользовательскими типами данных будет приоритет над операциями сложения и вычитания. Бинарные операции останутся бинарными, унарные — унарными.

Разработанный вами класс `Rational` позволяет хранить рациональные дроби в нормализованном виде, вводить и выводить их в потоки стандартной библиотеки. Чтобы работать с этим классом, как со встроенными числами, освоим перегрузку арифметических операций `+`, `-`, `*`, `/`.

### Арифметические операции с одинаковыми типами аргументов

Перегрузка арифметических операций `+`, `-`, `*`, `/` позволит выполнять арифметические операции над дробями естественным образом, как над целыми и вещественными числами:

```cpp
int main() {
    Rational r1{1, 6};
    Rational r2{1, 3};
    Rational sum = (r1 + r2) * r1;
    cout << sum << endl; // Выведет 1/12
}

```

При перегрузке операторов в первую очередь руководствуйтесь предметной областью. Она накладывает ограничения на набор операций над типами и их семантику.

Арифметические операции `+`, `-`, `*`, `/` над типом `Rational` — это бинарные операции, принимающие два аргумента типа `Rational`. Результат — новое значение, также имеющее тип `Rational`. Эти операции не изменяют значения ни левого, ни правого аргументов.

Результатом сложения двух обыкновенных дробей, будет обыкновенная дробь, равная:

________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

Чтобы задать операцию сложения, объявим функцию со специальным именем `operator+`, принимающую два рациональных числа и возвращающую результат типа `Rational`:

```cpp
Rational operator+(Rational left, Rational right) {
    const int numerator = left.Numerator() * right.Denominator() 
                  + right.Numerator() * left.Denominator();
    const int denominator = left.Denominator() * right.Denominator();

    return {numerator, denominator};
}

```

Объекты `Rational` хранят два целых числа и считаются легковесными. Вот почему мы передаём дроби в функцию `operator+` по значению. Более тяжелые для копирования классы принимайте по константной ссылке, если функция или операция их не модифицирует.

Убедимся, что добавленная операция работает:

```cpp
int main() {
    Rational r1, r2;

    cout << "Введите первую дробь: "s;
    cin >> r1;

    cout << "Введите вторую дробь: "s;
    cin >> r2;

    cout << "Их сумма равна: "s << r1 + r2 << endl;
}

```

Запустив программу, увидим:

```
Введите первую дробь: 1/3
Введите вторую дробь: 1/6
Их сумма равна: 1/2

```

Но в классе `Rational` есть ещё один параметризованный конструктор, принимающий тип `int`:

```cpp
class Rational {
public:
    Rational(int value)
};

```

С этим конструктором мы можем складывать дроби не только между собой, но и с целыми числами. И наоборот:

```cpp
int main() {
    cout << "Введите первую дробь: "s;
    Rational rational;
    cin >> rational;

    cout << "Введите целое число: "s;
    int integer;
    cin >> integer;

    cout << "Их сумма равна: "s << rational + integer << endl;
}

```

Здесь компилятор обнаружит выражение `rational + integer` и будет искать версию `operator+`, принимающую типы `Rational` и `int`. Но мы её не написали. Поэтому не найдёт и попытается преобразовать типы аргументов под имеющиеся операции. Увидев оператор сложения двух аргументов `Rational`, компилятор превратит второй параметр из `int` в `Rational`. Для этого неявно вызовется конвертирующий конструктор, как если бы мы написали:

```cpp
 cout << "Их сумма равна: "s << rational + Rational{integer} << endl;

```

### Арифметические операции с разными типами аргументов

Типы аргументов бинарной арифметической операции не обязательно должны быть одинаковыми. Правила определяются особенностями предметной области.

Рассмотрим операцию умножения двухмерного вектора и скаляра. В результате операции получается новый отмасштабированный двухмерный вектор. При этом умножать можно не только вектор на скаляр, но и скаляр на вектор. Для этого реализуем две версии операции умножения — `vector*scalar` и `scalar*vector`:

```cpp
// Здесь мы объявляем структуру, а не класс, так как поля структуры 
// могут принимать произвольные значения
struct Vector2D {
    // Такая запись сообщает компилятору, чтобы он сгенерировал конструктор по умолчанию,
    // в котором поля x и y проинициализировал значениями, заданными при их объявлении
    Vector2D() = default;

    Vector2D(double x0, double y0)
        : x(x0), y(y0) {
    }

    // Задаем значения по умолчанию для полей структуры
    double x = 0.0;
    double y = 0.0;
};

// Операция умножения вектора на скаляр
Vector2D operator*(Vector2D vector, double scalar) {
    return {vector.x * scalar, vector.y * scalar};
}

// Операция умножения скаляра на вектор
Vector2D operator*(double scalar, Vector2D vector) {
    // Благодаря коммутативности операции умножения, мы можем выразить 
    // умножение скаляра на вектор через операцию умножения вектора на скаляр
    return vector * scalar;
}

```

Аргументы бинарной операции могут быть одного типа или разных. При этом может понадобиться реализовать для них две перегрузки в зависимости от порядка операндов или только одну. Всё определяется предметной областью. Например, операция деления вектора на скаляр существует, а обратная операция деления скаляра на вектор — нет.

### Перегрузка унарного плюса и минуса

Для дробей и векторов помимо бинарных арифметических операций, существуют операции унарного плюса и минуса. Они используются в выражениях вроде:

```cpp
int main() {
    const Vector2D v1{1, 7}
    const Vector2D minus_v1 = -v1; // вызов унарного минуса
    const Vector2D plus_v1 = +v1;  // вызов унарного плюса
}

```

Чтобы перегрузить унарный плюс и минус, задают операции `operator+` и `operator-` с единственным аргументом. Унарный плюс должен возвращать копию своего аргумента, а унарный минус — противоположное по знаку значение. Например, для типа `Vector2D` операции унарного плюса и минуса можно задать так:

```cpp
// Операция унарного плюса возвращает копию переданного вектора
Vector2D operator+(Vector2D v) {
    return v;
}

// Операция унарного минуса возвращает вектор с противоположным направлением
Vector2D operator-(Vector2D v) {
    return {-v.x, -v.y};
}

```

Уметь работать с унарными операциями — значит эффективно использовать средства языка. В любой нетривиальной программе вы не раз будете самостоятельно реализовать хотя бы некоторые из таких операций, либо использовать написанные коллегами.

</details>

<details>
<summary>Задание:</summary>

## Задание

Реализуйте для класса `Rational` операции сложения и вычитания, а также операции унарного плюса и унарного минуса. Это позволит выполнять над обыкновенными дробями базовые арифметические операции, так же как с целыми числами и числами с плавающей запятой.

### Подсказка

Возьмите код сложения дробей из теории. Операцию вычитания реализуйте аналогично. Операции унарного плюса и минуса реализуйте по аналогии со структурой `Vector2D`.

</details>
