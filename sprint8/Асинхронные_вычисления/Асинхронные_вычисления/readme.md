<details>
<summary>Введение:</summary>

# Введение

Асинхронные вычисления — чуть более широкое понятие, чем многопоточность. Разберёмся на жизненном примере.

Представьте, что вы готовитесь к зиме и хотите почистить своё лучшее пальто. Приносите его в химчистку, отдаёте — и вам говорят: «Никуда не уходите, через два часа вернём. Или раньше». Что вы делаете? Ждёте на стульчике вместе с такими же ответственными владельцами одежды. И достаточно бесполезно тратите два часа своей жизни. Это пример синхронных процессов: вы не можете начать следующее дело, пока не закончится текущее.

Вы скажете, что этот пример ужасно несовременен — и будете правы. В реальности вы, сидя дома на самоизоляции, закажете химчистку через удобное мобильное приложение, к вам приедет добродушный курьер и заберёт пальто. И вы свободны заниматься чем угодно! Это пример асинхронных процессов: можно начинать следующее дело, если оно не зависит от текущего. Правда, если это ваша единственная зимняя одежда, а ваша собака не гуляла со вчерашнего дня и на улице не май, вы потеряете покой и будете названивать в химчистку.

Синхронные вычисления в коде выглядят максимально знакомо:

```cpp
CallSister();
CleanCoat();
WalkDog();  // сначала чистим пальто, потом гуляем с собакой

```

А вот асинхронная чистка потребует многопоточности. Как её организовать для нашего сценария, вы узнаете в следующих уроках.

Асинхронность может присутствовать и в пользовательском коде, где многопоточности в явном виде нет. Пусть вы пишете высоконагруженную систему обработки некоторых данных, и в какой-то момент вам понадобилось запросить данные у другого сервиса. Вы отправляете ему запрос, а пока сервис его обрабатывает, можете выполнять другие вычисления. Это пример асинхронности между несколькими сервисами, обрабатывающими смежные данные.

</details>


<details>
<summary>Теория + тестирование:</summary>

# Асинхронные вычисления

Итак, мы хотим реализовать конкретную схему:

-   в одном потоке сдать пальто в чистку;
-   в другом потоке пойти гулять с собакой, не дожидаясь окончания чистки.

Параллельные алгоритмы тут не подойдут, нужна более гибкая схема.

Перед тем как рассмотреть конкретные функции и типы данных, немного дополним пример. Представьте, что вы сдали пальто и получили талончик с адресом и номером заказа. Вы закончили свои текущие дела, приезжаете с этим талончиком в химчистку и дожидаетесь, когда пальто почистят. Современный C++ позволяет реализовать асинхронное выполнение задач, используя именно такие «талончики» на получение результата функции.

Так выглядит синхронный вариант:

```cpp
const CleaningReport report = CleanCoat(coat, money);
const bool is_dog_happy = WalkDog(dog);

```

А так — асинхронный:

```cpp
#include <future>

// ... 

future<CleaningReport> coat_future =
    async([&coat, money] { return CleanCoat(coat, money); });
const bool is_dog_happy = WalkDog(dog);  // любые действия, не связанные с пальто
const auto report = coat_future.get();

```

Обо всём по порядку:

1.  В библиотеке  `<future>`  объявлены функция  `async`  и шаблон  `future`.
2.  `async`  принимает функцию, которую нужно запустить асинхронно. По возможности она запускается немедленно, а возвращается из  `async`  тот самый «талончик» — объект  `future<FunctionResult>`. Позже он позволит получить результат выполнения асихнронной функции типа  `FunctionResult`.
3.  Гуляем с собакой. Если потоков достаточно, пальто уже чистится.
4.  Вызов метода  `get`  для  `future<FunctionResult>`  переводит текущий поток в режим ожидания окончания выполнения асинхронной функции. Как только она завершилась, из  `get`  возвращается результат.

----------

Предположим, что функция  `CleanCoat`  работает два часа. Возможно ли, что и вызов  `async`, и вызов  `coat_future.get()`  отработают практически мгновенно?

-   Если есть свободные ядра процессора, почему нет?
    
-   Конечно, нет: нужно же как минимум дождаться окончания чистки.
    

Функция  `async`  умеет принимать не только функцию без параметров: после функции можно указать аргументы, с которыми она должна быть запущена. Но будьте аккуратны: если указать их как есть, они скопируются:

```cpp
future<CleaningReport> coat_future = async(CleanCoat, coat, money);
// за деньги не страшно (если это число), а вот тяжёлое пальто скопируется

```

Если аргумент нужно передать по ссылке, оберните его в  `ref`, а если по константной ссылке — в  `cref`:

```cpp
#include <functional>

// ...
future<CleaningReport> coat_future = async(CleanCoat, ref(coat), money);
// деньги копируются, пальто передаётся по неконстантной ссылке

```

Разберём более конкретный пример. Пусть есть два числовых вектора — количества кошек и собак в разных приютах. Нужно вычислить их суммарное количество. Последовательное решение здесь очевидно:

```cpp
int SumAnimalsSeq(const vector<int>& cats, const vector<int>& dogs) {
    LOG_DURATION("sequenced");
    return reduce(cats.begin(), cats.end()) + reduce(dogs.begin(), dogs.end());
}

```

И оно легко параллелится функцией  `async`: поставим асинхронную задачу вычисления количества кошек, а в основном потоке посчитаем количество собак.

```cpp
int SumAnimalsAsync(const vector<int>& cats, const vector<int>& dogs) {
    LOG_DURATION("async");
    auto cats_future =
        async([&cats] { return reduce(cats.begin(), cats.end()); });

    // в этот момент — до вызова cats_future.get() — параллельно считаются кошки
    const int dog_count = reduce(dogs.begin(), dogs.end());

    return cats_future.get() + dog_count;
}

```

Если запустить эти функции на векторах длины 100 000 000, увидим ускорение для второй версии:

```
sequenced: 97 ms
async: 59 ms

```

----------

Что делать дальше? Выберите несколько вариантов ответа.

-   На этом всё, распараллеливание идеально.
    
-   Надо попробовать версию  `reduce`  с  `execution::par`, но без  `async`.
    
-   Нужно обязательно в примере с  `async`  добавить  `execution::par`  в вызов  `reduce`: так параллельности будет вдвое больше.
    
-   Надо попробовать запустить больше асинхронных задач, например, для половин векторов.
    

Возможно, вы замечали, что не все стандартные алгоритмы имеют параллельную версию. И дело даже не в том, что их в принципе невозможно распараллелить. Скорее, в стандартных сценариях их использования параллельность неуместна.

Пример такого алгоритма —  `lower_bound`: он принимает отсортированный диапазон элементов и ищет первый элемент, не меньший данного. Распараллелить бинарный поиск, на котором основан  `lower_bound`  — интересное упражнение, которое вы сейчас проделаете. Поддержку кастомного компаратора реализовывать не нужно, достаточно сравнивать элементы стандартным оператором  `<`.

Сложность бинарного поиска не просто logN, а C×logN, где N — количество элементов, а C — сложность сравнения элементов. Например,  `lower_bound`  для строк, длина которых ограничена L, в худшем случае будет работать за L×logN. Как уменьшать logN, не очень ясно, поэтому замахнёмся на ускорение сравнений за счёт их распараллеливания.

</details>


<details>
<summary>Ответы:</summary>

# Ответы на задания

Предположим, что функция  `CleanCoat`  работает два часа. Возможно ли, что и вызов  `async`, и вызов  `coat_future.get()`  отработают практически мгновенно?

-   **(+)**  Если есть свободные ядра процессора, почему нет?
    
-   **(-)**  Конечно, нет: нужно же как минимум дождаться окончания чистки.
    

> Если долго гулять с собакой, время пролетит незаметно — останется только заглянуть в химчистку по окончании прогулки.

----------

Что делать дальше? Выберите несколько вариантов ответа.

-   **(-)**  На этом всё, распараллеливание идеально.

> Мы запустили всего одну асинхронную задачу. А если ядер процессора больше двух?

-   **(+)**  Надо попробовать версию  `reduce`  с  `execution::par`, но без  `async`.
    
-   **(-)**  Нужно обязательно в примере с  `async`  добавить  `execution::par`  в вызов  `reduce`: так параллельности будет вдвое больше.
    

> Как бы не стало медленнее! Параллельные алгоритмы рассчитывают на то, что с ними за потоки никто не конкурирует. В любом случае надо пробовать разное и измерять.

-   **(+)**  Надо попробовать запустить больше асинхронных задач, например, для половин векторов.

</details>

<details>
<summary>Задание 1:</summary>

## Задание

Вспомните схему обычного бинарного поиска. На каждой итерации цикла есть полуинтервал элементов  `[left, right)`, в котором ищется  `value`. Пусть  `middle`  — середина этого полуинтервала. Если  `*middle < value`, надо продолжать поиск справа от  `middle`, иначе — слева.

Примените ту же идею, но с разбиением полуинтервала на три части. Выберите  `middle_left`  и  `middle_right`, сравните элементы под ними с  `value`  параллельно и на основании полученных результатов выберите, в какой из третей продолжать поиск.

Базовая версия  `LowerBound`  — последовательная и с разбиением на две части — уже написана за вас. Тем не менее, вам понадобится очень внимательное тестирование, чтобы отловить все неприятные крайние случаи.

### Что отправлять на проверку

Отправьте cpp-файл, содержащий три версии шаблонной функции  `LowerBound`:

-   без ExecutionPolicy,
-   с  `execution::seq`,
-   с  `execution::par`.

А также нужные для их работы подключения библиотек и другие функции. Ваша программа должна содержать подстроку  `async`. Функция  `main`  будет проигнорирована при тестировании.

### Как будет тестироваться ваш код

Правильность работы функции будет проверена юнит-тестами.

Производительность параллельной версии будет проверена так. Дан отсортированный вектор из 10 объектов некоторого класса  `Heavy`. Для этого класса определён оператор сравнения, и сравнение занимает относительно большое время. Измерим время, за которое будут обработаны 100 запросов  `LowerBound`  к этому вектору.

Время работы многопоточной версии вашей функции должно быть по крайней мере на 25% меньше, чем у версии из заготовки кода.

Также это время должно быть по крайней мере на 25% меньше, чем у вашей однопоточной версии в обоих вариантах вызова.

Бенчмарк для самопроверки разработайте самостоятельно.

### Подсказка

Если ваша программа зацикливается, поймайте значения границ, на которых это происходит — наверняка понадобится отдельно обработать крайний случай. Между созданием future и вызовом  `get`  для future должны выполняться некоторые сложные вычисления.

</details>
