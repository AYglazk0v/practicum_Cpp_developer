<details>
<summary>Теория:</summary>

# Особенности future

Вы уже видели пример, где всё делалось по правилам: вызвали  `async`, положили результат в переменную типа  `future<T>`, через некоторое время вызвали  `get`. Например, вот так можно параллельно отсортировать два вектора:

```cpp
void SortAnimals(vector<int>& cats, vector<int>& dogs) {
    auto cats_future = async([&cats] { sort(cats.begin(), cats.end()); });
    sort(dogs.begin(), dogs.end());
    cats_future.get();
}

```

Или так, для большей симметрии:

```cpp
void SortAnimals(vector<int>& cats, vector<int>& dogs) {
    auto cats_future = async([&cats] { sort(cats.begin(), cats.end()); });
    auto dogs_future = async([&dogs] { sort(dogs.begin(), dogs.end()); });
    cats_future.get();
    dogs_future.get();
}

```

Когда функция, запускаемая асинхронно, не возвращает ничего, соответствующий  `async`  возвращает  `future<void>`. И его метод  `get`  ничего не возвращает, а лишь дожидается завершения асинхронной операции, блокируя выполнение текущего потока.

Когда у функции нет конкретного результата, легко забыть вызвать  `get`. Например, так:

```cpp
void SortAnimals(vector<int>& cats, vector<int>& dogs) {
    auto cats_future = async([&cats] { sort(cats.begin(), cats.end()); });
    auto dogs_future = async([&dogs] { sort(dogs.begin(), dogs.end()); });
}

```

Интересно, что такое использование  `async`  можно встретить в реальном коде, и ничего страшного в этом нет.

----------

Как вы думаете, что произойдёт?

-   Сортировки выполнятся последовательно.
    
-   Компилятор пожалуется на неиспользуемые переменные.
    
-   Хм, надо посмотреть, что делает деструктор future.
    

Оказывается, в данном случае деструктор future дождётся завершения функции, то есть, по сути, сам вызовет  `get`. Как вы уже видели в начале урока, два последовательных вызова  `get`  для двух future — стандартный способ дать задачам выполниться параллельно и дождаться завершения обеих. Но важно не допустить такой ошибки:

```cpp
void SortAnimals(vector<int>& cats, vector<int>& dogs) {
    async([&cats] { sort(cats.begin(), cats.end()); });
    async([&dogs] { sort(dogs.begin(), dogs.end()); });
}

```

В предыдущем примере могло показаться, что переменные  `cats_future`  и  `dogs_future`  никак не используются — и можно их вообще не создавать. Современные компиляторы при попытке сделать это выдадут предупреждение благодаря атрибуту  `[[nodiscard]]`  в объявлении функции  `async`.

----------

Что случилось бы, если бы этого предупреждения не было?

-   Сортировки выполнились бы параллельно.
    
-   Сортировки выполнились бы последовательно.
    

Итак, вы действительно можете не вызывать  `get`  для future в следующих случаях:

-   запускаемая асинхронно функция возвращает  `void`;
-   нигде в области видимости этого future (до его уничтожения) не требуется готовность результатов функции.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Как вы думаете, что произойдёт?

-   **(-)**  Сортировки выполнятся последовательно.

> Но они запустились параллельно и к моменту завершения функции уже работают в таком режиме.

-   **(-)**  Компилятор пожалуется на неиспользуемые переменные.

> Это исключение: у future нетривиальный деструктор, поэтому именно ради него компилятор позволяет создать переменную, имя которой дальше не упоминается.

-   **(+)**  Хм, надо посмотреть, что делает деструктор future.

----------

Что случилось бы, если бы этого предупреждения не было?

-   **(-)**  Сортировки выполнились бы параллельно.

> К сожалению, нет: деструктор для результата вызова первого  `async`  (временной переменной) вызовется до второго  `async`.

-   **(+)**  Сортировки выполнились бы последовательно.

</details>

<details>
<summary>Задание:</summary>

## Задание

Крупная IT-компания Янгл проводит исследование упоминаемости своего бренда в блогах и социальных сетях. Аналитики компании уже выгрузили интересующие их публикации и сформировали набор ключевых слов. Аналитики хотят знать, сколько раз каждое ключевое слово входит в набор публикаций.

Помогите им это сделать: напишите функцию  `Stats ExploreKeyWords(const KeyWords& key_words, istream& input)`. Её параметры:

-   `key_words`  — множество ключевых слов,
-   `input`  — входной поток, содержащий исследуемые публикации в блогах и соц. сетях, одна строка — одна публикация.

`KeyWords`  — синоним для  `set<string, less<>>`.

Функция  `ExploreKeyWords`  должна возвращать структуру  `Stats`, в которой хранится, сколько раз каждое слово из  `key_words`  суммарно встретилось в потоке  `input`:

```cpp
struct Stats {
    map<string, int> word_frequences;
    Stats& operator+=(const Stats& other);
};

```

При подсчёте вхождения ключевых слов в текст нужно учитывать только вхождения в виде отдельных слов. Слова друг от друга отделяются одним или несколькими пробелами.

Чтобы уложиться в ограничение по времени, эту задачу вам предстоит распараллелить.

### Пример

Допустим, что  `key_words = {"yangle", "rocks", "sucks", "all"}`  и у вас есть публикация из социальной сети Switter: “Goondex really sucks, but yangle rocks ! Use yangle”. Слово “yangle” входит в неё два раза, “rocks” — один раз, а слова “all” и “sucks” — ни разу. Слово “sucks” не входит ни разу, потому что в данном примере оно — префикс слова “sucks,”, ведь по условию слова друг от друга отделяются только пробелами. Несмотря на то, что слово “all” — часть слова “really”, его вхождение тоже нельзя засчитывать, так как это не отдельное слово.

Полный пример — в заготовке кода.

### Ограничения

Слова состоят только из букв, цифр и знаков пунктуации (тех, для которых  [`isprint`](https://en.cppreference.com/w/cpp/string/byte/isprint)`(c) == true`).

Ваш код должен содержать слово  `async`.

### Что отправлять на проверку

cpp-файл, содержащий функцию  `ExploreKeyWords`, определение структуры  `Stats`, а также нужные для их работы подключения библиотек и другие функции. Функция  `main`  будет проигнорирована при тестировании.

### Как будет тестироваться ваш код

Правильность работы функции будет проверена юнит-тестами. Также будет измерено время её работы.

Входные данные для теста производительности:

-   длина слов не больше шести элементов;
-   количество ключевых слов не больше 50 000;
-   количество слов в строке не больше 20;
-   количество строк не больше 50 000.

Время работы вашей функции должно быть по крайней мере на 30% меньше, чем у авторского однопоточного решения.

Мы не предоставляем вам бенчмарк, но гарантируем, что ограничения соответствуют указанным.

### Подсказка

Разные строки текста или наборы этих строк можно обрабатывать параллельно, а затем складывать полученные словари.

Если собираетесь добавлять future в вектор, имейте в виду: это некопируемый тип.

</details>
