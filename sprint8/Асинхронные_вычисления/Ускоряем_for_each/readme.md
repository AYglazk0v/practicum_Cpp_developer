<details>
<summary>Теория:</summary>

# Ускоряем for_each

В этом уроке замахнёмся на недостижимое и ускорим параллельную реализацию алгоритма  `for_each`  _из стандартной библиотеки._  Конечно, без небольшой хитрости тут не обойдётся.

`for_each`  принимает два итератора и функцию, которую надо вызвать для каждого элемента диапазона. Например, так можно умножить на два все элементы вектора:

```cpp
vector<int> animal_weights = {3, 1, 7, 4};
for_each(animal_weights.begin(), animal_weights.end(),
         [](int& weight) { weight *= 2; });

```

Стандартная реализация этого алгоритма — с использованием цикла  `for`. Посмотрим, как можно применить  `async`  для её ускорения. Достаточно разбить диапазон на несколько подряд идущих частей одного размера, как в сортировке слиянием, и отдать каждую часть своей асинхронной задаче.

Это элементарно, если имеете дело с итераторами произвольного доступа: для них можно за константное время и вычислить количество элементов, и последовательно найти точки разбиения. Если речь идёт об однонаправленных итераторах без произвольного доступа, почти на все из этих операций потребуется линейное количество действий:

-   вычислить количество элементов: функция  `distance`, линейная сложность из-за отсутствия произвольного доступа;
-   вычислить размер каждой части, разделив количество элементов на количество задач: константная сложность;
-   определить точки разбиения: функция  `next`  или  `advance`, линейная сложность.

Зададимся целью ускорить многопоточную реализацию  `for_each`  именно для итераторов без произвольного доступа. И здесь самое время для трюка.

----------

Можно ли получить более быструю версию  `for_each`, если принимать на вход не пару итераторов, а контейнер?

-   Это действие неоправданно сузит функциональность: больше нельзя будет передать в  `for_each`  половину списка.
    
-   Нет: придётся специально вызывать  `begin`  и  `end`  для контейнера, а это лишние накладные расходы.
    
-   Да: большинство контейнеров имеют метод  `size`, работающий за константное время.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Можно ли получить более быструю версию  `for_each`, если принимать на вход не пару итераторов, а контейнер?

-   **(-)**  Это действие неоправданно сузит функциональность: больше нельзя будет передать в  `for_each`  половину списка.

> Часто ли вы передаёте в функцию часть контейнера? В любом случае, вызов для целого контейнера — частый сценарий, который интересно ускорить.

-   **(-)**  Нет: придётся специально вызывать  `begin`  и  `end`  для контейнера, а это лишние накладные расходы.

> Этими накладными расходами можно пренебречь.

-   **(+)**  Да: большинство контейнеров имеют метод  `size`, работающий за константное время.

</details>

<details>
<summary>Задание 1:</summary>

## Задание 1

Вам дана функция  `ForEach`, интерфейс которой отличается от  `for_each`  лишь тем, что вместо пары итераторов принимает контейнер. Она уже реализована с помощью простого вызова многопоточной версии  `for_each`. Ускорьте её для итераторов без произвольного доступа, применив  `async`.

Пример использования — в заготовке кода.

### Что отправлять на проверку

cpp-файл, содержащий функцию  `ForEach`, а также нужные для её работы подключения библиотек, другие классы и функции. Функция  `main`  будет проигнорирована при тестировании.

### Как будет тестироваться ваш код

Правильность работы функции будет проверена юнит-тестами. Также будет измерено время её работы.

Ваша функция должна быть эффективнее функции ForEach, данной в заготовке кода, по крайней мере на 40%, когда в неё передаётся контейнер без произвольного доступа к элементам.

Вы можете ориентироваться на бенчмарк, данный в заготовке кода.

### Подсказка

1.  Для вычисления количества элементов используйте метод  `size`.
2.  Вычислите размер части массива для одной асинхронной задачи, разделив количество элементов на количество задач.
3.  За один проход по контейнеру определите точки разбиения и запустите асинхронные задачи.

Поэкспериментируйте с количеством задач и помните о том, что количество элементов может не разделиться нацело на количество задач.

</details>

<details>
<summary>Задание 2:</summary>

## Задание 2

Победить в производительности стандартный алгоритм, пусть и в не совсем честной борьбе — большое достижение. Но чтобы вашу функцию можно было использовать в самых разных сценариях, хочется сделать её умнее. Пусть ваша версия вызывается только тогда, когда пользователь передал  `execution::par`  и контейнер без произвольного доступа. В остальных случаях нужно вызвать стандартный алгоритм.

Это непростая задача, и ничему подобному мы вас не учили. Но в жизни случается всякое. Поэтому поэкспериментируйте и попробуйте найти ответ сами. А если не выйдёт, в подсказке вас ждёт описание самой короткой дороги к успеху. После сдачи задания вы сможете посмотреть на решение с использованием самых свежих возможностей C++20.

### Пример

```cpp
#include <algorithm>
#include <iostream>
#include <list>
#include <string>
#include <string_view>
#include <vector>

using namespace std;

template <typename Strings>
void PrintStrings(const Strings& strings) {
    for (string_view s : strings) {
        cout << s << " ";
    }
    cout << endl;
}

int main() {
    auto reverser = [](string& s) { reverse(s.begin(), s.end()); };

    list<string> strings_list = {"cat", "dog", "code"};

    ForEach(strings_list, reverser);
    PrintStrings(strings_list);
    // tac god edoc

    ForEach(execution::seq, strings_list, reverser);
    PrintStrings(strings_list);
    // cat dog code

    // единственный из вызовов, где должна работать ваша версия
    // из предыдущего задания
    ForEach(execution::par, strings_list, reverser);
    PrintStrings(strings_list);
    // tac god edoc

    vector<string> strings_vector = {"cat", "dog", "code"};

    ForEach(strings_vector, reverser);
    PrintStrings(strings_vector);
    // tac god edoc

    ForEach(execution::seq, strings_vector, reverser);
    PrintStrings(strings_vector);
    // cat dog code

    ForEach(execution::par, strings_vector, reverser);
    PrintStrings(strings_vector);
    // tac god edoc

    return 0;
}

```

### Ограничения

Гарантируется, что тип итератора передаваемого в функцию контейнера типа  `C`  можно получить, используя выражение  `typename C::iterator`. В вашу функцию не будут передаваться контейнеры, итераторы которых не однонаправленные. И без этого непросто.

### Что отправлять на проверку

cpp-файл, содержащий функцию  `ForEach`, а также необходимые для её работы подключения библиотек, другие классы и функции. Функция  `main`  будет проигнорирована при тестировании.

### Как будет тестироваться ваш код

В тестах ваша функция будет вызвана с различными контейнерами и с различными значениями  `execution_policy`  — см. пример выше. Для каждой комбинации параметров будет измерено время работы вашей функции, а также время работы «стандартной» версии на основе  `std::for_each`.

При работе с контейнером без произвольного доступа к элементам и с политикой  `execution::par`  ваша версия должна быть эффективнее стандартной минимум на 40%.

Во всех остальных случаях проверяется, что по времени выполнения ваша функция не отличается от стандартной более чем на 10% в любую сторону.

Также в каждом из тестов результаты работы вашей и стандартной функции проверяются на совпадение.

### Подсказка

Начните с написания шаблонной функции  `ForEach`, принимающей произвольные ExecutionPolicy, контейнер и функцию и вызывающей  `for_each`. Добавьте версию от двух параметров, вызывающую предыдущую с  `execution::seq`.

Теперь самый простой способ — добавить в основную версию ветвление следующего вида: «если тип ExecutionPolicy — это  `execution::par`  и итераторы контейнера не обладают произвольным доступом, вызвать свою версию». Проблема в том, что в C++ типы — это не объекты: их нельзя сравнивать на == и передавать их в функции. Зато типы могут быть параметрами шаблонов, поэтому будем использовать шаблонную магию из библиотек  `<type_traits>`  и  `<iterator>`.

1.  Чтобы проверить, что два типа совпадают, используйте  `is_same_v`:  `is_same_v<ExecutionPolicy, execution::sequenced_policy>`. Если что-нибудь не работает, вероятно, тип  `ExecutionPolicy`  отличается от нужного лишь константностью или наличием ссылки. В этом случае поможет обернуть его в  `decay_t`:  `is_same_v<decay_t<ExecutionPolicy>, execution::sequenced_policy>`. Здесь  `is_same_v`, это шаблонная булевская переменная, так что при подстановке в неё двух типов выражение  `is_same_v<T, U>`  имеет тип  `bool`  и может участвовать в логических выражениях.
2.  Тип итератора для контейнера типа  `ForwardRange`  можно получить с помощью выражения  `typename ForwardRange::iterator`. В реальной жизни это не всегда так, и в авторском решении вы увидите более правильный подход.
3.  Получить категорию итератора типа  `It`  можно, использовав выражение  `typename iterator_traits<It>::iterator_category`.
4.  Категория итератора — это некоторый тип, объекты которого вам точно не понадобится создавать. Вам нужен  `random_access_iterator_tag`.
5.  Условие из этих кирпичиков можно поместить в оператор  `if`: тогда при каждом вызове функции оно будет проверяться. Но поскольку результат вычисления такого логического выражения зависит только от шаблонных параметров, его можно вычислить ещё на этапе компиляции — и там же пойти в нужную ветку условного оператора. Для этого сразу после слова  `if`  добавьте слово  `constexpr`. Оно употребляется в разных контекстах, но всегда относится к вычислениям на этапе компиляции. Преимущество  `if constexpr`  не только в эффективности: теперь в той ветке, в которую компилятор попадает только с итераторами произвольного доступа, можно спокойно вычитать итераторы. С обычным  `if`  такой код не скомпилируется.

</details>
