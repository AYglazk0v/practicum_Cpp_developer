<details>
<summary>Теория + тестирование:</summary>

# Scan-алгоритмы

Не все алгоритмы легко разложить на map и reduce, но это не означает, что их нельзя распараллелить. Разберём один из них —  [`partial_sum`](https://en.cppreference.com/w/cpp/algorithm/partial_sum). Можно сказать, что он обобщает функцию  `accumulate`, вычисляя не только сумму или минимум всех элементов, но и сумму на любом префиксе — начале массива.

Как и  `accumulate`, алгоритм  `partial_sum`  даёт слишком жёсткие гарантии на порядок вычислений. Поэтому его версии, поддерживающие параллельность, называются по-другому. Более того, появляется две версии, соответствующие двум способам вычисления таких префиксных сумм. В обоих случаях алгоритм получает N объектов и возвращает N сумм. Разница лишь в том, включает ли i-я сумма сам i-й элемент:

-   [`inclusive_scan`](https://en.cppreference.com/w/cpp/algorithm/inclusive_scan)  возвращает первый элемент, сумму первых двух, первых трёх, а последней — сумму всех. То есть i-я сумма включает в себя i-й элемент.
-   [`exclusive_scan`](https://en.cppreference.com/w/cpp/algorithm/exclusive_scan)  возвращает начальный элемент (например, 0), первый, сумму первых двух, а последней — сумму всех, кроме последнего. То есть i-я сумма не включает i-й элемент.

Лучше всего разобраться на примере. Пусть есть данные о количестве котов, поступавших в приют каждый день — вектор  `cat_count_daily`. Scan-алгоритмы позволят вычислить, сколько котов суммарно оказывалось в приюте в каждый из дней. Inclusive-версия будет содержать данные на конец каждого дня, и в конце последнего дня мы узнаем суммарное количество котов. А exclusive-версия хранит данные на начало каждого дня, и в начале первого дня мы не будем видеть ни одного кота.

```cpp
#include <iostream>
#include <numeric>
#include <vector>

using namespace std;

int main() {
    const vector<int> cat_count_daily = {1, 7, 2, 6, 9};
    // 1 кот в первый день, 7 во второй и т. д.

    vector<int> cat_count_cumulative(cat_count_daily.size());

    inclusive_scan(cat_count_daily.begin(), cat_count_daily.end(),
                   cat_count_cumulative.begin());
    cout << "Количество котов на конец каждого дня: ";
    for (const int count : cat_count_cumulative) {
        cout << count << " ";
    }
    cout << endl;

    exclusive_scan(cat_count_daily.begin(), cat_count_daily.end(),
                   cat_count_cumulative.begin(),
                   0);
    cout << "Количество котов на начало каждого дня: ";
    for (const int count : cat_count_cumulative) {
        cout << count << " ";
    }
    cout << endl;
}

```

Вывод будет таким:

```
Количество котов на конец каждого дня: 1 8 10 16 25 
Количество котов на начало каждого дня: 0 1 8 10 16

```

----------

Почему exclusive-версия требует передать начальное значение (в данном примере ноль), а inclusive — нет?

-   Exclusive-версия работает с более широким спектром группирующих операций и потому не может определить подходящее начальное значение.
    
-   Inclusive-версия не нуждается в начальном значении, потому что можно всё прибавлять к первому элементу.
    
-   В inclusive-версии «всё включено», в том числе и начальное значение. Если хорошо попросить, она и остальные аргументы додумает за разработчика.
    

Как  `inclusive_scan`  обобщает  `reduce`, так  `transform_inclusive_scan`  обобщает  `transform_reduce`  и позволяет применить преобразование ко всем элементам перед вычислением сумм. Например, transform-операция может помочь достать нужное поле из структуры:

```cpp
#include <functional>
#include <iostream>
#include <numeric>
#include <vector>

using namespace std;

struct DailyStat {
    int day_id;
    int cat_count;
};

int main() {
    const vector<DailyStat> daily_stats = {
        {15, 1},  // 1 кот 15-го числа
        {16, 7},  // 7 котов 16-го числа
        {17, 2},
        {18, 6},
        {19, 9}
    };

    vector<int> cat_count_cumulative(daily_stats.size());

    transform_inclusive_scan(
        daily_stats.begin(), daily_stats.end(),
        cat_count_cumulative.begin(),
        plus<>{},
        [](const DailyStat& stat) { return stat.cat_count; }
    );
    cout << "Количество котов на конец каждого дня: ";
    for (const int count : cat_count_cumulative) {
        cout << count << " ";
    }
    cout << endl;

    transform_exclusive_scan(
        daily_stats.begin(), daily_stats.end(),
        cat_count_cumulative.begin(),
        0,
        plus<>{},
        [](const DailyStat& stat) { return stat.cat_count; }
    );
    cout << "Количество котов на начало каждого дня: ";
    for (const int count : cat_count_cumulative) {
        cout << count << " ";
    }
    cout << endl;
}

```

Вывод всё тот же:

```
Количество котов на конец каждого дня: 1 8 10 16 25 
Количество котов на начало каждого дня: 0 1 8 10 16

```

В отличие от  `transform`  и  `transform_reduce`, обе функции  `transform_*_scan`  не умеют принимать два входных диапазона и применять преобразование к парам соответствующих элементов. Когда это требуется, нужно отдельно вызвать  `transform`, сложить результат в отдельный контейнер или в один из существующих, а для него уже вызвать  `*_scan`.

----------

Почему нельзя было сделать одну функцию, вычисляющую N+1 префиксных сумм: и нулевую, и сумму всех элементов?

-   Удобно, когда функция возвращает столько же объектов, сколько принимает на вход. Это позволяет записывать результат на место входных данных без дополительного выделения памяти.
    
-   Алгоритмы стандартной библиотеки должны заранее понимать, сколько объектов будет записано в выходной итератор.
    
-   Распараллеливание наиболее эффективно, когда функция возвращает столько же объектов, сколько принимает на вход.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Почему exclusive-версия требует передать начальное значение (в данном примере ноль), а inclusive — нет?

-   **(-)**  Exclusive-версия работает с более широким спектром группирующих операций и потому не может определить подходящее начальное значение.

> Нет, обе версии могут принять произвольную бинарную операцию вместо суммы.

-   **(+)**  Inclusive-версия не нуждается в начальном значении, потому что можно всё прибавлять к первому элементу.
    
-   **(-)**  В inclusive-версии «всё включено», в том числе и начальное значение. Если хорошо попросить, она и остальные аргументы додумает за разработчика.
    

> Мечты, мечты.

----------

Почему нельзя было сделать одну функцию, вычисляющую N+1 префиксных сумм: и нулевую, и сумму всех элементов?

-   **(+)**  Удобно, когда функция возвращает столько же объектов, сколько принимает на вход. Это позволяет записывать результат на место входных данных без дополительного выделения памяти.
    
-   **(-)**  Алгоритмы стандартной библиотеки должны заранее понимать, сколько объектов будет записано в выходной итератор.
    

> Нет,  `copy_if`  же как-то работает.

-   **(-)**  Распараллеливание наиболее эффективно, когда функция возвращает столько же объектов, сколько принимает на вход.

> Один элемент погоды не сделает, inclusive-версии ничего не стоит записать дополнительный ноль.

</details>
