<details>
<summary>Теория:</summary>

# Концепция MapReduce, функция transform

Удобно, когда ускоряется готовый алгоритм. Но иногда нуждающаяся в оптимизации программа устроена сложно. В этом случае помогает посмотреть на неё с точки зрения концепции MapReduce, популярной в различных областях распределённых вычислений.

В рамках этой концепции алгоритм стараются представить следующим образом:

1.  Стадия преобразования (map, transform). На вход ей подаётся исходный набор объектов. Задача этой стадии — применить некоторую функцию к каждому объекту. Важно, чтобы применяемая к каждому объекту операция могла выполняться независимо от других: только тогда этот этап будет эффективно распараллеливаться. Например, если в вашем распоряжении два процессора, можно попросить первый выполнить преобразование для первой половины объектов, а второй процессор — для второй половины. Иногда преобразующей функции разрешается отфильтровать некоторые объекты.
2.  Стадия группировки (reduce). На вход ей подаётся результат map-стадии — преобразованные объекты. Выход — результат применения некоторой группирующей функции ко входному набору. Это может быть сумма, произведение, минимум или другая подобная бинарная операция. Reduce-стадия тоже параллелится: можно попросить первый процессор вычислить сумму для первой половины, второй процессор — для второй и просуммировать результаты.

Потренируемся и представим в таком виде алгоритм  `count`  из прошлого урока. Его задача заключалась в подсчёте количества пробелов в строке.

1.  Map-стадия:
    -   Вход: набор символов строки;
    -   Операция: будет ли конкретный символ пробелом? Если да — 1. Если нет — 0;
    -   Выход: набор чисел 0 и 1, где 1 означает, что соответствующий символ — пробел.
2.  Reduce-стадия:
    -   Вход: набор чисел 0 и 1;
    -   Операция: сумма;
    -   Выход: количество единиц во входном наборе, то есть количество пробелов.

И для каждой стадии в отдельности, и для их комбинации в С++ есть готовые функции-алгоритмы.

[Функция  `transform`](https://en.cppreference.com/w/cpp/algorithm/transform)  из  `<algorithm>`  принимает диапазон входных объектов, выходной итератор для записи результата и преобразующую функцию. Так можно реализовать map-стадию подсчёта пробелов:

```cpp
#include <algorithm>
#include <execution>
#include <iostream>
#include <string_view>

using namespace std;

int main() {
    const string_view s = "pretty little octopus"sv;
    vector<int> marks(s.size());
    transform(execution::par, s.begin(), s.end(), marks.begin(),
              [](char c) { return c == ' '; });
    for (const int mark : marks) {
        cout << mark;
    }
    cout << endl;
    // выведет 000000100000010000000
}

```

Вызов с  `execution::par`  приведён для простой демонстрации. Для короткой строки нет смысла распараллеливать такую операцию.

----------

Можно ли объявить вектор  `marks`  пустым, а в качестве выходного итератора в  `transform`  передать  `back_inserter(marks)`?

-   Да, это будет работать аналогично. Разве что вызов  `reserve`  не помешал бы.
    
-   Нет, код будет работать неверно.
    
-   Нет, код не скомпилируется.
    

Обратите внимание на версию функции  `transform`  для двух входных диапазонов одинаковой длины. В этом случае преобразующая функция принимает элемент первого диапазона, соответствующий ему элемент второго на той же позиции и комбинирует их. Скажем, если для набора кубиков у вас есть вектор их объёмов и вектор их плотностей, используя такую версию  `transform`  и операции умножения, можно получить вектор масс.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

Можно ли объявить вектор  `marks`  пустым, а в качестве выходного итератора в  `transform`  передать  `back_inserter(marks)`?

-   **(-)**  Да, это будет работать аналогично. Разве что вызов  `reserve`  не помешал бы.

> Посмотрите в  [документацию](https://en.cppreference.com/w/cpp/algorithm/transform): версия  `transform`  с  `ExecutionPolicy`  в качестве итератора для записи результата принимает только forward-итераторы.

-   **(-)**  Нет, код будет работать неверно.

> Если бы он скомпилировался, то действительно работал бы неверно: разные потоки пытались бы вставить в один и тот же вектор, ещё и в другом порядке. Но посмотрите в  [документацию](https://en.cppreference.com/w/cpp/algorithm/transform).

-   **(+)**  Нет, код не скомпилируется.

> Действительно, версия  `transform`  с  `ExecutionPolicy`  в качестве итератора для записи результата принимает только forward-итераторы. А если бы код и скомпилировался, то несколько потоков не смогли бы одновременно вставлять в один и тот же вектор — мы увидим это в третьей теме.

</details>
