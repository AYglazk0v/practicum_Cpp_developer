<details>
<summary>Теория:</summary>

# Введение

Вы уже знаете, что несколько потоков могут читать одни и те же данные, не мешая друг другу, — и применяли это при решении задач. Изменять общие данные в многопоточных программах опасно, и вы даже могли с этим столкнуться в заданиях.

В этой теме вы увидите, как многообразны проблемы, которые возникают в таких ситуациях. И, конечно же, разберёте различные способы координации потоков, желающих изменить общие данные.

</details>

<details>
<summary>Теория + тестирование:</summary>

# Состояние гонки

Ситуация, когда несколько процессов используют общие объекты и хотя бы один из них их изменяет, называется  **состояние гонки**. Продемонстрируем её на простом примере.

Представьте семью, у каждого члена которой есть доступ к банковскому счёту. За функциональность счёта отвечает класс  `Account`:

```cpp
class Account {
public:
    explicit Account(int value) : value_(value) {}
    int GetValue() const { return value_; }
    bool TrySpend(int plan) {
        if (value_ < plan) {
            return false;
        } else {
            value_ -= plan;
            return true;
        }
    }
private:
    int value_;
};

```

Ключевой метод здесь —  `TrySpend`: он принимает сумму, которую кто-нибудь планирует потратить, и, если денег на счёте пока достаточно, списывает её со счёта и возвращает  `true`. Иначе —  `false`, и ничего не происходит.

Каждый член семьи планирует некоторые покупки, и их стоимости хранятся в векторе целых чисел. Функция  `SpendAll`  принимает один такой вектор, поочерёдно пытается списать каждую сумму со счёта и возвращает потраченную сумму — стоимость всех покупок, для которых  `TrySpend`  завершился успешно.

```cpp
int SpendAll(Account& account, const vector<int>& plans) {
    int total_spent = 0;
    for (const int plan : plans) {
        if (account.TrySpend(plan)) {
            total_spent += plan;
        }
    }
    return total_spent;
}

```

План покупок для каждого члена семьи будем генерировать случайным образом:

```cpp
vector<int> GeneratePlans(mt19937& generator, int count = 1'000'000, int max_value = 1000) {
    vector<int> plans(count);
    for (int& plan : plans) {
        plan = uniform_int_distribution(1, max_value)(generator);
    }
    return plans;
}

```

Наконец, рассмотрим функцию  `main`: в ней сгенерируем случайные планы для каждого члена семьи, запустим асинхронные процессы трат и посмотрим, сколько потратит каждый:

```cpp
int main() {
    mt19937 generator;

    // генерируем случайный план для каждого члена семьи
    const vector<int> mother_plans   = GeneratePlans(generator);
    const vector<int> father_plans   = GeneratePlans(generator);
    const vector<int> son_plans      = GeneratePlans(generator);
    const vector<int> daughter_plans = GeneratePlans(generator);

    // на счету миллион
    Account account(1'000'000);

    // каждый асинхронно идёт тратить деньги
    vector<future<int>> spend_futures;
    for (const vector<int>* plans_ptr : {&mother_plans, &father_plans, &son_plans, &daughter_plans}) {
        spend_futures.push_back(async(SpendAll, ref(account), cref(*plans_ptr)));
    }

    // выводим сумму, потраченную каждым
    for (auto& spend_future : spend_futures) {
        cout << "Spent " << spend_future.get() << endl;
    }

    // выводим остаток на счёте
    cout << account.GetValue() << endl;
}

```

При запуске эта программа, скорее всего, выведет нечто достаточно произвольное. Например:

```
Spent 1154228
Spent 1655856
Spent 733617
Spent 728901
-478

```

Сумма потраченных денег превышает изначальный баланс на счёте! Да и баланс отрицательный.

Это объясняется конфликтом потоков в методе  `Account::TrySpend`. Представьте, что в него одновременно вошли два процесса:

```cpp
bool TrySpend(int plan) {
    if (value_ < plan) {  // ← поток 1
        return false;
    } else {
        value_ -= plan;
        return true;
    }
}

```

----------

```cpp
bool TrySpend(int plan) {
    if (value_ < plan) {  // ← поток 2
        return false;
    } else {
        value_ -= plan;
        return true;
    }
}

```

Если денег достаточно на трату только одного из потоков, при одновременной проверке указанного условия это не обнаружится, оба потока перейдут в ветку  `else`:

```cpp
bool TrySpend(int plan) {
    if (value_ < plan) {
        return false;
    } else {
        value_ -= plan;  // ← поток 1
        return true;
    }
}

```

----------

```cpp
bool TrySpend(int plan) {
    if (value_ < plan) {
        return false;
    } else {
        value_ -= plan;  // ← поток 2
        return true;
    }
}

```

Если «повезёт», вычитание случится не одновременно — и тогда баланс уйдёт в минус. Но чаще всего одно из действий не выполнится, и трата не отразится в балансе. Отсюда и неучтённые траты.

В первом случае — с одновременным сравнением — мы не изменяем данные, и в этом конкретном месте программа ведёт себя корректно. Но из-за того, что этот код не потокобезопасен, процессы обнаруживают себя в else-ветке тогда, когда мы этого не хотим.

Во втором случае — с одновременным вычитанием — мы столкнулись с классической проблемой изменения одного объекта разными потоками. Здесь мы имели дело с целым числом, и вычитания иногда не срабатывали. В случае же более сложных объектов — например контейнеров, — высока вероятность промахнуться по памяти и получить падение программы. Так или иначе, мы столкнулись с неопределённым поведением.

----------

Отметьте все ситуации, в которых при одновременной работе нескольких потоков возникает состояние гонки. Под вектором везде имеется в виду вектор целых чисел.

-   Потоки обращаются к элементам одного вектора, никак их не изменяя.
    
-   Потоки обращаются к элементам одного вектора, иногда их изменяя.
    
-   Потоки обращаются к элементам одного вектора, иногда их изменяя. При этом каждый поток обращается к своему набору индексов, так что к каждому элементу обращается не больше одного потока.
    
-   Потоки вызывают  `push_back`  для одного вектора.
    
-   Потоки вызывают  `push_back`  для одного вектора. Предварительно вызван  `reserve`  с достаточно большой вместимостью, и реаллокаций не возникает.
    
-   Потоки обращаются к значениям одного словаря через метод  `at`, никак их не изменяя.
    
-   Потоки обращаются к значениям одного словаря через оператор  `[]`, никак эти значения не изменяя.
    
-   Потоки обращаются к значениям одного словаря через оператор  `[]`, никак эти значения не изменяя. При этом каждый поток обращается к своему набору ключей, так что к каждому значению обращается не больше одного потока.

</details>

<details>
<summary>Ответы:</summary>

# Ответы на задания

----------

Отметьте все ситуации, в которых при одновременной работе нескольких потоков возникает состояние гонки. Под вектором везде имеется в виду вектор целых чисел.

-   **(-)**  Потоки обращаются к элементам одного вектора, никак их не изменяя.

> Потоки обращаются к элементам одного вектора, никак их не изменяя. Текст ошибки: Никакие данные не меняются — нет гонки.

-   **(+)**  Потоки обращаются к элементам одного вектора, иногда их изменяя.
    
-   **(-)**  Потоки обращаются к элементам одного вектора, иногда их изменяя. При этом каждый поток обращается к своему набору индексов, так что к каждому элементу обращается не больше одного потока.
    

> Некоторые данные меняются, но не более чем одним потоком — значит, гонки нет.

-   **(+)**  Потоки вызывают  `push_back`  для одного вектора.
    
-   **(+)**  Потоки вызывают  `push_back`  для одного вектора. Предварительно вызван  `reserve`  с достаточно большой вместимостью, и реаллокаций не возникает.
    
-   **(-)**  Потоки обращаются к значениям одного словаря через метод  `at`, никак их не изменяя.
    

> Никакие данные не меняются — нет гонки. Спасибо методу  `at`  за константность.

-   **(+)**  Потоки обращаются к значениям одного словаря через оператор  `[]`, никак эти значения не изменяя.
    
-   **(+)**  Потоки обращаются к значениям одного словаря через оператор  `[]`, никак эти значения не изменяя. При этом каждый поток обращается к своему набору ключей, так что к каждому значению обращается не больше одного потока.

</details>

