<details>  
<summary>Пары в компараторах:</summary>

<p>В прошлом уроке мы применили логические выражения, чтобы сравнить два события сначала по давности, а затем по критичности:</p>

<pre><code class="language-cpp">sort(observations.begin(), observations.end(),
     [](const AnimalObservation&amp; lhs, const AnimalObservation&amp; rhs) {
		return lhs.days_ago &lt; rhs.days_ago
			|| (lhs.days_ago == rhs.days_ago
				&amp;&amp; lhs.health_level &lt; rhs.health_level);
     });
</code></pre>

<p>Такая задача возникает довольно часто, поэтому её давно автоматизировали. Тот же результат получим, если создадим пары нужных характеристик для <code>lhs</code> и <code>rhs</code> и сравним их между собой:</p>

<pre><code class="language-cpp">sort(observations.begin(), observations.end(),
	[](const AnimalObservation&amp; lhs, const AnimalObservation&amp; rhs) {
		return pair(lhs.days_ago, lhs.health_level)
			&lt; pair(rhs.days_ago, rhs.health_level);
	});
</code></pre>

<p>Пары сравниваются так, как нам нужно: сначала по возрастанию первой компоненты, а при её равенстве — по возрастанию второй. Такой порядок называется лексикографическим<strong>.</strong> Его вы уже встречали при сортировке строк. Строки мы упорядочиваем сначала по первой букве, затем по второй и по третьей. Точно так же сортируются векторы.</p>

<p>Если у вас старый компилятор, и последний пример не компилируется из-за ошибки <code>missing template arguments before '(' token</code>, напишите <code>make_pair</code>. Так компилятор сможет сам определить тип компонента пары, и вам не придётся указывать <code>pair&lt;int, int&gt;</code>.</p>

<p>Вы научились применять пары в компараторах. В следующем уроке узнаете, как сравнить более двух параметров.</p>

</details>  

<details>  
<summary>Задание 1:</summary>
<p>Перепишите компаратор из предыдущего урока, используя пары.</p>

<h3>Подсказка</h3>

<p>Сравнить <code>lhs</code> и <code>rhs</code> по убыванию сначала одной характеристики, а затем другой — то же самое, что сравнить по убыванию пары из этих характеристик. Или по возрастанию, если поменять местами <code>lhs</code> и <code>rhs</code>.</p>

</details>

<details>  
<summary>Задание 2:</summary>
<p>Введём статусы документов: <code>ACTUAL</code> (актуальные), <code>EXPIRED</code> (просроченные) и <code>DELETED</code> (удалённые). Исправьте компаратор так, чтобы после сортировки порядок документов был следующим:</p>
<ol>
<li><p>актуальные,</p></li>
<li><p>просроченные,</p></li>
<li><p>удалённые.</p></li>
</ol>
<p>Внутри каждого статуса документы должны быть упорядочены по убыванию рейтинга, а затем по убыванию релевантности.</p>
<p>Код из тренажёра должен вывести следующее:</p>
<pre><code>104 0 0.3 5
102 0 1.2 4
100 0 0.5 4
101 1 0.5 4
103 2 1.2 4
</code></pre>

<h3>Подсказка</h3>
<p>Подставить все три поля в пару, к сожалению, не выйдет. Но можно написать логическое выражение ещё большей вложенности. А можно скомбинировать два подхода: самостоятельно сравнить статусы и, если они равны, — сравнить пары двух оставшихся характеристик.</p>
</details>  
