<details>  
<summary>Пары в компараторах:</summary>

# Кортежи. Начало

В прошлых уроках мы определили структуру  `AnimalObservation`:

```cpp
struct AnimalObservation {
	string name;
	int days_ago;
	int health_level;
};

```

Для сортировки значений  `days_ago`  и  `health_level`  применили пару. Но если решим сортировать сначала по давности наблюдения, затем по уровню здоровья, а при равенстве обеих числовых характеристик — по имени, пары в компараторе уже не подойдут.

Здесь нужен класс  `tuple`  из одноимённой библиотеки. Он собирает в кортеж набор объектов произвольного размера. Объектов в кортеже может быть сколько угодно.

__________________________________________________________________________________________________________________________

Кортежи, как и пары, сравниваются лексикографически:

```cpp
const AnimalObservation lhs = {"Степан"s, 2, 8};
const AnimalObservation rhs = {"Захар"s,  2, 8};
cout << (tuple(lhs.days_ago, lhs.health_level, lhs.name)
		 < tuple(rhs.days_ago, rhs.health_level, rhs.name)) << endl;
// выведет 0, так как "Степан"s > "Захар"s

```

Если такой код не скомпилируется, используйте функцию  `make_tuple`. Она работает в более старых компиляторах.

Кортежи позволяют писать простые и понятные операторы сравнения для структур.

</details>  

<details>  
<summary>Задание 1:</summary>
<p>Перепишите компаратор из предыдущего урока, применив кортежи.</p>

<p>Код должен вывести следующее:</p>

<pre><code>104 0 0.3 5
102 0 1.2 4
100 0 0.5 4
101 1 0.5 4
103 2 1.2 4
</code></pre>

<h3>Подсказка</h3>

<p>Документы нужно упорядочить сначала по возрастанию статусов, а при их равенстве — по убыванию рейтинга, затем по убыванию релевантности. Но при сравнении кортежей все компоненты сравниваются одинаково. Поэтому при создании кортежа удобно умножить рейтинг и релевантность на −1.</p>

</details>

<details>  
<summary>Задание 2:</summary>
<p>Копирование кода — это зло. В компараторе продублирована половина кода — создание кортежа по объекту. Когда такой код написан для <code>lhs</code>, велик соблазн его скопировать и исправить <code>lhs</code> на <code>rhs</code>. Но исправляя, можем что-то упустить в одном из параметров. Вынесите создание кортежа в отдельный метод <code>MakeKey</code> структуры <code>Document</code>.</p>

<p><code>MakeKey</code> должен возвращать кортеж, который можно сравнивать вместо исходных объектов — так, чтобы компаратор выглядел просто как <code>return lhs.MakeKey() &lt; rhs.MakeKey();</code></p>

<h3>Подсказка</h3>

<p>Явно указывать возвращаемый тип для нового метода не нужно. Укажите вместо него <code>auto</code>, а в теле метода верните <code>tuple(...)</code> — компилятор сам поймёт, о каком типе речь.</p>
</details>  
