<details>  
<summary>Введение:</summary>  
<p>На вводном курсе вы изучили стандартный целочисленный тип <code>int</code>. В этой теме познакомитесь с другими целочисленными типами С++, узнаете их размеры и правила преобразования друг к другу. Научитесь избегать переполнения типов. И убедитесь, что компилятор — ваш заклятый друг.</p>

<p>Вы уже знаете основы С++ и умеете писать на нём довольно сложные программы. Выполните задания и вспомните всё.</p>
<h1>Ограниченность памяти и переполнение</h1>

<p>Вы уже знаете, что целочисленные типы данных отличаются диапазоном значений. Если значение переменной находится вне диапазона значений указанного типа, происходит переполнение.</p>

<p>Рассмотрим примеры. Возьмём максимальное значение типа <code>int</code> и прибавим к нему единицу:</p>

<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;limits&gt;

using namespace std;

int main() {
    cout &lt;&lt; numeric_limits&lt;int&gt;::max() + 1 &lt;&lt; endl;
}
</code></pre>

<p>Современные компиляторы даже выдадут предупреждение, что мы встали на скользкую дорожку:</p>

<pre><code> warning: integer overflow in expression of type ‘int’ results in ‘-2147483648’ [-Woverflow]
</code></pre>

<p>И действительно, при запуске вместо ожидаемого 2 147 483 648 получаем отрицательное число — минимальное значение типа <code>int</code>:</p>

<pre><code class="language-cpp">-2147483648
</code></pre>

<p>Это произошло, потому что значение выражения в <code>int</code> не поместилось.</p>

<p>Теперь возьмём значение меньше минимального:</p>

<pre><code class="language-cpp">cout &lt;&lt; numeric_limits&lt;int&gt;::min() - 1 &lt;&lt; endl;
</code></pre>

<p>Снова предупреждение и снова не то, чего ожидали:</p>

<pre><code class="language-cpp">2147483647
</code></pre>

<p>Берём число на единицу больше, чем максимум, — получаем минимум. Берём число на единицу меньше, чем минимум, — получаем максимум. Такое в С++ переполнение.</p>

<p>Более практичный пример. Допустим, у нас есть два числа типа <code>int</code>: два миллиарда и один миллиард. Вычислим среднее арифметическое. Оба числа не превышают максимального значения <code>int</code>. Предполагаем, что их среднее арифметическое не превысит два миллиарда и тоже поместится в <code>int</code>. Спокойно пишем программу:</p>

<pre><code class="language-cpp">// разряды в больших числах удобно разделять символом '
int x = 2'000'000'000;
int y = 1'000'000'000;
cout &lt;&lt; (x + y) / 2 &lt;&lt; endl;
</code></pre>

<p>Вместо ожидаемых полутора миллиардов получаем:</p>

<pre><code class="language-cpp">-647483648
</code></pre>

<p>С++ сначала выполнил действие в скобках: сложил <code>x</code> и <code>y</code>. Получилось три миллиарда — число, которое превышает максимальное значение типа <code>int</code>. После этого всё и пошло наперекосяк.</p>

<p>Выбирая тип данных, нужно продумать каждый сегмент программы. Если промежуточные вычисления не поместятся в ваш тип, рискуете получить большое отрицательное число — верный признак переполнения. А когда выполняете серию арифметических операций, переполнение можете и вовсе не заметить.</p>

<p>Посмотрим, как это работает с беззнаковыми типами. Сохраним переменную <code>x</code> со значением два миллиарда в беззнаковую переменную <code>y</code> и выведем обе:</p>

<pre><code class="language-cpp">int x = 2'000'000'000;
unsigned int y = x;
cout &lt;&lt; x &lt;&lt; &quot; &quot;s &lt;&lt; y &lt;&lt; endl;
</code></pre>

<p>Запустим код и увидим, что всё в порядке, ведь это значение помещается и в <code>int</code>, и в <code>unsigned int</code>:</p>

<pre><code class="language-cpp">2000000000 2000000000
</code></pre>

<p>Теперь сохраним в переменную <code>x</code> отрицательное значение:</p>

<pre><code class="language-cpp">int x = -2'000'000'000;
unsigned int y = x;
cout &lt;&lt; x &lt;&lt; &quot; &quot;s &lt;&lt; y &lt;&lt; endl;
</code></pre>

<p>Запустим код. В беззнаковый тип наше значение не поместилось:</p>

<pre><code class="language-cpp">-2000000000 2294967296
</code></pre>

<p>Так происходит переполнение беззнакового целочисленного типа.</p>

<p>С одним беззнаковым типом мы уже сталкивались — это тип <code>size_t</code>. Во-первых, именно его возвращает метод <code>size</code> контейнеров. Во-вторых, результат вызова оператора <code>sizeof</code> тоже имеет тип <code>size_t</code>. Это вполне логично: размер чего-либо не может быть отрицательным.</p>

<p>Размер самого типа <code>size_t</code> зависит от разрядности вашей операционной системы. Если система 32-битная — размер <code>size_t</code> составит 32 бита (четыре байта), если 64-битная — 64 бита (восемь байт).</p>

<p>Вернёмся к задаче о среднем рейтинге. Имея рейтинги −5, 1 и −2, найдём их среднее арифметическое:</p>

<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int ComputeAverageRating(const vector&lt;int&gt;&amp; ratings) {
    if (ratings.empty()) {
        return 0;
    }
    int rating_sum = 0;
    for (const int rating : ratings) {
        rating_sum += rating;
    }
    return rating_sum / ratings.size();
}

int main() {
    cout &lt;&lt; ComputeAverageRating({1, -7, 3}) &lt;&lt; endl;
}
</code></pre>

<p>Средний рейтинг должен составить (−5+1−2) / 3 = −2. Но результат намекает на переполнение:</p>

<pre><code>1431655763
</code></pre>

<p>Дело в финальном выражении функции: <code>rating_sum / ratings.size()</code>. Чтобы разделить <code>int</code> на <code>size_t</code>, компилятор привёл оба операнда к беззнаковому типу. В нём −2 не сохранить.</p>

<p>Поэтому и помогало предварительно привести размер вектора к знаковому типу <code>int</code>:</p>

<pre><code class="language-cpp">return rating_sum / static_cast&lt;int&gt;(ratings.size());
</code></pre>

<p>Избегайте переполнения типов: даже если код работает при ваших текущих настройках, он может дать сбой на другом компиляторе или ОС. Ситуаций, когда переполнение приносит пользу, — мало. Едва ли вы с ними столкнётесь.</p>

<p>Выбирайте подходящие типы и преобразовывайте их оператором <code>static_cast</code>. В следующем уроке вы научитесь этому на конкретных примерах и узнаете о нюансах приведения операндов к общему типу.</p>

</details>  

<details>  
<summary>Задание:</summary> 
<p>Пощупайте переполнение типов <code>int64_t</code> и <code>uint64_t</code> на простом примере.</p>

<p>Запомните в переменную <code>min</code> минимальное значение типа <code>int64_t</code>, а в переменную <code>max</code> — максимальное значение <code>uint64_t</code>.</p>

<p>Никак не преобразуя типы, выведите 5 чисел, каждое на новой строке:</p>

<ul>
<li><code>min</code></li>
<li><code>max</code></li>
<li>Сумму <code>min</code> и <code>max</code></li>
<li>Удвоенный <code>min</code></li>
<li>Удвоенный <code>max</code></li>
</ul>

<p>Посмотрите на вывод — один из результатов вычислений будет неожиданным.</p>

<h3>Подсказка</h3>

<p>Обратите внимание на типы <code>min</code> и <code>max</code>: они должны быть <code>int64_t</code> и <code>uint64_t</code>. Вычисляя сумму и произведение, не преобразуйте аргументы: суть задачи именно в демонстрации переполнения.</p>
</details>  
