<details>  
<summary>Теория:</summary>  


# Ранжирование по TF-IDF

Сортировка документов позволяет отображать сначала те результаты поиска, у которых больше общих слов с запросом. Такое ранжирование делает поиск эффективнее.

Но не все слова одинаково полезны при ранжировании. Встретить в документе слово «ошейник» гораздо важнее, чем слово «кличка»: понятно, что у большинства пропавших животных есть имя, а вот ошейником могут похвастаться не все. Ошейник — важное отличие.

Полезность слов оценивают понятием inverse document frequency или IDF. Эта величина — свойство слова, а не документа. Чем в большем количестве документов есть слово, тем ниже его IDF. Вычисляют IDF так:

-   Количество всех документов делят на количество тех, где встречается слово. Не встречающиеся нигде слова в расчёт не берут, поэтому деления на ноль опасаться не стоит. Важно, встречается ли слово в документе, а сколько раз встречается — всё равно.
-   К результату деления применяют логарифм — функцию  `log`  из библиотеки  `<cmath>`.

Возьмите знакомый пример из трёх документов:

1.  `белый кот и модный ошейник`
    
2.  `пушистый кот пушистый хвост`
    
3.  `ухоженный пёс выразительные глаза`
    

Вычислите IDF слова  `кот`. Оно встречается в двух документах из трёх: 0 и 1. 3 / 2 = 1,5. Примени́те логарифм и полу́чите примерно 0,4055. Это и есть IDF.

Слово  `ошейник`  есть только в одном документе, так что его IDF равен log(3 / 1) = log(3) ≈ 1,0986.

Второй способ улучшить ранжирование — выше располагать документы, где искомое слово встречается более одного раза. Здесь нужно рассчитать term frequency или TF. Для конкретного слова и конкретного документа это доля, которую данное слово занимает среди всех.

Рассчитайте TF слова  `кот`  в документе 1. Всего слов в этом документе четыре, из них  `кот`  — только одно. 1 / 4 = 0,25. А слово  `пушистый`  встречается дважды, так что его TF в этом документе будет 2 / 4 = 0,5.

С TF и IDF вы точнее посчитаете релевантность документа запросу и улучшите ранжирование. Это делается так:

-   вычисляется IDF каждого слова в запросе,
-   вычисляется TF каждого слова запроса в документе,
-   IDF каждого слова запроса умножается на TF этого слова в этом документе,
-   все произведения IDF и TF в документе суммируются.

Чем больше сумма, тем релевантнее документ. Ранжирование, как и прежде, происходит по убыванию релевантности. Взгляните на пример.

![1.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint1/%D0%98%D1%82%D0%BE%D0%B3%D0%BE%D0%B2%D1%8B%D0%B5_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82/%D0%A0%D0%B0%D0%BD%D0%B6%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BF%D0%BE_TF-IDF/image/1.png?raw=true)

По запросу  `пушистый ухоженный кот`  нашлись документы:

1.  `белый кот и модный ошейник`
    
2.  `пушистый кот пушистый хвост`
    
3.  `ухоженный пёс выразительные глаза`
    

Чтобы узнать их релевантность, сначала для каждого из трёх слов запроса нужно вычислить IDF:

### IDF слов запроса

| Name |пушистый|ухоженный|кот|
|--|--|--|--|
| 0. белый кот и модный ошейник | не встречается|не встречается|встречается|
| 1. пушистый кот пушистый хвост |встречается (неважно, сколько раз)|	не встречается|встречается|
| 2. ухоженный пёс выразительные глаза |не встречается|встречается|не встречается|
| IDF |	log(3 / 1) ≈ 1,0986|log(3 / 1) ≈ 1,0986|log(3 / 2) ≈ 0,4055|

Затем посчитать TF слов запроса в каждом документе:



### TF слов запроса в документах

| Name |пушистый|ухоженный|кот|
|--|--|--|--|
| IDF |	1,0986|1,0986|0,4055|
| 0. белый кот и модный ошейник |0 / 4 = 0|0 / 4 = 0|1 / 4 = 0,25|
| 1. пушистый кот пушистый хвост |2 / 4 = 0,5|0 / 4 = 0|1 / 4 = 0,25|
| 2. ухоженный пёс выразительные глаза |0 / 4 = 0|1 / 4 = 0,25|0 / 4 = 0|


Умножить TF слова на его IDF и вычислить сумму таких произведений для каждого документа:

### TF-IDF

| Документ |пушистый|ухоженный|кот| Сумма TF-IDF по словам |
|--|--|--|--|--|
| 0. белый кот и модный ошейник |0 * 1,0986 = 0|0 * 1,0986 = 0|0,25 * 0,4055 ≈ 0,1014| 0,1014|
| 1. пушистый кот пушистый хвост |0,5 * 1,0986 = 0,5493|0 * 1,0986 = 0|0,25 * 0,4055 ≈ 0,1014| 0,6507 |
| 2. ухоженный пёс выразительные глаза | 0 * 1,0986 = 0|0,25 * 1,0986 ≈ 0,2746|0 * 0,4055 = 0| 0,2746 |



Суммы в правом столбце — это релевантность документов. После ранжирования результат будет таким:

![2.png](https://github.com/AYglazk0v/practicum_Cpp_developer/blob/main/sprint1/%D0%98%D1%82%D0%BE%D0%B3%D0%BE%D0%B2%D1%8B%D0%B5_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82/%D0%A0%D0%B0%D0%BD%D0%B6%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BF%D0%BE_TF-IDF/image/2.png?raw=true)

Документ 1 ожидаемо оказался самым релевантным — из-за пересечения с запросом по двум словам и пушистости кота. Документы 0 и 2 одинаково неинтересны, но второй релевантнее, потому что слово «кот» в нулевом более частотное, а значит, менее интересное.

Словам  `кот`  и  `пёс`  можно придать одинаковую значимость, завысив их IDF. Но нам интересно общее решение.

</details>  

<details>  
<summary>Задание:</summary>

<p>Переведите вычисление релевантности на формулу TF-IDF.</p>

<p>Будьте внимательны с повторами: теперь они важны и кратно увеличивают релевантность по соответствующему слову. Повторение слова в документе увеличивает TF. А сколько раз слово повторится в запросе, столько раз нужно будет перемножить TF и IDF этого слова.</p>

<p>Чтобы сохранить в классе поисковой системы текущее количество документов в ней и избежать беспорядка, поле <code>document_count</code> нужно по умолчанию проинициализировать нулём при объявлении: <code>int document_count_ = 0;</code>.</p>

<h3>Пример</h3>

<p><strong>Ввод</strong></p>

<pre><code>и в на
3
белый кот и модный ошейник
пушистый кот пушистый хвост
ухоженный пёс выразительные глаза
пушистый ухоженный кот
</code></pre>

<p><strong>Вывод</strong></p>

<pre><code>{ document_id = 1, relevance = 0.650672 }
{ document_id = 2, relevance = 0.274653 }
{ document_id = 0, relevance = 0.101366 }
</code></pre>

<h3>Комментарии</h3>

<p>По умолчанию при выводе вещественных чисел типа <code>double</code> отображаются шесть знаков после запятой, мы же считали с точностью до четырёх знаков. Поэтому есть небольшие расхождения в результате.</p>

<h3>Подсказка</h3>

<p>Как и раньше, для поиска документов и вычисления их релевантности хватит двойной вложенности циклов <code>for</code>: внешний — по словам запроса, внутренний — по документам, где это слово встречается.</p>

<p>Помимо добавления количества документов, вам достаточно будет переделать словарь «слово → документы» в более сложную структуру <code>map&lt;string, map&lt;int, double&gt;&gt; word_to_document_freqs_</code>, сопоставляющую каждому слову словарь «документ → TF». Подумайте, как с этими данными быстро вычислять IDF.</p>
    
    
</details>
