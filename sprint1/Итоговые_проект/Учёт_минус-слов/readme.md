<details>  
<summary>Введение:</summary>  

<p>Вы написали самодостаточную поисковую систему, усовершенствовали её и параллельно изучили основы С++. Впечатляющий результат!</p>

<p>Но любая серьёзная программа обречена на развитие: её будут переписывать и улучшать по мере появления новых требований. Поэтому важно проектировать код так, чтобы вносить изменения в него было легко, и не приходилось ради одного параметра в <strong>ранжировании</strong> переписывать половину функций.</p>

<p>В этой теме вы расширите возможности своей поисковой системы. Какие функции и классы для этого применить — решать вам. Главное, чтобы программа выполняла задачу и выдавала конкретный результат на имеющихся входных данных. Вперёд!</p>

</details> 

<details>  
<summary>Теория:</summary>  

<h1>Учёт минус-слов</h1>

<p>Вы уже знаете, что минус-слова исключают из результатов поиска документы, содержащие эти слова.</p>

<p>Пусть, например, в системе есть такие документы:</p>

<ol>
<li><p><code>белый кот и модный ошейник</code></p></li>
<li><p><code>пушистый кот пушистый хвост</code></p></li>
<li><p><code>ухоженный пёс выразительные глаза</code></p></li>
</ol>

<p>По запросу <code>кот</code> найдутся документы 0 и 1. Но если кот ушёл без ошейника, запрос нужно уточнить. Если ввести <code>кот без ошейника</code>, вряд ли получится ожидаемый результат. Предлоги поисковая система выкидывает, да и очевидцы едва ли будут явно указывать на отсутствие ошейника у кота.</p>

<p>А запрос <code>кот -ошейник</code> подойдёт идеально. Минус-слово «-ошейник» позволит исключить из результата документ 0, где слово «ошейник» есть. Документ 1 останется, потому что в нём об ошейнике ни слова — зато какой хвост!</p>

<p>Теперь нужно указать несколько минус-слов. По запросу <code>кот -ошейник -пушистый</code> не найдётся ничего, потому что <code>-ошейник</code> исключило документ 0, а <code>-пушистый</code> — документ 1. Порядок слов всё так же не имеет значения: запрос <code>-пушистый кот -ошейник</code> ничем не отличается от <code>кот -ошейник -пушистый</code>.</p>

<p>Стоп-слово в запросе не нужно учитывать при поиске, даже если оно с минусом. Слова без минуса пусть называются плюс-словами.</p>

<p>В нестандартных ситуациях программа должна вести себя так:</p>

<ul>
<li>Если в запросе нет плюс-слов, ничего найтись не должно.</li>
<li>Если одно и то же слово будет в запросе и с минусом, и без, считается, что оно есть только с минусом. Например, по запросу <code>кот вот -кот</code> никогда не найдётся ничего, если <code>вот</code> — стоп-слово. А по запросу <code>ухоженный кот -кот</code> поисковая система покажет документ <code>ухоженный пёс выразительные глаза</code>, но не покажет <code>пушистый кот пушистый хвост</code>.</li>
</ul>

</details> 

<details>  
<summary>Задание:</summary>  
<p>Научитесь обрабатывать запросы с минус-словами. Прежние условия сохраняются:</p>

<ul>
<li>слова в документах и запросах разделены ровно одним пробелом;</li>
<li>перед первым словом и после последнего пробелов нет;</li>
<li>сами слова состоят только из букв.</li>
</ul>

<p>Единственное нововведение: запрос может содержать минус-слова — слова с минусом в начале. В документе минус-слов быть не может.</p>

<h3>Пример</h3>

<p><strong>Ввод</strong></p>

<pre><code>и в на
3
белый кот и модный ошейник
пушистый кот пушистый хвост
ухоженный пёс выразительные глаза
пушистый ухоженный кот -ошейник
</code></pre>

<p><strong>Вывод</strong></p>

<pre><code>{ document_id = 1, relevance = 2 }
{ document_id = 2, relevance = 1 }
</code></pre>

<h3>Комментарии</h3>

<p>Документ 0 не подходит из-за слова «ошейник», запрещённого в запросе.</p>

<p>С документом 1 запрос пересекается по двум словам «пушистый» и «кот», а с документом 2 — только по слову «ухоженный».</p>

<h3>Подсказка</h3>

<p>Минус-слова запроса должны обрабатываться после плюс-слов. Каждый документ, где есть минус-слово, надо удалить из словаря «документ → релевантность».</p>

<p>Для хранения запроса удобно создать структуру <code>Query</code> с двумя векторами слов: плюс- и минус-словами. Возвращать эту структуру по строке запроса нужно в новом приватном методе — <code>ParseQuery</code>.</p>

<p>После сравнения первого символа с <code>'-'</code> не забудьте отрезать этот минус вызовом <code>.substr(1)</code>, а затем проверить результат по словарю стоп-слов.</p>
</details> 
