<details>  
<summary>Введение:</summary>
<h1>Операции с целочисленными типами</h1>

<p>Чтобы сложить дроби, человек сначала приводит их к общему знаменателю. Чтобы сравнить разные целочисленные типы или произвести над ними арифметические операции, компилятор приводит их к единому типу.</p>

<ul>
<li>Все типы, размер которых меньше <code>int</code>, компилятор приводит к <code>int</code>.</li>
<li>Когда размер разных целочисленных типов равен <code>int</code> или превышает его, меньший тип преобразуется к большему.</li>
<li>Если размер типов одинаковый, но один из них беззнаковый, — компилятор приводит знаковый к беззнаковому.</li>
</ul>

<p>Это мы увидели на примере рейтингов, когда делили <code>int</code> на <code>size_t</code>. Если <code>int</code> и <code>size_t</code> имеют размер четыре байта, компилятор приводит оба типа данных к <code>size_t</code>, так как это беззнаковый тип. Если размер <code>size_t</code> — восемь байт, а <code>int</code> — четыре байта, <code>size_t</code> снова побеждает, потому что он больше.</p>

<p>Допустим, мы забыли правила преобразования типов. Компилятор напомнит — достаточно специально вызвать ошибку компиляции, связанную с этим типом. Например, прибавить к целому числу то, что прибавить невозможно. Из сообщения об ошибке компиляции поймём, как преобразование типов будет происходить в данном случае.</p>

<p>Сравним знаковое и беззнаковое число:</p>

<pre><code class="language-cpp">int x = -1;
unsigned y = 1;
cout &lt;&lt; (x &lt; y) &lt;&lt; endl;
```Сделаем код компактнее:

```cpp
cout &lt;&lt; (-1 &lt; 1) &lt;&lt; endl;  //сравниваем два числа напрямую
</code></pre>

<p>Теперь всё сравнивается ожидаемо: как вы помните, по умолчанию числа имеют тип <code>int</code>. Чтобы воспроизвести предыдущий пример и сделать единицу беззнаковой, добавим суффикс <code>u</code>:</p>

<pre><code class="language-cpp">cout &lt;&lt; (-1 &lt; 1u) &lt;&lt; endl;
</code></pre>

<p>Суффикс <code>u</code> (или <code>U</code>) показывает, что литерал в коде относится к типу <code>unsinged int</code>. То есть:</p>

<ul>
<li>тип литерала <code>1</code> — <code>int</code>;</li>
<li>тип литерала <code>1u</code> — <code>unsigned int</code>.</li>
</ul>

<p>Запустим код и увидим warning — компилятор предупреждает, что мы сравниваем знаковое и беззнаковое числа. Предупреждение полезно. Но код всё равно скомпилируется, и переполнение мы не заметим. Этого можно избежать. В тренажёре предупреждения приравниваются к ошибкам, и опасный код не компилируется. Настройте свою IDE так же. Ниже — инструкция для Eclipse.</p>

<ul>
<li>Зайдите в <strong>Project</strong> ⇒ <strong>Properties</strong>.</li>
<li>В <strong>Properties</strong> откройте <strong>С / С ++ Build</strong> ⇒ <strong>Settings</strong>.</li>
<li>В открывшемся меню выберите <strong>Warnings</strong>.</li>
<li>Поставьте галочку в пункт <strong>Warnings as errors</strong> (англ. «считать предупреждения ошибками»).</li>
<li>Примените изменения и снова запустите компиляцию. Код не скомпилируется, потому что все предупреждения стали ошибками.</li>
<li>Оставьте эту настройку, и опасный код не пройдёт.</li>
</ul>

</details>  

<details>  
<summary>Теория:</summary>  
<h1>Техника безопасности</h1>
<p>Логические и арифметические операции с целочисленными типами могут вызвать внезапное переполнение. Та же проблема подстерегает при итерации по вектору циклом <code>for</code>.</p>

<p>Проитерируемся по вектору циклом <code>for</code> с индексом <code>i</code>. Выведем сам индекс и содержимое по этому индексу:</p>

<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
    vector&lt;int&gt; v = {4, 5};
    for (int i = 0; i &lt; v.size(); ++i) {
        cout &lt;&lt; i &lt;&lt; &quot; &quot;s &lt;&lt; v[i] &lt;&lt; endl;
    }
}
</code></pre>

<p>Убедимся, что компилятор считает предупреждения ошибками. Скомпилируем код в этом придирчивом режиме и увидим:</p>

<pre><code>comparison of integer expressions of different signedness: ‘int’ and ‘std::vector&lt;int&gt;::size_type’ {aka ‘long unsigned int’}
</code></pre>

<p>Действительно, тип переменной <code>i</code> знаковый, а тип выражения <code>v.size()</code> — беззнаковый. Сравнивать их опасно, потому что переменная <code>i</code> может быть отрицательной.</p>

<p>Есть два способа решить проблему:</p>

<ul>
<li>объявить переменную <code>i</code> с типом <code>size_t</code> — тогда предупреждений от компилятора не будет;</li>
<li>перед сравнением привести <code>v.size()</code> к знаковому типу.</li>
</ul>

<p>Выбор из этих двух вариантов — дело вкуса. Часто команды разработчиков договариваются не только о том, как называть функции и расставлять пробелы, но и о подходе к использованию беззнаковых типов.</p>

<p>Мы остановимся на втором способе. Применим оператор <code>static_cast</code>, чтобы привести <code>v.size()</code> к <code>int</code>:</p>

<pre><code class="language-cpp">vector&lt;int&gt; v = {4, 5};
for (int i = 0; i &lt; static_cast&lt;int&gt;(v.size()); ++i) {
    cout &lt;&lt; i &lt;&lt; &quot; &quot;s &lt;&lt; v[i] &lt;&lt; endl;
}
</code></pre>

<p>Когда явно приводим <code>v.size()</code> к типу <code>int</code>, нужно быть уверенными, что размер вектора не превысит 2^31 − 1. Иначе случится переполнение. Правда, векторы такого размера встречаются довольно редко: несколько гигабайт оперативной памяти под одну переменную — это не шутки.</p>

<p>В нашем случае переполнения нет. Код компилируется и запускается:</p>

<pre><code>0 4
1 5
</code></pre>

<p>Рассмотрим другой пример. У нас есть вектор целых чисел. Мы хотим перебрать в нём все элементы, кроме последнего. Напишем цикл по индексам от 0 до <code>v.size() − 1</code> и выведем все такие элементы:</p>

<pre><code class="language-cpp">vector&lt;int&gt; v = {1, 4, 6};
for (size_t i = 0; i &lt; v.size() - 1; ++i) {
    cout &lt;&lt; v[i] &lt;&lt; endl;
}
</code></pre>

<p>Здесь мы решились объявить индекс беззнаковым, ведь он не бывает отрицательным. При запуске видим все элементы, кроме последнего:</p>

<pre><code class="language-cpp">1
4
</code></pre>

<p>При написании кода важно проверять, что он будет работать в крайних случаях. Например, если вектор пустой и в нём нет последнего элемента. Проверим:</p>

<pre><code class="language-cpp">vector&lt;int&gt; v;
for (size_t i = 0; i &lt; v.size() - 1; ++i) {
    cout &lt;&lt; v[i] &lt;&lt; endl;
}
</code></pre>

<p>Запустим код и увидим, что он упал. Дело в том, что <code>v.size()</code> — это ноль беззнакового типа <code>size_t</code>. Мы вычли единицу и получили максимальное значение типа <code>size_t</code>. Итерируясь от нуля до максимума, попали в чужую память. Программа сломалась.</p>

<p>Чтобы избежать таких сюрпризов, не вычитайте из беззнаковых типов или будьте внимательны при вычитании. Заменим вычитание сложением:</p>

<pre><code class="language-cpp">for (size_t i = 0; i + 1 &lt; v.size(); ++i) {
    cout &lt;&lt; v[i] &lt;&lt; endl;
}
</code></pre>

<p>Такой цикл будет работать корректно и для пустого, и для непустого вектора.</p>

<p>Теперь проитерируемся по вектору в обратную сторону. Что может пойти не так?</p>

<pre><code class="language-cpp">vector&lt;int&gt; v = {1, 4, 5}; 
for (size_t i = v.size() - 1; i &gt;= 0; --i) {
    cout &lt;&lt; v[i] &lt;&lt; endl;
}
</code></pre>

<p>При запуске код выведет много интересного, а потом упадёт. Проблема снова в переполнении: после итерации с нулевым <code>i</code> индекс уменьшится на единицу, переполнится — и станет максимальным значением типа <code>size_t</code>. Наивно было писать в цикле условие <code>i &gt;= 0</code>: для беззнакового <code>i</code> оно верно всегда. А для пустого вектора вдобавок произойдёт переполнение в выражении <code>v.size() − 1</code>. Чтобы решить проблему, перепишем заголовок цикла <code>for</code>. Сделаем замену переменной (привет матанализу), оставив прежний смысл <code>i</code>. Проитерируемся не <code>i</code>, а индексом, который на единицу больше:</p>

<pre><code class="language-cpp">vector&lt;int&gt; v = {1, 4, 5};
for (size_t k = v.size(); k &gt; 0; --k) {
    const size_t i = k - 1;
    cout &lt;&lt; v[i] &lt;&lt; endl;
}
</code></pre>

<p>Успех!</p>

<pre><code class="language-cpp">5
4
1
</code></pre>

<p>Встаёт вопрос, какие типы использовать — знаковые или беззнаковые. Это каждый разработчик на С++ решает самостоятельно. У вас два пути:</p>

<ol>
<li>Следовать семантике значений. Если у переменной по смыслу не бывает отрицательных значений — объявлять её беззнаковой. Минус: придётся помнить все опасности преобразования знаковых и беззнаковых типов.</li>
<li>Избегать беззнаковых типов. То есть использовать <code>static_cast</code> и приводить все беззнаковые типы к знаковым. Минус: <code>static_cast</code> будет встречаться в вашем коде довольно часто.</li>
</ol>

<p>Вы узнали, чем опасны операции с беззнаковыми типами, и увидели, как предотвратить проблемы. Далее разберём перечисления.</p>

</details>  

<details>  
<summary>Задание:</summary> 
<p>Напишите функцию <code>PrintDocuments</code>, принимающую вектор документов и два числа: <code>skip_start</code> и <code>skip_finish</code>. Пусть функция сортирует документы по убыванию рейтинга и выводит документы в таком порядке, пропустив <code>skip_start</code> документов с наибольшим рейтингом и <code>skip_finish</code> с наименьшим. Считайте, что рейтинги не повторяются.</p>

<p>Числа на входе функции могут быть сколь угодно большими: ваша программа должна обрабатывать их корректно и не падать. Если требуется пропустить все документы или даже больше, не выводите ничего. Вектор документов может быть пустым, <code>skip_start</code> и <code>skip_finish</code> не обязательно меньше размера вектора. Формат вывода документов — в примере:</p>

<p><strong>Пример</strong></p>

<pre><code class="language-cpp">PrintDocuments(
    {
        {100, 5},
        {101, 7},
        {102, -4},
        {103, 9},
        {104, 1}
    },
    1,
    2
);
</code></pre>

<p><strong>Вывод</strong></p>

<pre><code>{ id = 101, rating = 7 }
{ id = 100, rating = 5 }
</code></pre>

<h3>Подсказка</h3>

<p>Объявите индекс в цикле типа <code>size_t</code> и не вычитайте из <code>documents.size()</code>. Cтоит проверить, что не происходит переполнения, когда числа на входе <code>PrintDocuments</code> оказываются предельно большими.</p>

</details>  
